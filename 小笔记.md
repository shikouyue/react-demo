# 1.闭包

**1.1什么是闭包？**

闭包是指有权访问另外一个函数作用域中的变量的函数。可以理解为(一个函数作用域能够访问另一个函数作用域的变量的函数)

**1.2闭包的实际应用**

**（1）react中函数柯里化**、

**（2）React中函数式组件hooks的React.useEffect模仿生命周期即将销毁钩子时候用到**

  **(3)   防抖**

**（3）在函数执行之前为要执行的函数提供具体参数，如react表单传值**

```react
<Input value = {this.state.name} onChange = {(e) => {this.changeInput(‘name’,e)} } style = {undefined{width:“150px”}} placeholder=“姓名” />
<Input value = {this.state.phone} onChange = {this.changeInput('phone') } style = {undefined{width:“150px”}} placeholder=“手机号” />
```

在[react](https://so.csdn.net/so/search?from=pc_blog_highlight&q=react)中input的value是通过this.state.value动态绑定的,动态的修改需要通过onChange事件,但是如果有好多个input需要动态修改,但是事件又是一样的,只是value的值不一样,这时候就需要onChange事件的复用了

```react
/input onchange触发
	changeInput = (type, e) => {
		return ()=>{
            this.setState({
			//setState 里 key如果传一个变量会自动被处理为一个字符串而不是变 解决方案 给key加一个[]
			[type] : e.target.value
		})
        }
	}
```

**（4）变量私有化，使用闭包代替全局变量**

全局变量有变量污染和变量安全等问题

假设我们在做一个游戏，在写其中关于「还剩几条命」的代码。

所以我们不能让别人「直接访问」这个变量。怎么办呢？

用局部变量。

但是用局部变量别人又访问不到，怎么办呢？

暴露一个访问器（函数），让别人可以「间接访问」。

```text
function(){

  var lives = 50

  window.奖励一条命 = function(){
    lives += 1
  }

  window.死一条命 = function(){
    lives -= 1
  }

}()
```

# 2.如何解决闭包变量污染?

**使用闭包的注意点**
（1）  性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

```
function  showId() {
    var el = document.getElementById("app")
    var id  = el.id
    el.onclick = function(){
      aler(id)   // 这样会导致闭包引用外层的el，当执行完showId后，el无法释放
    }
    el = null    // 主动释放el
}
```

（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

# 3.react中，函数式组件和类组件的优缺点

1.类组件的性能消耗比较大，因为类组件需要创建类组件的实例，而且不能销毁。

2.函数式组件性能消耗小，因为函数式组件不需要创建实例，渲染的时候就执行一下，得到返回的react元素后就直接把中间量全部都销毁。

函数式组件是不能有状态的，但是现在有了react hooks，也可能有状态了。

# 4.自己封装过什么组件

**封装过List组件**

```react
const CardList = ({title, extra, children, ...restProps})=>{
  return(
    <div>
      <div className={style.card2} {...restProps}>
        <nav>{title} <span className={style.details}>{extra}</span></nav>
        {React.Children.map(
          children,
          child => (child ? React.cloneElement(child, {  }) : child)
        )}
      </div>
    </div>
  )
}
const Card = ({title,children,...restProps})=>{
  return(
    <div>
      <div className={style.list1} {...restProps}>
        <span>{title} {children}</span>
      </div>
    </div>
  )
}

<CardList title={`${obj.stationName}站`} extra={<span onClick={()=>{this.jump({obj})}}>查		看当天数据</span>} key={index}>
	<Card title="当天进站列车：">
		{obj.trainCount||0} 车次
	</Card>
</CardList>

```

![image-20211130170104224](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211130170104224.png)

**header组件**

```react
<Header
        onBack={() => goback(props)}
        className="navbar"
        rightContent={props.rightContent}
      >
        {props.children}
</Header>
```

**Sticky组件**

```react
import React, { useRef, useEffect } from 'react'
import styles from './index.module.css'

export default function Sticky(props) {
  useEffect(() => {
    window.addEventListener('scroll', handleScroll)
    return () => {
      window.removeEventListener('scroll', handleScroll)
    }
    // eslint-disable-next-line
  }, [])
  const placeholderRef = useRef()
  const contentRef = useRef()

  const handleScroll = () => {
    const placeholderEl = placeholderRef.current
    const contentEl = contentRef.current

    const { top } = placeholderEl.getBoundingClientRect()
    if (top < 0) {
      // 吸顶
      contentEl.classList.add(styles.fixed)
      placeholderEl.style.height = props.height
    } else {
      // 取消吸顶
      contentEl.classList.remove(styles.fixed)
      placeholderEl.style.height = '0px'
    }
  }

  return (
    <div>
      {/* 占位元素 */}
      <div ref={placeholderRef} />
      {/* 内容元素 */}
      <div ref={contentRef}>{props.children}</div>
    </div>
  )
}

```



# 5.手写Promise

**5.1promise理解**

从语法上来说: Promise 是一个构造函数

从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/

失败的结果值



**5.2promise的状态改变**

\1. pending 变为 resolved

\2. pending 变为 rejected

说明: 只有这 2 种, 且一个 promise 对象只能改变一次

 无论变为成功还是失败, 都会有一个结果数据

 成功的结果数据一般称为 value, 失败的结果数据一般称为 reason



**5.3手写promise步骤**

1.（基本）resolve与reject函数实现=>添加属性PromiseState（pending等待、fulfilled成功、rejected失败）、PromiseResult存放接下来要处理的值（resolve和reject传进来的参数）为了接下来和.then方法共用

2.throw抛出异常错误要用try catch接一下，不然会报错，然后在用catch中用reject把错误处理成失败的结果

3.状态只能修改一次，就根据构造函数定义过的变量PromiseState判断是否为pending，是的话才能继续执行resolve和reject函数

4.then要定义在原型对象上，这样实例对象才能用过原型链访问到then方法

5.正常new promise实例对象和调用then方法是同步的，当promise中有异步任务执行时，then方法会先调用，这时就应该给promise指定成功和失败的事件，可以给promise构造函数中添加一个存放成功或失败回调函数的属性，等promise异步任务执行完再调用这个属性

6.then方法要返回一个promise对象，这时就要在then方法中return一个promise对象，返回的promise状态和值要根据实例对象传进来的是普通值还是promise函数，非Promise值直接返回状态成功，值的话有返回值就是返回值，没有返回值 值就是undfined，传进来的是promise函数就通过then方法进行递归，直到不是promise对象是普通值结束，将这个最终值传递给promise

7.promise的中的catch方法可以捕获异常进行异常穿透，核心原理是先在then方法判断是否是一个错误的值，是错误的值就直接throw错误的值给下一个then方法，因为try catch不会执行成功的回调 最后catth方法捕获错误并输出

8.resolve、reject、all、race都是定义在构造函数上的静态方法（只能由构造函数Promise调用，不能由实例对象调用）

9.all就是返回一个新的 promise 对象, 只有 promises 中所有 promise 都产生成功 value 时, 才最终成功, 只要有一个失败就直接失败，我的方法是定义一个全部变量用来计数，成功一个变量就加一，直到变量值等于promise.all数组长度值时在执行成功的回调，有一个失败就直接执行失败的回调函数，因为有peeding判断，状态只能修改一次，最后会返回一个有这个失败的状态和值的promise，谁在数组前面最先失败就返回谁

10.race返回一个 promise，一旦某个 promise最先 成功或失败， 返回的 promise 就是成功或失败的，这个就是挨个执行，哪个执行的快就直接执行成功或失败的回调，因为有peeding判断，状态只能修改一次，最后会返回一个有这个失败的状态和值的promise

# 6.自己封装过什么hooks   

**useFetch**

获取数据是我每次创建React应用时都会做的事情。我甚至在一个应用程序中进行了好多个这样的重复获取。

不管我们选择哪种方式来获取数据，Axios、Fetch API，还是其他，我们很有可能在React组件序中一次又一次地编写相同的代码。

这个 Hook 接受两个参数，一个是获取数据所需查询的**URL**，另一个是表示要应用于请求的选项的对象**options**。

我们使用 Fetch API来发出请求。我们会传递`URL`和 `options`。一旦 Promise 被解决，我们就通过解析响应体来检索数据。为此，我们使用`json()`方法。获取到的数据存储在一个React state 变量中

这里，我们还需要处理网络错误，以防我们的请求出错。所以我们要用另一个 `state` 变量来存储错误。这样我们就能从 Hook 中返回它并能够判断是否发生了错误

最后，向用户表明异步请求的状态通常是一个好做法，比如在呈现结果之前显示 loading。

因此，我们添加第三个 state 变量来跟踪请求的状态。在请求之前，将`loading`设置为`true`，并在请求之后完成后设置为`false`。

```react
import { useState, useEffect } from 'react';

const useFetch = (url = '', options = null) => {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    let isMounted = true;

    setLoading(true);

    fetch(url, options)
      .then(res => res.json())
      .then(data => {
        if (isMounted) {
          setData(data);
          setError(null);
        }
      })
      .catch(error => {
        if (isMounted) {
          setError(error);
          setData(null);
        }
      })
      .finally(() => isMounted && setLoading(false));

    return () => (isMounted = false);
  }, [url, options]);

  return { loading, error, data };
};

export default useFetch;

const App = () => {
  const { loading, error, data = [] } = useFetch(
    'https://hn.algolia.com/api/v1/search?query=react'
  );
```

**useEventListener**

这个 Hook 负责在组件内部设置和清理事件监听器。

这样，我们就不需要每次添加事件监听器,做重复的工作。

这个函数有几个参数，`eventType` 事件类型，`listener` 监听函数，`target` 监听对象，`options` 可选参数。

首先，我们需要确保`target` 是否支持`addEventListener`方法。否则，我们什么也不做。

然后，我们可以添加实际的事件监听器并在卸载函数中删除它。

```react
import { useEffect, useRef } from 'react';

const useEventListener = (
  eventType = '',
  listener = () => null,
  target = null,
  options = null
) => {
  const savedListener = useRef();

  useEffect(() => {
    savedListener.current = listener;
  }, [listener]);

  useEffect(() => {
    if (!target?.addEventListener) return;

    const eventListener = event => savedListener.current(event);

    target.addEventListener(eventType, eventListener, options);

    return () => {
      target.removeEventListener(eventType, eventListener, options);
    };
  }, [eventType, target, options]);
};

export default useEventListener;



useEventListener(
    'mousedown',
    event => {
      if (event.defaultPrevented) {
        return; // Do nothing if the event was already processed
      }
      if (dialogRef.current && !dialogRef.current.contains(event.target)) {
        console.log('Click outside detected -> closing dialog...');
        onClose();
      }
    },
    window
  );
	
```

**useLocalStorage**

这个 Hook 主要有两个参数，一个是 `key`，一个是 `value`。

返回的值为localStorage存的值和改变localStorage存的值的方法

我们创建将与 localStorage 同步的React状态变量。

```react
const [state, setState] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.log(error);
      return initialValue;
    }
  });
```

在这里，我们使用惰性初始化来读取 `localStorage` 以获取键的值，如果找到该值，则解析该值，否则返回传入的`initialValue`。

如果在读取 `localStorage` 时出现错误，我们只记录一个错误并返回初始值。

此函数同时更新React状态和 `localStorage` 中的相应键/值。

最后，我们返回状态值和我们的自定义更新函数。

现在可以使用`useLocalStorage` hook 将组件中的任何数据持久化到`localStorage`中。

```react
import { useState } from 'react';

const useLocalStorage = (key = '', initialValue = '') => {
  const [state, setState] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  const setLocalStorageState = newState => {
    try {
      const newStateValue =
        typeof newState === 'function' ? newState(state) : newState;
      setState(newStateValue);
      window.localStorage.setItem(key, JSON.stringify(newStateValue));
    } catch (error) {
      console.error(`Unable to store new value for ${key} in localStorage.`);
    }
  };

  return [state, setLocalStorageState];
};

export default useLocalStorage;

const [appSettings, setAppSettings] = useLocalStorage(
    'app-settings',
    defaultSettings
  );
```



# 7.ES6新特性

**1. let const**

let 表示申明变量。const 表示申明常量

**2. 模块字符串``**

可以使用反引号````来进行字符拼接。${}

**3. 解构**

可以使用{}来对数组和对象进行解构。

{A:{B:C}} 连续解构赋值加重命名 => {A:{B:D}},重命名为D

**4. 函数的参数默认值**

function printText(text = 'default') {    console.log(text); }

**5. Spread / Rest 操作符...**

1.数组（扩展运算符）

（1）解构赋值
扩展运算符(spread)就是我们知道的三个点(...)，它就好像rest参数的逆运算，***将一个数组转为用逗号分隔的参数序列。***

（2）复制数组

（3）合并数组

2.对象

拓展运算符（...）用于**取出 \*参数对象\* 所有 \*可遍历属性\* 然后拷贝到当前对象。**
**基本用法**

合并对象

3.函数

不定参数用来表示不确定参数个数，形如，...变量名，由...加上一个具名参数标识符组成。**具名参数只能放在参数组的最后，并且有且只有一个不定参数。**
**基本用法**

```
function f(...values){
    console.log(values.length);
}
f(1,2);      //2
f(1,2,3,4);  //4
function f(x,y,z,v,w){
    console.log(x,y,z,v,w)
}
var args = [0,1,5];
var args1 = [0,1];
f(-1,...args,2,...[3]);//-1, 0, 1, 5, 2
f(-1,...args1,2,...[3]);//-1, 0, 1, 2, 3
```

**6. 箭头函数**

- 不需要 function 关键字来创建函数
- 省略 return 关键字
- this始终指向函数申明时所在作用域下的this值

**7. for of遍历数组**

for-in循环存在缺陷：循环会遍历对象自身的和继承的可枚举属性(不含Symbol属性)



1. for-of 无法遍历 不可迭代对象
2. for-of这个方法避开了for-in循环的所有缺陷
3. 与forEach()不同的是，它可以正确响应break、continue和return语句 

可迭代对象包括: Array，Map，Set，String，TypedArray，arguments等等



for-of 遍历的是值，for-in遍历的是key

- for of遍历的是键值对中的值
- for in遍历的是键值对中的键

**导入导出**

- 导入improt
- 导出export default

**promise**

Promise 用于更优雅地处理异步请求。

 **async/await**

比promise更好的解决了回调地狱

**Symbol**

ES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。

Symbol 函数栈不能用 new 命令，因为 Symbol 是原始数据类型，不是对象

**Set集合**

存储任何类型的唯一值，即集合中所保存的元素是不重复的。类数组结构。

```js
arr = [1,2,3,1]
let arrNew = new Set(arr)
arrNew = [1,2,3]
```

类数组不是数组，要转化为数组`Array.form(arrNew)`这样arrNew才是数组了



# 8.防抖节流

**防抖**：所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。

应用场景：

- 表单输入验证
- 表单输入触发搜索 ajax
- resize/scroll/touch/mouseove 事件

代码：

```react
const debounce = (fn, wait = 1000, immediate = false) => {
        let timer = null;

        return function debounced() {
          if (timer) clearTimeout(timer);
          if (immediate && !timer) {
            fn();

            timer = setTimeout(() => {
              timer = null;
            }, wait);
            return;
          }

          timer = setTimeout(() => {
            fn();
            timer = null;
          }, wait);
        };
      };
```

**节流**：在 n 秒中无论事件事件触发多少次只执行一次函数

应用场景：

- 编辑器语法校验
- resize/scroll/touch/mouseove 事件
- 表单输入联想

代码：

```react
const throttle = (
        fn,
        wait = 1000,
        immediate = false,
        options = { leading: false, trailing: true }
      ) => {
        let previous = 0;
        let timer = null;

        let { leading, trailing } = options;

        return function throttled() {
          const now = +new Date();

          if (leading === false && !previous) previous = now;
          if (timer) clearTimeout(timer);

          if (now - previous > wait) {
            fn();
            previous = now;
          } else if (trailing) {
            timer = setTimeout(() => {
              fn();
              previous = 0;
              timer = null;
            }, wait);
          }
        };
      };
```



# 9.性能优化

**1.路由懒加载**

React.lazy(()=>import('组件路径'))  +   <Suspense>

![image-20211124215855297](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211124215855297.png)

![image-20211124215811440](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211124215811440.png)

​	![image-20211124215926021](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211124215926021.png)

**2.图片懒加载**

长列表优化（长列表产生性能问题的元素：大量DOM节点的重绘和重排）：懒加载，react-virtualized（头条项目）

```react
import React from 'react';
import ReactDOM from 'react-dom';
import LazyLoad from 'react-lazyload';
import MyComponent from './MyComponent';

const App = () => {
  return (
    <div className="list">
      <LazyLoad height={200}>
        <img src="tiger.jpg" /> /*
                                  Lazy loading images is supported out of box,
                                  no extra config needed, set `height` for better
                                  experience
                                 */
      </LazyLoad>
      <LazyLoad height={200} once >
                                /* Once this component is loaded, LazyLoad will
                                 not care about it anymore, set this to `true`
                                 if you're concerned about improving performance */
        <MyComponent />
      </LazyLoad>
      <LazyLoad height={200} offset={100}>
                              /* This component will be loaded when it's top
                                 edge is 100px from viewport. It's useful to
                                 make user ignorant about lazy load effect. */
        <MyComponent />
      </LazyLoad>
      <LazyLoad>
        <MyComponent />
      </LazyLoad>
    </div>
  );
};

ReactDOM.render(<App />, document.body);
```

**3.antd组件按需加载**

**4.借助shouldComponentUpdate生命周期函数，避免无谓的组件的render函数的运行**

```react
shouldComponentUpdate(nextProps,nextState){

	return !this.state.data === nextState.data

}
```

**PureComponent**

`React.PureComponent`  , `React.PureComponent` 通过props和state的浅对比来实现 `shouldComponentUpate()`。如果对象包含复杂的数据结构(比如对象和数组)，他会浅比较，如果深层次的改变，是无法作出判断的，`React.PureComponent` 认为没有变化，而没有渲染视图。

解决办法：

```react

 <Text data={{ ...data }} />
```

无论组件是否是 `PureComponent`，如果定义了 `shouldComponentUpdate()`，那么会调用它并以它的执行结果来判断是否 `update`。在组件未定义 `shouldComponentUpdate()` 的情况下，会判断该组件是否是 `PureComponent`，如果是的话，会对新旧 `props、state` 进行 `shallowEqual` 比较，一旦新旧不一致，会触发渲染更新。

**useMemo 和 useCallback进行性能优化**

`useMemo` 和 `useCallback` 接收的参数都是一样,第一个参数为回调 第二个参数为要依赖的数据

共同作用：
1.仅仅 `依赖数据` 发生变化, 才会重新计算结果，也就是起到缓存的作用。

两者区别：
1.`useMemo` 计算结果是 `return` 回来的值, 主要用于 缓存计算结果的值 ，应用场景如： 需要 计算的状态
2.`useCallback` 计算结果是 `函数`, 主要用于 [缓存函数](https://www.zhihu.com/search?q=缓存函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A188602024})，应用场景如: 需要缓存的函数，因为[函数式组件](https://www.zhihu.com/search?q=函数式组件&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A188602024})每次任何一个 state 的变化 整个组件 都会被重新刷新，一些函数是没有必要被重新刷新的，此时就应该缓存起来，提高性能，和减少资源浪费。

```react
//useMemo
export default function WithMemo() {
    const [count, setCount] = useState(1);
    const [val, setValue] = useState('');
    const expensive = useMemo(() => {
        console.log('compute');
        let sum = 0;
        for (let i = 0; i < count * 100; i++) {
            sum += i;
        }
        return sum;
    }, [count]);
 
    return <div>
        <h4>{count}-{expensive}</h4>
        {val}
        <div>
            <button onClick={() => setCount(count + 1)}>+c1</button>
            <input value={val} onChange={event => setValue(event.target.value)}/>
        </div>
    </div>;
}
```

```react
//useCallBack
import React, { useState, useCallback, useEffect } from 'react';
function Parent() {
    const [count, setCount] = useState(1);
    const [val, setVal] = useState('');
 
    const callback = useCallback(() => {
        return count;
    }, [count]);
    return <div>
        <h4>{count}</h4>
        <Child callback={callback}/>
        <div>
            <button onClick={() => setCount(count + 1)}>+</button>
            <input value={val} onChange={event => setVal(event.target.value)}/>
        </div>
    </div>;
}
 
function Child({ callback }) {
    const [count, setCount] = useState(() => callback());
    useEffect(() => {
        setCount(callback());
    }, [callback]);
    return <div>
        {count}
    </div>
}
```

# 11.JS数据类型和如何判断数据类型

**js** 中数据类型分为原始数据类型与引用数据类型

**基本数据类型**

- number
- string
- boolean
- null
- undefined
- symbol (ES6)
- bigint (ES10)

**引用数据类型**

- object

在引用数据类型 **object** 中包括**function**/**array**/**object**

看到这里我们可以发现总共是 **8** 种数据类型



**ES6新增：Symbol**

这种数据类型主要用于创建一个独一无二的标识

**ES10新增：Bigint**

JavaScript 中 `Number` 类型只能安全的表示`-(2^53-1)`至 `2^53-1` 范的值，即 `Number.MIN_SAFE_INTEGER` 至 `Number.MAX_SAFE_INTEGER`，超出这个范围的整数计算或者表示会丢失精度。****

为解决此问题，ES2020 提供一种新的数据类型：`BigInt`。使用 `BigInt` 有两种方式：

1. 在整数字面量后面加`n`。

```go
var bigIntNum = 9007199254740993n;
```

1. 使用 `BigInt` 函数。

```go
var bigIntNum = BigInt(9007199254740);
var anOtherBigIntNum = BigInt('9007199254740993');
```



**判断数据类型**

**1: typeof**

返回数据类型，包含这7种： number、boolean、symbol、string、object、undefined、function。

typeof null  返回类型错误，返回object

引用类型，除了function返回function类型外，其他均返回object。

其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型，没有错，但不是我们想要的结果。

```js
typeof ''; // string 有效
typeof 1; // number 有效
typeof true; //boolean 有效
typeof undefined; //undefined 有效
typeof null; //object 无效
typeof [] ; //object 无效
typeof new Function(); // function 有效
typeof new Date(); //object 无效
typeof new RegExp(); //object 无效
```

**2.instanceof**

instanceof 是用来判断 A 是否为 B 的实例对，表达式为：A instanceof B，如果A是B的实例，则返回true,否则返回false。 在这里需要特别注意的是：**instanceof检测的是原型**

```js
 console.log("123" instanceof String); //false
 console.log(new String("111") instanceof String); //true
 console.log(123 instanceof Number); //false
 console.log(false instanceof Boolean); //false
 console.log(NaN instanceof Number); //false
 console.log(bigIntNum instanceof BigInt); //false
 console.log(a instanceof Symbol); //false

 console.log(function fn() {} instanceof Function); //true
 console.log([] instanceof Array); //true
 console.log({} instanceof Object); //true
 console.log(new Date() instanceof Date); //true
```

**3.toString 这个是最完美的**

toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。

对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息

```js
console.log(Object.prototype.toString({})); //[object Object]
console.log(Object.prototype.toString.call("")); // [object String]
console.log(Object.prototype.toString.call(1)); // [object Number]
console.log(Object.prototype.toString.call(true)); // [object Boolean]
console.log(Object.prototype.toString.call(Symbol())); //[object Symbol]
console.log(Object.prototype.toString.call(undefined)); // [object Undefined]
console.log(Object.prototype.toString.call(null)); // [object Null]
console.log(Object.prototype.toString.call(new Function())); // [object Function]
console.log(Object.prototype.toString.call(new Date())); // [object Date]
console.log(Object.prototype.toString.call([])); // [object Array]
console.log(Object.prototype.toString.call(new RegExp())); // [object RegExp]
console.log(Object.prototype.toString.call(new Error())); // [object Error]
console.log(Object.prototype.toString.call(document)); // [object HTMLDocument]
console.log(Object.prototype.toString.call(window)); //[object Window] window 是全局对象 
```



**js非严格相等（==）比较表**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190507192755388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FTbWFsbFByb2dyYW1tZXI=,size_16,color_FFFFFF,t_70)

如果操作数是一个对象，返回true
如果操作数是一个空字符串，返回false
如果操作数是一个非空字符串，返回true
如果操作数是数值0，返回false
如果操作数是任意非0数值（包括Infinity），返回true
如果操作数是null，返回false
如果操作数是NaN，返回false
如果操作数是undefined，返回false




基本上 undefined、null、NaN、0 、“ ” 和 false 本身都是 false

# 12.数组去重

**一、利用ES6中的 Set 方法去重**

　　注：Set为ES6新增的一个对象，允许存储任何类型（原始值或引用值）的唯一值

```js
let arr = [1, 0, 0, 2, 9, 8, 3, 1, 3, 1];
const newArr = new Set(arr);
console.log(newArr);  //Set(6) {1, 0, 2, 9, 8, …}
console.log([...newArr]); //[1, 0, 2, 9, 8, 3]
console.log(Array.from(newArr)); //[1, 0, 2, 9, 8, 3]
```

**二、使用双重for循环，再利用数组的splice方法去重（ES5常用）**

```js
var arr = [1, 5, 6, 0, 7, 3, 0, 5, 9, 5, 5];
function unique(arr) {
  for (var i = 0, len = arr.length; i < len; i++) {
    for (var j = i + 1, len = arr.length; j < len; j++) {
      if (arr[i] === arr[j]) {
        arr.splice(j, 1);
        j--; // 每删除一个数j的值就减1
        len--; // j值减小时len也要相应减1（减少循环次数，节省性能）
        // console.log(j,len)
      }
    }
  }
  return arr;
}
console.log(unique(arr)); //  [1, 5, 6, 0, 7, 3, 9]
```

**三、利用数组的indexOf方法去重**

　　注：array.indexOf(item,statt) 返回数组中某个指定的元素的位置，没有则返回-1

```js
var arr =[1,-5,-4,0,-4,7,7,3];
function unique(arr){
   var arr1 = [];       // 新建一个数组来存放arr中的值
   for(var i=0,len=arr.length;i<len;i++){
       if(arr1.indexOf(arr[i]) === -1){
           arr1.push(arr[i]);
       }
   }
   return arr1;
}
console.log(unique(arr));    // 1, -5, -4, 0, 7, 3
```

**四、利用数组的sort方法去重（相邻元素对比法）**

　　注：array.sort( function ) 参数必须是函数，可选，默认升序

```js
var arr =  [5,7,1,8,1,8,3,4,9,7];
function unique( arr ){
    arr = arr.sort();
    console.log(arr);

    var arr1 = [arr[0]];
    for(var i=1,len=arr.length;i<len;i++){
        if(arr[i] !== arr[i-1]){
            arr1.push(arr[i]);
        }
    }
    return arr1;
}
console.log(unique(arr))l;   //  1, 1, 3, 4, 5, 7, 7, 8, 8, 9
```

**六、利用数组的includes去重**

　　注：arr.includes(指定元素(必填),指定索引值(可选,默认值为0) )，有值返回true，没有则返回false

```js
var arr = [-1,0,8,-3,-1,5,5,7];
   function unique( arr ){
       var arr1 = [];
       for(var i=0,len=arr.length;i<len;i++){
           if( !arr1.includes( arr[i] ) ){      // 检索arr1中是否含有arr中的值
               arr1.push(arr[i]);
           }
    }
       return arr1;
  }
console.log(unique(arr));      //  -1, 0, 8, -3, 5, 7
```

**七、利用数组的filter方法去重**

注：filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，array.filter(function(currentValue,index,arr), thisValue)

currentValue：当前元素的值(必选参数)、index：当前元素的索引值(可选)、arr：当前元素属于的数组对象(可选)、thisValue：对象作为该执行回调时使用，传递给函数，用作 "this" 的值，默认undefined(可选)

```js
var arr = [1,2,8,9,5,8,4,0,4];
function unique( arr ){
    // 如果新数组的当前元素的索引值 == 该元素在原始数组中的第一个索引，则返回当前元素
    return arr.filter(function(item,index){
        return arr.indexOf(item,0) === index;
    });
}
console.log(unique(arr));    //  [1, 2, 8, 9, 5, 4, 0]
```

**八、利用函数递归去重**

```js
var arr = [1,1,5,6,0,9,3,0,6]
function unique( arr ){
     var arr1 = arr;
     var len = arr1.length;
     arr1.sort((a,b)=>{
         return a-b
     })
     function loop(index){
         if(index >= 1){
            if(arr1[index] === arr1[index-1] ){
                arr1.splice(index,1);
           }
            loop(index - 1);  // 递归loop，然后数组去重
       }
   }
   loop(len-1);
   return arr1
}
console.log(unique(arr));    //   [0, 1, 3, 5, 6, 9]
```

**九、利用ES6中的Map方法去重**

```js
/*
              　　　　创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果。
                */
let arr = [1, 0, 8, 3, -9, 1, 0, -9, 7]
function unique(arr) {
	let map = new Map();
	console.log(map)
	//let arr1 = new Array();      // 数组用于返回结果
	let arr1 = []
    	for (let i = 0, len = arr.length; i < len; i++) {
        	if (map.has(arr[i])) {      // 判断是否存在该key值
            	map.set(arr[i], true);
        	}
        	else {
            	map.set(arr[i], false);
            	arr1.push(arr[i]);
        	}
    	}
    	return arr1;
	}
console.log(unique(arr)); // [1, 0, 8, 3, -9, 7]
```

**十、reduce数组去重**

```jsx
let arr = [1,2,3,4,4,1]
let newArr = arr.reduce((pre,cur)=>{
    if(!pre.includes(cur)){
      return pre.concat(cur)
    }else{
      return pre
    }
},[])
console.log(newArr);// [1, 2, 3, 4]
```

# **找出数组最大值**

1.es6拓展运算符...

```js
Math.max(...arr)
```

2.es5 apply(与方法1原理相同)

```js
Math.max.apply(null,arr)
```

3.for循环

```js
let max = arr[0];
for (let i = 0; i < arr.length - 1; i++) {
    max = max < arr[i+1] ? arr[i+1] : max
}
```

4.数组sort()

```js
arr.sort((num1, num2) => {
    return num1 - num2 < 0
})
arr[0]
```

5.数组reduce

```js
arr.reduce((num1, num2) => {
    return num1 > num2 ? num1 : num2}
)
```



# 数组扁平化

**1. reduce**

遍历数组每一项，若值为数组则递归遍历，否则concat。

```js
function flatten(arr) {  
    return arr.reduce((result, item)=> {
        return result.concat(Array.isArray(item) ? flatten(item) : item);
    }, []);
}
```

reduce是数组的一种方法，它接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。

reduce包含两个参数：回调函数，传给total的初始值

```js
// 求数组的各项值相加的和： 
arr.reduce((total, item)=> {  // total为之前的计算结果，item为数组的各项值
    return total + item;
}, 0);
```

**2. toString & split**

调用数组的toString方法，将数组变为字符串然后再用split分割还原为数组

```js
function flatten(arr) {
    return arr.toString().split(',').map(function(item) {
        return Number(item);
    })
} 
```

因为split分割后形成的数组的每一项值为字符串，所以需要用一个map方法遍历数组将其每一项转换为数值型

**3. join & split**

和上面的toString一样，join也可以将数组转换为字符串

```js
function flatten(arr) {
    return arr.join(',').split(',').map(function(item) {
        return parseInt(item);
    })
}
```

**4. 递归**

递归的遍历每一项，若为数组则继续遍历，否则concat

```js
function flatten(arr) {
    var res = [];
    arr.map(item => {
        if(Array.isArray(item)) {
            res = res.concat(flatten(item));
        } else {
            res.push(item);
        }
    });
    return res;
}
```



# **13.浏览器从输入url到服务器页面渲染的流程**

**1.在浏览器的地址输入URL并按下回车**
**2.浏览器会先查找当前的URL是否存在缓存，并进行对比，判断是否过期**
**3.DNS解析URL所对应的IP**

什么是域名解析* DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录。

**4.根据IP建立TCP连接，期间会有三次握手**

TCP/IP 意味着 TCP 和 IP 在一起协同工作。

TCP 负责应用软件（比如你的浏览器）和网络软件之间的通信。

IP 负责计算机之间的通信。

TCP 负责将数据分割并装入 IP 包，然后在它们到达的时候重新组合它们。

IP 负责将包发送至接受者。

**三次握手**

1. TCP 三次握手的过程如下：
   - 客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口（第一次握手，由浏览器发起，告诉服务器我要发送请求了）
   - 服务器发回一个带 SYN=1， ACK=X+1， Seq=Y 的响应包以示传达确认信息（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）
   - 客户端再回传一个带 ACK=Y+1， Seq=Z 的数据包，代表“握手结束”（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）
2. 为啥需要三次握手？ “三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。

**5.发送HTTP请求**

建立TCP连接后，开始向Web服务器发送HTTP请求报文。

- 请求方法包含 8 种：GET、POST、PUT、DELETE、PATCH、HEAD、OPTIONS、TRACE。

- URL 即请求地址，由 <协议>：//<域名>：<端口号>/<路径>?<参数> 组成

- 协议版本即 http 版本号

  **GET和POST的区别：**

  1. **GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以？分割URL和传输数据，参数之间以&相连，如：login.action?**name=hyddd&password=idontknow&verify=%E4%BD%A0%E5%A5%BD。如果数据是英文字母或数字，则原样发送；如果是空格，转换为+；如果是中文或其他字符，则直接把字符串用BASE64加密，得出如：%E4%BD%A0%E5%A5%BD，其中％XX中的XX为该符号以16进制表示的ASCII码值。
  
     **而与之对应的，POST把提交的数据放置在HTTP包的包体中。**
  
  2. **POST的安全性要比GET的安全性高**。注意：这里所说的安全性和上面GET提到的“安全”不是同个概念。上面“安全”的含义仅仅是不作数据修改，而这里安全的含义是真正的Security的含义。比如：**通过GET提交数据，用户名和密码将明文出现在URL上**，因为：(1)登录页面有可能被浏览器缓存，(2)其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击（CSRF,跨站请求伪造，也被称为：one click attack/session riding）。

**6.服务器处理请求，浏览器接收HTTP的响应**

**服务器处理请求并返回 HTTP 报文**

服务器接受到请求后，对相应的请求作出相应的处理，处理完成后并作出相应的http 响应报文

** 响应行包含：协议版本，状态码，状态码描述 **

状态码规则如下：

- 1xx：指示信息--表示请求已接收，继续处理。
- 2xx：成功--表示请求已被成功接收、理解、接受。
- 3xx：重定向--要完成请求必须进行更进一步的操作。
- 4xx：客户端错误--请求有语法错误或请求无法实现。
- 5xx：服务器端错误--服务器未能实现合法的请求。

**7.浏览器解析渲染页面并构建DOM树**
**8.关闭TCP连接，期间会有四次挥手**

**当数据传送完毕，需要断开 tcp 连接，此时发起 tcp 四次挥手。**

- 发起方向被动方发送报文，Fin、Ack、Seq，表示已经没有数据传输了。并进入 FIN_WAIT_1 状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)
- 被动方发送报文，Ack、Seq，表示同意关闭请求。此时主机发起方进入 FIN_WAIT_2 状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)
- 被动方向发起方发送报文段，Fin、Ack、Seq，请求关闭连接。并进入 LAST_ACK 状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)
- 发起方向被动方发送报文段，Ack、Seq。然后进入等待 TIME_WAIT 状态。被动方收到发起方的报文段以后关闭连接。发起方等待一定时间未收到回复，则正常关闭。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)

# 14.浏览器拿到响应之后是怎么样去渲染页面的

总体来说，关键渲染路径分为六步。

- 创建DOM树(Constructing the DOM Tree)
- 创建CSSOM树(Constructing the CSSOM Tree)
- 执行脚本(Running JavaScript)
- 生成渲染树(Creating the Render Tree)
- 生成布局(Generating the Layout)
- 绘制(Painting)

**1.创建 DOM 树**

从根元素<html>开始，浏览器会把上每个元素或者文本都会创建一个对应的节点，节点上会有他对应的属性，生成一个DOM树

![134550_9Mzf_2608629.png](https://static.oschina.net/uploads/space/2017/0316/134550_9Mzf_2608629.png)

**2.创建CSSOM 树**

CSS是一种渲染阻塞资源(render blocking resource)，它需要完全被解析完毕之后才能进入生成渲染树的环节。CSS并不像HTML那样能执行部分并显示，因为CSS具有继承属性， 后面定义的样式会覆盖或者修改前面的样式。如果我们只使用样式表中部分解析好的样式，我们可能会得到错误的页面效果。所以，我们只能等待CSS完全解析之后，才能进入关键渲染路径的下一环节。

![134751_Uhc2_2608629.png](https://static.oschina.net/uploads/space/2017/0316/134751_Uhc2_2608629.png)

**3.执行JavaScript**

JavaScript是一种解析阻塞资源(parser blocking resource)，它能阻塞HTML页面的解析。

当页面解析到<script>标签，页面解析会暂停，转而加载JavaScript文件（外联的话）并且执行JavaScript。这也是为什么如果JavaScript文件有引用HTML文档中的元素，JavaScript文件必须放在那个元素的后面。

**4.生成渲染树**

渲染树是DOM和CSSOM的结合，是最终能渲染到页面的元素的树形结构表示。也就是说，它包含能在页面中最终呈现的元素，而不包含那些用CSS样式隐藏的元素，比如带有display: none;属性的元素。

**5.生成布局**

布局决定了视口的大小，为CSS样式提供了依据，比如百分比的换算或者视口的总像素值。视口大小是由meta标签的name属性为viewport的内容设置所决定的，如果缺少这个标签，默认的视口大小为980px。

**6.绘制**

最后，页面上可见的内容就会转化为屏幕上的像素点。

绘制过程所需要花费的时间取决于DOM的大小以及元素的CSS样式。有些样式比较耗时，比如一个复杂的渐变背景色比起简单的单色背景需要更多的时间来渲染。

总结：

- 发送请求(Send Request) —— 发送GET请求获取index.html
- 解析HTML(Parse HTML)，再次发送请求 —— 开始解析HTML文件，创建DOM结构，发送请求获取style.css和main.js
- 解析样式文件(Parse Stylesheet) —— 根据style.css生成CSSOM树
- 执行脚本(Evaluate Script) —— 执行main.js
- 生成布局(Layout) —— 基于HTML页面中的meta viewport标签生成布局
- 绘制(Paint) —— 在浏览器页面绘制像素点

# 15.原型和原型链、实例对象和静态对象、类和构造函数、继承

想要继承，就必须要提供个父类（继承谁，提供继承的属性）

![img](https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162054267-1200211276.png)

**一、原型链继承**（通过子类原型对象指向父类新建实例的方法实现继承，优点：父类构造函数、原型对象属性都可继承，缺点：创建子类实例时无法向父类传参，父类有什么就得用什么，且父类原型对象修改，所有子类实例对象的原型属性全部更改）
　　　　 ![img](https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162110117-1744170661.png)
　　　　重点：让新实例的原型等于父类的实例。
　　　　特点：1、实例可继承的属性有：实例的构造函数的属性，父类构造函数属性，父类原型的属性。（新实例不会继承父类实例的属性！）
　　　　缺点：1、新实例无法向父类构造函数传参。
　　　　　　　2、所有新实例都会共享父类实例的属性。（原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！)

**二、借用构造函数继承**（通过子类构造函数用.call()将this指向父类构造函数的方法实现继承，优点：相比原型链继承能传参了，却又不像原型链继承可以继承原型上的属性，而且可以用call指向多个父构造函数，缺点：能传参了，却又不像原型链继承可以继承原型上的属性）
　　　　 ![img](https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162125772-1830945749.png)
　　　　重点：用.call()和.apply()将父类构造函数引入子类函数（在子类函数中做了父类函数的自执行（复制））
　　　　特点：1、只继承了父类构造函数的属性，没有继承父类原型的属性。
　　　　　　　2、解决了原型链继承缺点1、2、3。
　　　　　　　3、可以继承多个构造函数属性（call多个）。
　　　　　　　4、在子实例中可向父实例传参。
　　　　缺点：1、只能继承父类构造函数的属性，无法继承父类原型上的属性。
　　　　　　　2、每个新实例都有父类构造函数的副本（每次call都会新建一个Person构造函数)，臃肿。

**三、组合继承（组合原型链继承和借用构造函数继承）（常用）**（结合前两种，又把构造函数指向父构造函数，又把子原型对象指向父实例对象，缺点是调用了两次父类构造函数（耗内存)）
　　　　 ![img](https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162137084-1234623120.png)
　　　　重点：结合了两种模式的优点，传参和复用
　　　　特点：1、可以继承父类原型上的属性，可以传参，可复用。
　　　　　　　2、每个新实例引入的构造函数属性是私有的。
　　　　缺点：调用了两次父类构造函数（耗内存)

**四、实例继承（原型式继承）**（和原型链继承思想很像，只是实现方式不一样，通过创建父函数的实例，直接在实例上更改父构造函数和原型对象，然后再将父函数的实例对象return给外面包装的函数，缺点是所有实例都会继承原型上的属性，没办法复用。）

```js
function Cat(name){
  var instance = new Animal();
  instance.name = name || 'Tom';
  return instance;
}
```

　　　　 ![img](https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162147596-1363486586.png)
　　　　重点：用一个函数包装一个对象，然后返回这个函数的调用，这个函数就变成了个可以随意增添属性的实例或对象。object.create()就是这个原理。
　　　　特点：类似于复制一个对象，用函数来包装。
　　　　缺点：1、所有实例都会继承原型上的属性。
　　　　　　　2、无法实现复用。（新实例属性都是后面添加的)

**五、寄生组合式继承（常用）**(主要是通过一个函数当中间商，让函数的原型对象等于父构造函数的原型对象，再用函数创建实例对象指向给子构造函数的实力对象，这个主要是解决组合继承调用两次父构造函数占用内存的缺点，剩下的一步和组合继承一样，子构造函数将this指向父构造函数就可以了)
　　　　寄生：在函数内返回对象然后调用
　　　　组合：1、函数的原型等于另一个实例。2、在函数中用apply或者call引入另一个构造函数，可传参　
　　　　 ![img](https://img2018.cnblogs.com/blog/940884/201907/940884-20190717162220285-1478888936.png)
　　　　重点：修复了组合继承的问题

# 16.JS代码执行机制（宏任务和微任务、eventLoop）

**1.JavaScript是一门单线程语言。**
**2.Event Loop(事件循环)是JavaScript的执行机制。**

![img](https://upload-images.jianshu.io/upload_images/15216392-569f354ffa11d9ec.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

![img](https://images2018.cnblogs.com/blog/1424035/201807/1424035-20180717204025092-991427971.png)****

# 17.Histoty和Hash------------------

**hash模式和history模式的不同**

最直观的区别就是在url中 hash 带了一个很丑的 # 而history是没有#的

hash模式背后的原理是`onhashchange`事件,可以在window对象上监听这个事件，hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。

history —— 利用了 HTML5新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。浏览器从 / 到 /user是会向服务器发送 request 的。所以服务器端是要做特殊配置的；否则，页面将无法正常访问。

pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；
pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；
pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；
pushState() 可额外设置 title 属性供后续使用。

**React中的路由问题（官网）：**Hash 历史记录不支持 `location.key` 或 `location.state`。在以前的版本中，我们试图填补行为，但存在我们无法解决的边缘案例。 任何需要此行为的代码或插件都将无法使用。由于此技术仅用于支持传统浏览器，因此我们鼓励您配置服务器以便与 `<BrowserHistory>` 配合使用。

**上线后出现的问题及解决办法**

跳转后刷新或者回跳，会报一个404的错误，找不到指定的路由,最后后端去指向正确的路由 加了/hd/xxx 去匹配是否有这个/hd/{:path} 才得以解决，只需在后端（Apache 或 Nginx）进行简单的路由配置，同时搭配前端路由的 404 页面支持。(比如用的 express 的话，你需要 handle 所有的路由 app.get('*', (req, res) => { ... })；
使用了 nginx 的话，nginx也要做相应的配置)

# 18.react路由守卫

https://www.jianshu.com/p/677433245697

下面是我的实现方式，首先，准备一份路由表，包含了路由的地址，组件以及是否需要权限校验：

```tsx
import { HomePage } from '../pages/home/home.page';
import { LoginPage } from '../pages/login/login.page';
import { ErrorPage } from '../pages/error/error.page';

interface routerConfigModel {
    path:string,
    component?:any,
    auth?:boolean
}
export const routerConfig:routerConfigModel[] = [
    {
        path:'/',
        component:HomePage,
        auth:true,
    },{
        path:'/home',
        component:HomePage,
        auth:true,
    },{
        path:'/login',
        component:LoginPage,
    },{
        path:'/404',
        component:ErrorPage
    }
];
```

将 `auth` 设置为 `true`，表示该路由需要权限校验。
 然后，定义 `Router` 组件，该组件是经过高阶组件包装后的结果：



```jsx
import * as React from 'react';
import { HashRouter,Switch } from 'react-router-dom';
import { FrontendAuth } from '../components/frontend-auth/frontend-auth.component'
import { routerConfig } from './router.config'

export class Router extends React.Component{
    render(){
        return(
            <HashRouter>
                <Switch>
                    <FrontendAuth config={routerConfig} />
                </Switch>
            </HashRouter>
        );
    }
}
```

所有的路由跳转，都交给 `FrontendAuth` 高阶组件代理完成。下面是 `FrontendAuth` 组件的实现：



```tsx
import * as React from 'react';
import { Route,Redirect } from 'react-router-dom';
import { propsModel } from './frontend-auth.model'

export class FrontendAuth extends React.Component<any,propsModel>{
    render(){
        const { location,config } = this.props;
        const { pathname } = location;
        const isLogin = localStorage.getItem('__config_center_token')
        
        // 如果该路由不用进行权限校验，登录状态下登陆页除外
        // 因为登陆后，无法跳转到登陆页
        // 这部分代码，是为了在非登陆状态下，访问不需要权限校验的路由
        const targetRouterConfig = config.find((v:any) => v.path === pathname);
        if(targetRouterConfig && !targetRouterConfig.auth && !isLogin){
            const { component } = targetRouterConfig;
            return <Route exact path={pathname} component={component} />
        }

        if(isLogin){
            // 如果是登陆状态，想要跳转到登陆，重定向到主页
            if(pathname === '/login'){
                return <Redirect to='/' />
            }else{
                // 如果路由合法，就跳转到相应的路由
                if(targetRouterConfig){
                    return <Route path={pathname} component={targetRouterConfig.component} />
                }else{
                    // 如果路由不合法，重定向到 404 页面
                    return <Redirect to='/404' />
                }
            }
        }else{
            // 非登陆状态下，当路由合法时且需要权限校验时，跳转到登陆页面，要求登陆
            if(targetRouterConfig && targetRouterConfig.auth){
                return <Redirect to='/login' />
            }else{
                // 非登陆状态下，路由不合法时，重定向至 404
                return <Redirect to='/404' />
            }
        }
    }
}
```

以及对应的 Model：



```css
export interface propsModel {
    config:any[],
}
```

页面上的路由跳转，都由 `FrontendAuth` 高阶组件代理了，在 `Switch` 组件内部，不再是 `Route` 组件，而只有一个 `FrontendAuth` 组件。
 `FrontendAuth` 组件接收一个名为 `config` 的 `Props`，这是一份路由表。同时，由于 `FrontendAuth` 组件放在了 `Switch` 组件内部，React Router 还自动为 `FrontendAuth` 注入了 `location` 属性，当地址栏的路由发生变化时，就会触发 `location` 属性对象上的 `pathname` 属性发生变化，从而触发 `FrontendAuth` 的更新（调用 `render` 函数）。
 `FrontendAuth` 的 `render` 函数中，根据 `pathname` 查找到路由表中的相关配置，如果该配置中指定了无需校验，就直接返回相应的 `Route` 组件。
 如果查找到的配置需要进行校验，再根据是否登陆进行处理，具体可以查看代码中的注释。

**总结一下，实现路由守卫需要考虑到以下的问题：**

1. 未登录情况下，访问不需要权限校验的合法页面：允许访问
2. 登陆情况下，访问登陆页面：禁止访问，跳转至主页
3. 登陆情况下，访问除登陆页以外的合法页面：允许访问
4. 登陆情况下，访问所有的非法页面：禁止访问，跳转至 404
5. 未登录情况下，访问需要权限校验的页面：禁止访问，跳转至登陆页
6. 未登录情况下，访问所有的非法页面：禁止访问，跳转至 404

# 19.http状态码

**1XX：通知**

1XX系列响应代码仅在与HTTP服务器沟通时使用。

**2XX: 成功**

2XX系列响应代码表明操作成功了。

**3XX 重定向**

3XX系列响应代码表明：客户端需要做些额外工作才能得到所需要的资源。它们通常用于GET请求。他们通常告诉客户端需要向另一个URI发送GET请求，才能得到所需的表示。那个URI就包含在Location响应报头里。

**4XX：客户端错误**

这些响应代码表明客户端出现错误。不是认证信息有问题，就是表示格式或HTTP库本身有问题。客户端需要自行改正。

**5XX 服务端错误**

这些响应代码表明服务器端出现错误。一般来说，这些代码意味着服务器处于不能执行客户端请求的状态，此时客户端应稍后重试。有时，服务器能够估计客户端应在多久之后重试。并把该信息放在Retry-After响应报头里。

**常见状态码**

- 200 - 请求成功
- 301 - 资源（网页等）被永久转移到其它URL
- 400("Bad Request")
  客户端方面的问题。实体主题中的文档（若存在的话）是一个错误消息。希望客户端能够理解此错误消息，并改正问题。
- 404 - 请求的资源（网页等）不存在
- 404("Not Found") 和410("Gone")
  当客户端所请求的URI不对应于任何资源时，发送此响应代码。404用于服务器端不知道客户端要请求哪个资源的情况；410用于服务器端知道客户端所请求的资源曾经存在，但现在已经不存在了的情况。
- 409("Conflict")
  当客户端试图执行一个”会导致一个或多个资源处于不一致状态“的操作时，发送此响应代码。
- 500 - 内部服务器错误

# 20.移动端适配

目前对于移动端适配的内容布局效果是这样的：

- **百分比布局（流式布局）**，所有需要动态调整的元素宽高采用百分比，字号固定像素。
- **rem**，通过计算或者JavaScript获取到设备像素/CSS像素的比例，确定根元素的字体像素，然后所有单位根据根元素字体像素进行rem设置，确定大小。而基础rem会根据设备变化而变化。
- **vw和vh**，根据当前设备的Visual Viewport宽度作为100vw，然后得出单位vw的宽度，所有元素按照vw为单位进行样式排布。
- **Media Query(媒体查询)**：通过断点来进行不同宽度区间的设备样式适配。

以上几个方法各自都有各自的好处，我们可以看一下实际应用时候的效果：



**在css中单位长度用的最多的是px、em、rem，这三个的区别是**：

　　px是固定的像素，一旦设置了就无法因为适应页面大小而改变。

　　em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。

对于em和rem的区别一句话概括：**em相对于父元素，rem相对于根元素。**



## flex布局（弹性布局）

**一、Flex 布局是什么？**

```bash
Flex 是 Flexible Box 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。
任何一个容器都可以指定为 Flex 布局。
行内元素也可以使用 Flex 布局。
Webkit 内核的浏览器，必须加上-webkit前缀。
注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。
```

**2、Flex的属性**

**以下6个属性设置在容器上**。

```js
1.flex-direction  //属性决定主轴的方向
2.flex-wrap       //换行 
3.flex-flow       //（flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row 						nowrap。）
4.justify-content  //定义了项目在主轴上(即横向)的对齐方式。
5.align-items      //定义项目在交叉轴上(即纵向,垂直)如何对齐。
6.align-content    //定义了侧轴多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用
```

**1.flex-direction属性**

```css
flex-direction属性决定主轴的方向（即项目的排列方向）。
.box {
    flex-direction: row | row-reverse | column | column-reverse;
}
row（默认值）：主轴为水平方向，起点在左端。
row-reverse：主轴为水平方向，起点在右端。
column：主轴为垂直方向，起点在上沿,自上而下。
column-reverse：主轴为垂直方向，起点在下沿,自下而上。
```

**2.flex-wrap属性**

```css
默认情况下，项目都排在一条线（又称"轴线"）上。flex-wrap属性定义，如果一条轴线排不下，应该如何换行。
.box{
  flex-wrap: nowrap | wrap | wrap-reverse;
}
 nowrap（默认）：不换行,宽度自动压缩。
 wrap：换行，第一行在上方。
 wrap-reverse：换行，第一行在下方。
```

**3.flex-flow**

```css
 flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。
.box {
  flex-flow: <flex-direction> || <flex-wrap>;
}
.box{
  flex-flow:row||nowrap;
}
```

**4.justify-content属性**

```ruby
justify-content属性定义了项目在主轴上(即横向)的对齐方式。

flex-start（默认值）：左对齐
flex-end：右对齐
center： 居中
space-between：两端对齐，组件之间的间隔都相等。
space-around：距边界两侧的间隔相等，元素之间的间隔比项目与边框的间隔大一倍。
```

**5.align-items属性**

```css
align-items属性定义项目在交叉轴上(即纵向,垂直)如何对齐。
.box {
  align-items: flex-start | flex-end | center | baseline | stretch;
}
flex-start：交叉轴的起点(顶部)对齐。
flex-end：交叉轴的终点(底部)对齐。
center：交叉轴的中点(中间)对齐。
baseline: 项目的第一行文字的基线(即根据内容对齐,不再根据容器)对齐。
stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
```

**6.align-content属性(说的是垂直方向的交叉轴)**

```css
align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
.box {
  align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}
flex-start：与交叉轴的起点对齐。
flex-end：与交叉轴的终点对齐。
center：与交叉轴的中点对齐。
space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
stretch（默认值）：轴线占满整个交叉轴
```

**二、项目的属性**

**以下6个属性设置在项目上。**

```js
1.order				//属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
2.flex-grow			//属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
3.flex-shrink		//flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
4.flex-basis		//flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。
5.flex				//flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 						auto。后两个属性可选。
6.align-self		//align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属						性。
```

**1.order属性**

```css
order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
.item {
  order: <integer>;
}
```

**2.flex-grow属性**

```css
flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
.item {
  flex-grow: <number>; /* default 0 */
}
如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。
如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。
```

**3.flex-shrink属性**

```css
flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
.item {
  flex-shrink: <number>; /* default 1 */
}
如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。
如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。
注:负值对该属性无效。
```

**4.flex-basis属性**

```css
flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。
浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。
.item {
    flex-basis: <length> | auto; /* default auto */
}
它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。
```

## **5.flex属性是哪三个属性的缩写**

```css
flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。
.item {
  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
}
该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。
建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。
```

**6.align-self属性**

```css
align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。
默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
```

# 21.css3和html5新特性

**HTML5 的一些最有趣的新特性：**

- 新的语义化标签，比如 <header>, <footer>, <article>, and <section>。

  | <header>  | 定义了文档的头部区域 |
  | --------- | :------------------: |
  | <footer>  | 定义了文档的尾部区域 |
  | <nav>     |    定义文档的导航    |
  | <section> |    定义文档中的节    |
  | <article> |       定义文章       |
  | <aside>   |  定义页面以外的内容  |

- 新的表单控件，比如数字、日期、时间、日历和滑块。

- 强大的图像支持（借由 <canvas> 和 <svg>）

- 强大的多媒体支持（借由 <video> 和 <audio>）

- 强大的新 API，比如用本地存储取代 cookie。

**css3新特性**

**一、css3的新选择器**

- `E:nth-child(n)` 选择器匹配其父元素的第n个子元素，不论元素类型，n可以使数字，关键字，或公式

- `E:nth-of-type(n)` 选择与之其匹配的父元素的第N个子元素

- `E:frist-child` 相对于父级做参考，“所有”子元素的第一个子元素，并且“位置”要对应

- `E:frist-of-type` 相对于父级做参考，“特定类型”（E）的第一个子元素

- `E:empty` 选择没有子元素的每个E元素

- `E:target` 选择当前活动的E元素

- `::selection` 选择被用户选取的元素部分

- 属性选择器

  `E[abc*="def"]` 选择adc属性值中包含子串"def"的所有元素

**二、文本**

- `text-shadow:2px 2px 8px #000;`参数1为向右的偏移量，参数2为向左的偏移量，参数3为渐变的像素，参数4为渐变的颜色
- `text-overflow`：规定当文本溢出包含元素时发生的事情 text-overflow:ellipsis(省略)
- `text-wrap`：规定文本换行的规则
- `word-break` 规定非中日韩文本的换行规则
- `word-wrap`：对长的不可分割的单词进行分割并换行到下一行
- `white-space`：规定如何处理元素中的空白 white-space:nowrap 规定段落中的文本不进行换行

**三、边框**

- `border-raduis` 边框的圆角
- `border-image` 边框图片

```
.border-image {
    border-image-source:url(images/border.png-600);
    boder-image-slice:27;
    border-image-width:10px;
    border-iamge-repeat:round; (round平铺) 平铺效果不作用于四角，只适应与四边  
}
```

**四、背景**

- `rgba`
- `backgrounnd-size:cover/contain`，其中background-size：cover，会使“最大”边进行缩放，另一边同比缩放，铺满容器，超出部分会溢出。background-size:contain，会使“最小”边进行缩放，另一边同比缩放，不一定铺满容器，会完整显示图片

**五、渐变**

- `linear-gradient`

```
background-image:linear-gradient(90deg,yellow 20%,green 80%)
```

- `radial-gradient`

```
background-iamge:radial-gradient(120px at center center,yellow,green)
```

**六、多列布局**

- `column-count`
- `column-width`
- `column-gap`
- `column-rule`

**七、过渡**

- `transition`
- `transition-property:width` //property为定义过渡的css属性列表，列表以逗号分隔
- `transition-duration:2s;` //过渡持续的时间
- `transition-timing-function:ease;`
- `transition-delay:5s` //过渡延迟5s进行

**八、动画、旋转**

- `animation`
- `transform ：translate（x,y) rotate(deg) scale(x,y)`
- `translate`
- `scale`
- `rotate`
- `skew`（倾斜）

**九、flex布局**

**十、@media媒体查询**

# 22.React路由(React-Keeper路由缓存)

**React如何优雅地写单页面应用？**

为了追求极致的用户体验，很多Web应用采用单页面方式呈现，然而单页面应用，往往对应着高复杂度，比如多层次路由配置、统一数据处理等，这需要项目有一个强大的技术架构和友好的构建环境来支撑。[路由器](https://www.zhihu.com/search?q=路由器&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A26308250})，作为单页面构建的基础，对单页面应用的开发、加载、运行各个环节都起着至关重要的作用，项目体量越大，对路由器的依赖表现越强。

下面是一个React应用的基础路由配置，了解React的同学一定不陌生：

```js
const App = ()=> {
  return (
    <HashRouter>
      <div>
        <Route cache component={ Home } path="/"/>
        <Route component={ Products } path="/products"/>
      </div>
    </HashRouter>
  )
}

ReactDOM.render(<App/>, document.getElementById('root'))
```

是啊，[路由配置](https://www.zhihu.com/search?q=路由配置&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A26308250})不就这么简单吗？

真正做过单页面应用的同学要反驳你了，并且会立刻提出很多问题：

1. 路由配置拆分怎么做？
2. 动态加载怎么做？
3. props怎么传递？
4. 登录拦截怎么做？
5. 列表页能不能缓存？
6. balabala......

能遇到这些问题的同学，相信一定是饱经风霜了。这些问题，Demo中是不会有的，都是真实项目中才能遇到的。

当然，这篇文章，就是为解决这些问题而生的，下面我们以**React-Keeper**（以下简称Keeper）为例，来解决这些问题。

*BTW: React-Keeper是React生态里一款较新的开源路由库，由国内团队开发，借鉴了[React-Router](https://www.zhihu.com/search?q=React-Router&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A26308250}) 4很多特点，不过灵活性、实用性都强于React-Router很多，而且兼容React-Router常用用法，其文档和代码可以参见[React-Keeper GitHub](https://link.zhihu.com/?target=https%3A//github.com/lanistor/react-keeper)官网。*

![img](https://pic1.zhimg.com/80/v2-952fb10c0b6ea07eeb21d5ecdfd88f08_720w.png)

## **1. [路由拆分](https://www.zhihu.com/search?q=路由拆分&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A26308250})**

集中化的路由配置是一个很糟糕的方案，尤其是在大型Web应用中，路由拆分是很有必要的。

Keeper实现路由拆分的方式：

```js
const App = ()=> {
  return (
    <HashRouter>
      <div>
        <Route cache component={ Home } path="/"/>
        <Route component={ Products } path="/products"/>
      </div>
    </HashRouter>
  )
}

const Products = ()=> {
  return (
    <div>
      <Route component={ ScienceProducts } path="/sci" />
      <Route component={ DailiUseProducts } path="/dai" />
    </div>
  )
}

ReactDOM.render(<App/>, document.getElementById('root'))
```

实际开发中可以将大量的路由配置信息，按照模块化的方式进行拆分，跟路由只引入模块入口，内部页面配置在模块内部，模块内可以再切分二级模块，以此实现路由的拆分。

## **2. [页面缓存](https://www.zhihu.com/search?q=页面缓存&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A26308250})**

页面缓存是Keeper最重要的特性，保留用户前一个页面的所有状态（数据、各种交互状态等）对单页面应用是非常重要的，例如：在商品列表页点击进入商品详情页，然后返回列表页时，用户希望数据还是之前的数据，页面还停留在刚才的滚动位置。在Router中我们实现这种交互的方式，只能利用父子组件关系，而这经常会导致一个页面有多个URL，违背资源[单一地址原则](https://www.zhihu.com/search?q=单一地址原则&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A26308250})。

Keeper创造性地提供了页面缓存的功能，通过内置的缓存管理器，在页面未匹配激活时，保留用户所有的交互状态，在页面激活后对状态进行恢复。在Keeper中实现缓存也非常简单，只需要添加一个**cache**标记：

```js
<Route cache component={ Product } path='/products'/>
```

该标记表示页面永久缓存，针对不同场景，Keeper提供三种缓存方式：

**cache='root' (或cache) :** 永久缓存该路由对应页面，直至路由器销毁。

**cache='parent' :** 在父组件匹配的情况下缓存该[路由页面](https://www.zhihu.com/search?q=路由页面&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A26308250})，直至父组件不匹配。

**LinkCache :** [集成缓存管理器](https://www.zhihu.com/search?q=集成缓存管理器&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A26308250})的Link组件，为临时缓存，点击返回或跳转至其他页面，缓存即失效。

我们在使用时应根军不同的业务模块场景采用不同的缓存策略。

## **3. 动态加载**

把所有的JS文件打包为一个文件并不是一个明智的选择，这样会严重拖慢首屏的加载时间，JS代码应该是分割的，并且是按需加载的。

Keeper实现按需加载的方式：

```js
// 定义动态加载函数
const loadProduct = (cb)=> {
  import('../Products.js').then((Products)=>{
      cb(Products)
    })
}

// 通过loadComponent属性引入
<Route loadComponent={ loadProduct } path='/products'/>
```

## **4. [props传递](https://www.zhihu.com/search?q=props传递&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A26308250})**

我们知道在React-Router中并不支持自定义props的传递，然而这在Keeper中支持得很好：

```js
let hostUser = { id: 'ASDFSDFG', name: '马化腾' }

// 父组件中通过props传入Route (hostUser)
const Products = ()=> {
  return (
    <div>
      <Route hostUser={ hostUser } component={ ScienceProducts } path="/sci" />
      <Route component={ DailiUseProducts } path="/dai" />
    </div>
  )
}

// Route组件所有的props自动传入子组件
const ScienceProducts = (props)=> {
  return (
    <div>
      <h3>{ props.hostUser.name }</h3>
    </div>
  )
}
```

## **5. 登录拦截**

登录拦截、权限检测、表单关闭检测，这些是业务中非常常见的场景，而这也在Keeper中得到了很好的支持。

Keeper提供了两种[过滤器](https://www.zhihu.com/search?q=过滤器&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A26308250})来对路由的状态变化进行过滤和拦截：EnterFilter和LeaveFilter。

EnterFilter: 进入页面之前执行的过滤器，适用于登录检测、权限检测一类的场景。

LeaveFilter： 页面解绑之前执行的过滤器，适用于表单关闭检测一类的场景。

```js
// 定义过滤器，内部通过callback进行流程控制
const loginFilter = (callback, props)=> {
  
  if(!props.host) {
    new Promise((resolve, reject)=>{
      // some code
    }).then(callback);
  }
}

// 将过滤器加入Route
<HashRouter>
  <Route path='/user' component={User} enterFilter={ loginFilter } />
</HashRouter>

// 多过滤器配置
<HashRouter>
  <Route path='/user' component={User}, enterFilter={[ loginFilter, permitFilter1, permitFilter2 ] } />
</HashRouter>
```

**6. 进阶**

Keeper提供了很灵活的配置方式，以让我们简单的写出优雅的代码。从下面看几个场景切入介绍下Keeper常用配置的使用。

**Q1:** 页面未找到时显示默认

**A1:** 使用Route提供的miss属性，当页面找不到的时候自动渲染该组件。

```js
<Route miss path='/home' component={ Home }/>
```

**Q2:** 进入一个模块直接进入模块引导页

**A2:** 使用Route提供的index属性，和miss使用方式雷同，并且可以和miss一起使用。

```text
<Route index miss path='/home' component={ Home }/>
```

**Q3:** 组件地址重定向的处理

**A3:** 使用Route提供的redirect属性，当其他条件匹配完成时，自动进行页面重定向。

```js
<Route redirect='/homepage' path='/home' component={ Home }/>
```

**Q4:** 如何使用history的[state属性](https://www.zhihu.com/search?q=state属性&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A26308250})？

**A4:** Keeper内部集成了[state代理](https://www.zhihu.com/search?q=state代理&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A26308250})，对支持state API的浏览器，直接使用state API；对其他浏览器使用内部集成的state管理器，即使用随机ID（URL中加入[随机key](https://www.zhihu.com/search?q=随机key&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A26308250})）来映射state，并使用sessionStorage进行存储。

**写在最后**

React-Keeper是一款新兴的React路由库，由于其灵活的设计和强大的实用功能，一经发布便引起众多React开发者关注与尝试。

React-Keeper刚刚发布了V2.0版本，在底层很多地方做了优化。不过新兴框架，文档还不健全，目前开发者的使用方式，都是依赖其GitHub官网文档，目前尚未有中文文档。

一句话点评**React-Keeper**: 学习自React-Router，却远超过React-Router。

**附录**

**React-Keeper Github** : [https://github.com/lanistor/rea](https://link.zhihu.com/?target=https%3A//github.com/lanistor/react-keeper)

# 23.深拷贝和浅拷贝

###  实现浅拷贝的方法

（1）for···in只循环第一层



```jsx
// 只复制第一层的浅拷贝
function simpleCopy(obj1) {
   var obj2 = Array.isArray(obj1) ? [] : {};
   for (let i in obj1) {
   obj2[i] = obj1[i];
  }
   return obj2;
}
var obj1 = {
   a: 1,
   b: 2,
   c: {
         d: 3
      }
}
var obj2 = simpleCopy(obj1);
obj2.a = 3;
obj2.c.d = 4;
alert(obj1.a); // 1
alert(obj2.a); // 3
alert(obj1.c.d); // 4
alert(obj2.c.d); // 4
```

（2）Object.assign方法

```jsx
var obj = {
    a: 1,
    b: 2
}
var obj1 = Object.assign(obj);
obj1.a = 3;
console.log(obj.a) // 3
```

（3）直接用=赋值

```jsx
let a=[0,1,2,3,4],
    b=a;
console.log(a===b);
a[0]=1;
console.log(a,b);
```

![img](https:////upload-images.jianshu.io/upload_images/15037426-6a06b6f2ee711a5f.png?imageMogr2/auto-orient/strip|imageView2/2/w/248/format/webp)

image.png

### 实现深拷贝的方法

（1）采用递归去拷贝所有层级属性

```jsx
function deepClone(obj){
    let objClone = Array.isArray(obj)?[]:{};
    if(obj && typeof obj==="object"){
        for(key in obj){
            if(obj.hasOwnProperty(key)){
                //判断ojb子元素是否为对象，如果是，递归复制
                if(obj[key]&&typeof obj[key] ==="object"){
                    objClone[key] = deepClone(obj[key]);
                }else{
                    //如果不是，简单复制
                    objClone[key] = obj[key];
                }
            }
        }
    }
    return objClone;
}    
let a=[1,2,3,4],
    b=deepClone(a);
a[0]=2;
console.log(a,b);
```

结果：



![img](https:////upload-images.jianshu.io/upload_images/15037426-66f503dd14d2bd0f.png?imageMogr2/auto-orient/strip|imageView2/2/w/407/format/webp)



（2） 通过JSON对象来实现深拷贝

缺点： 无法实现对对象中方法的深拷贝，会显示为undefined

```jsx
function deepClone2(obj) {
  var _obj = JSON.stringify(obj),
    objClone = JSON.parse(_obj);
  return objClone;
}
```

 （3）通过jQuery的extend方法实现深拷贝

```php
var array = [1,2,3,4];
var newArray = $.extend(true,[],array); // true为深拷贝，false为浅拷贝
```

（4）lodash函数库实现深拷贝

```bash
let result = _.cloneDeep(test)
```

（6）手动实现深拷贝

```csharp
let obj1 = {
   a: 1,
   b: 2
}
let obj2 = {
   a: obj1.a,
   b: obj1.b
}
obj2.a = 3;
alert(obj1.a); // 1
alert(obj2.a); // 3
```

（7）如果对象的value是基本类型的话，也可以用Object.assign来实现深拷贝，但是要把它赋值给一个空对象

```jsx
var obj = {
    a: 1,
    b: 2
}
var obj1 = Object.assign({}, obj); // obj赋值给一个空{}
obj1.a = 3;
console.log(obj.a)；// 1
```

![img](https:////upload-images.jianshu.io/upload_images/15037426-1c7b29547b2a8794.png?imageMogr2/auto-orient/strip|imageView2/2/w/332/format/webp)

（8）用slice实现对数组的深拷贝

```jsx
// 当数组里面的值是基本数据类型，比如String，Number，Boolean时，属于深拷贝
// 当数组里面的值是引用数据类型，比如Object，Array时，属于浅拷贝
var arr1 = ["1","2","3"]; 
var arr2 = arr1.slice(0);
arr2[1] = "9";
console.log("数组的原始值：" + arr1 );
console.log("数组的新值：" + arr2 );
```

![img](https:////upload-images.jianshu.io/upload_images/15037426-a412661f28396034.png?imageMogr2/auto-orient/strip|imageView2/2/w/341/format/webp)

image.png

（9）用concat实现对数组的深拷贝

```jsx
// 当数组里面的值是基本数据类型，比如String，Number，Boolean时，属于深拷贝
var arr1 = ["1","2","3"];
var arr2 = arr1.concat();
arr2[1] = "9";
console.log("数组的原始值：" + arr1 );
console.log("数组的新值：" + arr2 );
// 当数组里面的值是引用数据类型，比如Object，Array时，属于浅拷贝
var arr1 = [{a:1},{b:2},{c:3}];
var arr2 = arr1.concat();
arr2[0].a = "9";
console.log("数组的原始值：" + arr1[0].a ); // 数组的原始值：9
console.log("数组的新值：" + arr2[0].a ); // 数组的新值：9
```

![img](https:////upload-images.jianshu.io/upload_images/15037426-5f64889271b63ce7.png?imageMogr2/auto-orient/strip|imageView2/2/w/326/format/webp)

（11）使用扩展运算符实现深拷贝

```jsx
// 当value是基本数据类型，比如String，Number，Boolean时，是可以使用拓展运算符进行深拷贝的
// 当value是引用类型的值，比如Object，Array，引用类型进行深拷贝也只是拷贝了引用地址，所以属于浅拷贝
var car = {brand: "BMW", price: "380000", length: "5米"}
var car1 = { ...car, price: "500000" }
console.log(car1); // { brand: "BMW", price: "500000", length: "5米" }
console.log(car); // { brand: "BMW", price: "380000", length: "5米" }
```

# 24.堆和栈

**js中的堆内存与栈内存**

在js引擎中对变量的存储主要有两种位置，**堆内存和栈内存**。

和java中对内存的处理类似，**栈内存**主要用于存储各种**基本类型的**变量，包括Boolean、Number、String、Undefined、Null，**以及对象变量的指针，这时候栈内存给人的感觉就像一个线性排列的空间，每个小单元大小基本相等。

![img](https://images2018.cnblogs.com/blog/461976/201808/461976-20180823211511434-1707579794.png)

**内存分配和垃圾回收**

一般来说栈内存线性有序存储，容量小，系统分配效率高。而堆内存首先要在堆内存新分配存储区域，之后又要把指针存储到栈内存中，效率相对就要低一些了。
垃圾回收方面，栈内存变量基本上用完就回收了，而推内存中的变量因为存在很多不确定的引用，只有当所有调用的变量全部销毁之后才能回收。

# 25.纯函数和高阶函数

**纯函数**

https://blog.csdn.net/c_kite/article/details/79138814

一个函数的返回结果**只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数**。

所谓纯函数，它是这样一种函数：**即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用**。****

为什么要煞费苦心地构建纯函数？因为纯函数非常“靠谱”，执行一个纯函数你不用担心它会干什么坏事，它不会产生不可预料的行为，也不会对外部产生影响。不管何时何地，你给它什么它就会乖乖地吐出什么。如果你的应用程序大多数函数都是由纯函数组成，那么你的程序测试、调试起来会非常方便

使用纯函数创建组件：

```react
// function
function Title (props) {
  return <h1>{ props.title }</h1>
}
// 箭头函数
const Title = ({ props }) => <div>{ props.title }</div>
```


对比下使用类组件方式创建的组件：

```react
// es6 类组件
class Title extends React.Component {
  render() {
    return <h1>{this.props.title}</h1>
  }
}
```

**通过对比，纯函数组件写法简单了，可以看出纯函数组件的特点:**

1.组件不会被实例化，整体渲染性能得到提升；
2.组件不能访问 this 对象；
3.组件无法访问生命周期的方法；
4.无状态组件只能访问输入的 props，无副作用。

**可以总结出纯函数组件的优点：**

1.无副作用；
2.占内存更小，首次 render 的性能更好；
3.语法更简洁，可读性好，逻辑简单，测试简单，代码量少，容易复用；
4.更佳的性能表现：因为函数组件中不需要进行生命周期的管理和状态管理，因此 React 并不需要进行某些特定的5.检查和内存分配，保证了性能。
6.当然，纯函数组件也有自己的短板，它无生命周期，且没有 this。

**高阶函数**

高阶函数: 若一个函数符合下面两个规范中的一个,该函数就是高阶函数

  1.若a函数,接受的参数是一个函数,那么a就可以称为高阶函数

  2.若a函数,调用的返回值依旧是一个函数,那么a就可以称之为高阶函数

  3.常见的高阶函数有:promise,setTimeout,arr.map等

**React 之 高阶函数_函数柯里化**

数据柯里化的作用是什么?

在处理表单时,可以通过ref的三种方式都可以获取表单控件数据,但是若是很多控件,都去定义一个ref(过多的使用会有性能问题),或者定义多个函数,那么就太臃肿了,那么数据柯里化可以解决

函数的柯里化:通过函数调用继续返回函数的方式,实现多次接受参数最后统一处理的函数编码形式.

**高阶组件**

高阶组件就是一个没有副作用的纯函数。

具体而言，**高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件**

# 27.数组方法

**影响原数组：**sort(callback)、reverse()、push、pop、unshift、shift、splice、delete、fill、copyWithin

**不影响原数组:** filter、map、some、every、forEach、for…in、for…of、reduce&reduceRight、find、finIndexOf、indexOf、lastIndexOf、flat、includes、from、slice、join、concat。

**纯函数**

纯函数有两个特点：1. 不改变原数组（没有副作用）；2. 返回一个数组

除了上面提到的 `forEach`, `every`, `some`, `filter` 属于非纯函数外，我们常用的 `push`, `pop`, `shift`, `unshift` 、splice方法也属于非纯函数

- join()
- push()和pop()
- shift() 和 unshift()
- sort()
- reverse()
- concat()
- slice()
- splice()
- indexOf()和 lastIndexOf() （ES5新增）
- forEach() （ES5新增）
- map() （ES5新增）
- filter() （ES5新增）
- every() （ES5新增）
- some() （ES5新增）
- reduce()
- flat()

**1.join()**

join，就是把数组转换成字符串，然后给他规定个连接字符，默认的是逗号( ，)

　　书写格式：join(" ")，括号里面写字符串 ("要加引号"),

```js
var arr = [1,2,3];
console.log(arr.join()); 　　　　// 1,2,3
console.log(arr.join("-")); 　　// 1-2-3
console.log(arr); 　　　　　　　　// [1, 2, 3]（原数组不变）
```

**2.push()和pop()**

push(): 把里面的内容添加到数组末尾，并返回修改后的长度。

pop()：移除数组最后一项，返回移除的那个值，减少数组的length。

​		书写格式：arr.push(" ")，括号里面写内容 ("字符串要加引号"),

​		书写格式：arr.pop( )

```js
var arr = ["Lily","lucy","Tom"];
var count = arr.push("Jack","Sean");
console.log(count); 　　　　　　　　　　// 5
console.log(arr); 　　　　　　　　　　　// ["Lily", "lucy", "Tom", "Jack", "Sean"]
var item = arr.pop();
console.log(item); 　　　　　　　　　　 // Sean
console.log(arr); 　　　　　　　　　　  // ["Lily", "lucy", "Tom", "Jack"]
```

**3.shift() 和 unshift()**  (和上面的push，pop相反，针对第一项内容)

shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。

unshift:将参数添加到原数组开头，并返回数组的长度 。

​		书写格式：arr.shift(" ")，括号里面写内容 ("字符串要加引号"),

```js
var arr = ["Lily","lucy","Tom"];
var count = arr.unshift("Jack","Sean");
console.log(count); 　　　　　　　　　　　　　　// 5
console.log(arr); 　　　　　　　　　　　　　　　//["Jack", "Sean", "Lily", "lucy", "Tom"]
var item = arr.shift();
console.log(item); 　　　　　　　　　　　　　　// Jack
console.log(arr); 　　　　　　　　　　　　　　 // ["Sean", "Lily", "lucy", "Tom"]
```

**4.sort()**

sort()：将数组里的项从小到大排序

​		书写格式：arr.sort( )

```js
var arr1 = ["a", "d", "c", "b"];
console.log(arr1.sort()); 　　　　　　　　　　// ["a", "b", "c", "d"]
```

sort()方法比较的是字符串，没有按照数值的大小对数字进行排序，要实现这一点，就必须使用一个排序函数



```js
function sortNumber(a,b)
{
　　return a - b
}
```



```js
arr = [13, 24, 51, 3]; console.log(arr.sort()); 　　　　　　　　　　// [13, 24, 3, 51] 
console.log(arr.sort(sortNumber)); 　　　　// [3, 13, 24, 51](数组被改变)
```

**5.reverse()**

reverse()：反转数组项的顺序。

　　　  书写格式：arr.reverse( )

```js
var arr = [13, 24, 51, 3];
console.log(arr.reverse()); 　　　　　　　　//[3, 51, 24, 13]
console.log(arr); 　　　　　　　　　　　　　　//[3, 51, 24, 13](原数组改变)
```

**6.concat()**

concat() ：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。

　　　　书写格式：arr.concat()，括号里面写内容 ("字符串要加引号"),



```js
var arr = [1,3,5,7];
var arrCopy = arr.concat(9,[11,13]);
console.log(arrCopy); 　　　　　　　　　　　　//[1, 3, 5, 7, 9, 11, 13]
console.log(arr); 　　　　　　　　　　　　　　// [1, 3, 5, 7](原数组未被修改)
```

**7.slice()**

slice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。

　　　　书写格式：arr.slice( 1 , 3 )

```js
var arr = [1,3,5,7,9,11];
var arrCopy = arr.slice(1);
var arrCopy2 = arr.slice(1,4);
var arrCopy3 = arr.slice(1,-2);
var arrCopy4 = arr.slice(-4,-1);
console.log(arr); 　　　　　　　　　　　　　　//[1, 3, 5, 7, 9, 11](原数组没变)
console.log(arrCopy); 　　　　　　　　　　　 //[3, 5, 7, 9, 11]
console.log(arrCopy2); 　　　　　　　　　　　//[3, 5, 7]
console.log(arrCopy3); 　　　　　　　　　　　//[3, 5, 7]
console.log(arrCopy4); 　　　　　　　　　　　//[5, 7, 9]
```

　　arrCopy只设置了一个参数，也就是起始下标为1，所以返回的数组为下标1（包括下标1）开始到数组最后。 

　　arrCopy2设置了两个参数，返回起始下标（包括1）开始到终止下标（不包括4）的子数组。 

　　arrCopy3设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从1开始到4（不包括）的子数组。 

　　arrCopy4中两个参数都是负数，所以都加上数组长度6转换成正数，因此相当于slice(2,5)。

**8.splice()**

splice()：删除、插入和替换。

删除：指定 2 个参数：要删除的第一项的位置和要删除的项数。

　　　　书写格式：arr.splice( 1 , 3 )

插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。

　　　　书写格式：arr.splice( 2,0,4,6 )
替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。

　　　　书写格式：arr.splice( 2,0,4,6 )

```js
var arr = [1,3,5,7,9,11];
var arrRemoved = arr.splice(0,2);
console.log(arr); 　　　　　　　　　　　　　　　//[5, 7, 9, 11]
console.log(arrRemoved); 　　　　　　　　　　　//[1, 3]
var arrRemoved2 = arr.splice(2,0,4,6);
console.log(arr); 　　　　　　　　　　　　　　　// [5, 7, 4, 6, 9, 11]
console.log(arrRemoved2); 　　　　　　　　　　// []
var arrRemoved3 = arr.splice(1,1,2,4);
console.log(arr); 　　　　　　　　　　　　　　　// [5, 2, 4, 4, 6, 9, 11]
console.log(arrRemoved3); 　　　　　　　　　　//[7]
```

**9.indexOf()和 lastIndexOf()**

**indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。**

　　　　书写格式：arr.indexof( 5 )

***\*lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。\**** 

　　　　书写格式：arr.lastIndexOf( 5,4 )

```js
var arr = [1,3,5,7,7,5,3,1];
console.log(arr.indexOf(5)); 　　　　　　//2
console.log(arr.lastIndexOf(5)); 　　　 //5
console.log(arr.indexOf(5,2)); 　　　　 //2
console.log(arr.lastIndexOf(5,4)); 　　//2
console.log(arr.indexOf("5")); 　　　　 //-1
```

**10.forEach()**

**forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。**

　　　　书写格式：arr.forEach()



```js
var arr = [1, 2, 3, 4, 5];
arr.forEach(function(x, index, a){
console.log(x + '|' + index + '|' + (a === arr));
});
// 输出为：
// 1|0|true
// 2|1|true
// 3|2|true
// 4|3|true
// 5|4|true
```

**11.map()**

**map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。**

　　　　书写格式：arr.map()



```js
var arr = [1, 2, 3, 4, 5];
var arr2 = arr.map(function(item){
return item*item;
});
console.log(arr2); 　　　　　　　　//[1, 4, 9, 16, 25]
```

**12.filter()**

**filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。**

　　　　书写格式：arr.filter()



```js
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var arr2 = arr.filter(function(x, index) {
return index % 3 === 0 || x >= 8;
}); 
console.log(arr2); 　　　　　　　　//[1, 4, 7, 8, 9, 10]
```

**13.every()**

**every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。**

　　　　书写格式：arr.every()



```js
var arr = [1, 2, 3, 4, 5];
var arr2 = arr.every(function(x) {
return x < 10;
}); 
console.log(arr2); 　　　　　　　　//true
var arr3 = arr.every(function(x) {
return x < 3;
}); 
console.log(arr3); 　　　　　　　　// false
```

**14.some()**

**some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。**

　　　　**书写格式：arr.some()**



```js
var arr = [1, 2, 3, 4, 5];
var arr2 = arr.some(function(x) {
return x < 3;
}); 
console.log(arr2); 　　　　　　　　//true
var arr3 = arr.some(function(x) {
return x < 1;
}); 
console.log(arr3); 　　　　　　　　// false
```

**15.reduce**

```js
arr.reduce(callback,[initialValue])
```

reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。

```js
callback （执行数组中每个值的函数，包含四个参数）

    1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））
    2、currentValue （数组中当前被处理的元素）
    3、index （当前元素在数组中的索引）
    4、array （调用 reduce 的数组）

initialValue （作为第一次调用 callback 的第一个参数。）
```

**reduce的简单用法**

当然最简单的就是我们常用的数组求和，求乘积了。

```jsx
var  arr = [1, 2, 3, 4];
var sum = arr.reduce((x,y)=>x+y)
var mul = arr.reduce((x,y)=>x*y)
console.log( sum ); //求和，10
console.log( mul ); //求乘积，24
```

**reduce的高级用法**

**（1）计算数组中每个元素出现的次数**

```jsx
let names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];

let nameNum = names.reduce((pre,cur)=>{
  if(cur in pre){
    pre[cur]++
  }else{
    pre[cur] = 1 
  }
  return pre
},{})
console.log(nameNum); //{Alice: 2, Bob: 1, Tiff: 1, Bruce: 1}
```

**（2）数组去重**

```jsx
let arr = [1,2,3,4,4,1]
let newArr = arr.reduce((pre,cur)=>{
    if(!pre.includes(cur)){
      return pre.concat(cur)
    }else{
      return pre
    }
},[])
console.log(newArr);// [1, 2, 3, 4]
```

**（3）将二维数组转化为一维**

```jsx
let arr = [[0, 1], [2, 3], [4, 5]]
let newArr = arr.reduce((pre,cur)=>{
    return pre.concat(cur)
},[])
console.log(newArr); // [0, 1, 2, 3, 4, 5]
```

**（3）将多维数组转化为一维**

```jsx
let arr = [[0, 1], [2, 3], [4,[5,6,7]]]
const newArr = function(arr){
   return arr.reduce((pre,cur)=>pre.concat(Array.isArray(cur)?newArr(cur):cur),[])
}
console.log(newArr(arr)); //[0, 1, 2, 3, 4, 5, 6, 7]
```

**（4）、对象里的属性求和**

```jsx
var result = [
    {
        subject: 'math',
        score: 10
    },
    {
        subject: 'chinese',
        score: 20
    },
    {
        subject: 'english',
        score: 30
    }
];

var sum = result.reduce(function(prev, cur) {
    return cur.score + prev;
}, 0);
console.log(sum) //60
```

**16.findIndex方法**

findIndex() 方法对数组的每个元素执行一次给定的函数

语法：arr.findIndex(arr.forEach(function (currentValue, currentIndex, currentArray){}）

```js
<script>
    let arr = [1, 5, 3, 3, 9];
    let result = arr.findIndex(function(currentValue) {
        if (currentValue == 3) {
            return true;
        }
    })
    console.log(result); // 找得到返回指定元素的索引，找不到返回-1
</script>

```
**17.find方法**

```js
<script>
    let arr = [1, 5, 3, 3, 9];
    let result = arr.find(function(currentValue) {
        if (currentValue == 33) {
            return true;
        }
    })
    console.log(result); // 找得到返回指定元素的索引，找不到返回undefined
</script>
```

**18.flat (扁平化数组-不影响原数组-返回扁平化后的数组)**

 此方法 需要浏览器兼容 IE浏览器不支持 chrome 需要 69及以上版本才支持 可采用其他方法

```js
// flat 将数组扁平化 可传入一个参数为 要扁平化的层数 传入`Infinity`则代表不管多少层 全部扁平化为一层
const arr = [1, [1,2,3,[4,5,6]], 6, 7, 9, 3] // 三维数组
const newArr1 = arr.flat(1)
console.log(newArr1) // 输出 [ 1, 1, 2, 3, [ 4, 5, 6, [ 7, 8, 9 ] ], 6 ]
const newArr2 = arr.flat(2)
console.log(newArr2) // 输出 [ 1, 1, 2, 3, 4, 5, 6, [ 7, 8, 9 ], 6 ]
const newArr3 = arr.flat(Infinity)
console.log(newArr3) // 输出 [1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 6]
```

**19.from (将类数组转换为真数组)**

```js
// from 转换有length的类数组 可传入三个参数（转换的数组-参数一，转换数组的每一个值-参数三，映射参数二的this-参数三）
 const arr = Array.from('abc') // 输出 [a, b, c]
 const arr1 = Array.from([1,2,3],v => v + 1) // 输出 [2,3,4]
 // 用 Set 和 from 去重
 const arr2 = Array.from(new Set([1,2,1,2,3,4,5,3,5,4])) // 输出 [ 1, 2, 3, 4, 5 ]
 const arr3 = [...new Set([1,2,1,2,3,4,5,3,5,4])] // 输出 [ 1, 2, 3, 4, 5 ]
```

**20. delete (删除元素值-删除后位置还在-值为undefined)**

```javascript
const arr = [1, 2, 3, 4]
delete arr[1] // 删除arr 索引为1的值 不删除位置
console.log(arr[1]) // 输出 undefined
```

**21.fill (填充数组-影响原数组)**

```js
// fill 接收三个参数fill(填充的值,填充开始位置,填充结束位置) 如果开始位置或者结束位置值为负数 则表示从结尾往前算
const arr = [1, 2, 3, 4]
arr.fill(6) // [6, 6, 6, 6]
arr.fill(6, 1) // [1, 6, 6, 6] 
arr.fill(6, -1) // [6, 6, 6, 4]
arr.fill(6, 1, -1) // [1, 6, 6, 4]
```

**22.copyWithin (替换元素-影响原数组)**

```js
// copyWithin 有三个参数copyWithin(开始替换的位置,开始截取元素的位置,结束截取元素的位置) 会将截取的元素 从参数以的位置开始替换。如果第二个或者第三个参数为负数 则会从后往前
let arr = [1,2,3,4,5,6];
// 从索引3 截取到索引5(不包括5) (截取到[4,5]) 然后将[4,5]从索引1开始替换
arr.copyWithin(1,3,5);
 console.log(arr); // 输出 [ 1, 4, 5, 4, 5, 6 ]
```

# 28.对象方法

**Object构造方法**

- [`Object.assign()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)

  将所有可枚举的自身属性的值从一个或多个源对象复制到目标对象。

- [`Object.create()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create)

  用指定的原型对象和属性创建一个新对象。

- [`Object.defineProperty()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)

  将给定描述符描述的命名属性添加到对象。

- [`Object.defineProperties()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties)

  将给定描述符描述的命名属性添加到对象。

- [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)

  返回一个包含`[key, value]`给定对象**自己的**可枚举字符串属性的所有对的数组。

- [`Object.freeze()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)

  冻结对象。其他代码无法删除或更改其属性。

- [`Object.fromEntries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)

  从可迭代的`[key, value]`对中返回一个新对象。（这是的反向 [`Object.entries`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)）。

- [`Object.getOwnPropertyDescriptor()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor)

  返回对象的命名属性的属性描述符。

- [`Object.getOwnPropertyDescriptors()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors)

  返回一个包含对象自身所有属性描述符的对象。

- [`Object.getOwnPropertyNames()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames)

  返回一个数组，其中包含给定对象**自己**的所有可枚举和不可枚举属性的名称。

- [`Object.getOwnPropertySymbols()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols)

  返回直接在给定对象上找到的所有符号属性的数组。

- [`Object.getPrototypeOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf)

  返回`prototype`指定对象的。

- [`Object.is()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)

  比较两个值是否相同。求所有`NaN`值（不同于“抽象相等比较”和“严格相等比较”）。

- [`Object.isExtensible()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible)

  确定是否允许扩展对象。

- [`Object.isFrozen()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen)

  确定对象是否冻结。

- [`Object.isSealed()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed)

  确定对象是否密封。

- [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)

  返回一个数组，其中包含给定对象**自己**的所有可枚举字符串属性的名称。

- [`Object.preventExtensions()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions)

  防止对象的任何扩展。

- [`Object.seal()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)

  防止其他代码删除对象的属性。

- [`Object.setPrototypeOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf)

  设置对象的原型（其内部`[[Prototype]]`属性）。

- [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values)

  返回一个数组，该数组包含与给定对象**自己的所有**可枚举字符串属性相对应的值。

**Object实例和Object原型对象**

JavaScript中的所有对象均来自`Object`。所有对象都继承自的方法和属性[`Object.prototype`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype)，尽管它们可能会被覆盖。

例如，其他构造函数的原型将覆盖`constructor`属性并提供自己的`toString()`方法。对`Object`原型对象的更改将传播到所有对象，除非经受这些更改的属性和方法在原型链中进一步被覆盖。

**方法**

1、Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。

```js
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };
const returnedTarget = Object.assign(target, source);
console.log(target);
// expected output: Object { a: 1, b: 4, c: 5 }
console.log(returnedTarget);
// expected output: Object { a: 1, b: 4, c: 5 }
```

2、Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 

```js
const person = {
  isHuman: false,
  printIntroduction: function () {
    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);
  }
};

const me = Object.create(person);

me.name = "Matthew"; // "name" is a property set on "me", but not on "person"
me.isHuman = true; // inherited properties can be overwritten

me.printIntroduction();
// expected output: "My name is Matthew. Am I human? true"
```

3、Object.defineProperties() 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。

     语法   Object.defineProperties(obj, props)   obj在其上定义或修改属性的对象。props要定义其可枚举属性或修改的属性描述符的对象。对象中存在的属性描述符主要有两种：数据描述符和访问器描述符（更多详情，请参阅Object.defineProperty()）。描述符具有以下键：configurabletrue 当且仅当该属性描述符的类型可以被改变并且该属性可以从对应对象中删除。 默认为 falseenumerabletrue 当且仅当在枚举相应对象上的属性时该属性显现。 默认为 falsevalue与属性关联的值。可以是任何有效的JavaScript值（数字，对象，函数等）。 默认为 undefined.writabletrue当且仅当与该属性相关联的值可以用assignment operator改变时。 默认为 falseget作为该属性的 getter 函数，如果没有 getter 则为undefined。函数返回值将被用作属性的值。 默认为 undefinedset作为属性的 setter 函数，如果没有 setter 则为undefined。函数将仅接受参数赋值给该属性的新值。 默认为 undefined返回值节 传递给函数的对象。

```js
var obj = {};
Object.defineProperties(obj, {
  'property1': {
    value: true,
    writable: true
  },
  'property2': {
    value: 'Hello',
    writable: false
  }
  // etc. etc.
});
```

4、Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。

    语法 Object.defineProperty(obj, prop, descriptor)      obj要在其上定义属性的对象。prop要定义或修改的属性的名称。descriptor将被定义或修改的属性描述符。返回值节    被传递给函数的对象。在ES6中，由于 Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而Object.defineProperty 是定义key为Symbol的属性的方法之一。

5、Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）

```js
const object1 = { foo: 'bar', baz: 42 };
console.log(Object.entries(object1)[1]);
// expected output: Array ["baz", 42]

const object2 = { 0: 'a', 1: 'b', 2: 'c' };
console.log(Object.entries(object2)[2]);
// expected output: Array ["2", "c"]

const result = Object.entries(object2).sort((a, b) => a - b);
console.log(Object.entries(result)[1]);
// expected output: Array ["1", Array ["1", "b"]]
```

6、Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。

```js
const object1 = {
  property1: 42
};

const object2 = Object.freeze(object1);

object2.property1 = 33;
// Throws an error in strict mode

console.log(object2.property1);
// expected output: 42
```

7、Object.fromEntries() 把键值对列表转换为一个对象。

```js
Map 转化为 Object
通过 Object.fromEntries， 可以将 Map 转化为 Object:

const map = new Map([ ['foo', 'bar'], ['baz', 42] ]);
const obj = Object.fromEntries(map);
console.log(obj); // { foo: "bar", baz: 42 }

Array 转化为 Object
通过 Object.fromEntries， 可以将 Array 转化为 Object:

const arr = [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ];
const obj = Object.fromEntries(arr);
console.log(obj); // { 0: "a", 1: "b", 2: "c" }
对象转换为Object
Object.fromEntries 是 Object.entries() 的反转函数， 借用 array manipulation methods 可以转换对象，如下：

const object1 = { a: 1, b: 2, c: 3 };

const object2 = Object.fromEntries(
  Object.entries(object1)
  .map(([ key, val ]) => [ key, val * 2 ])
);

console.log(object2);
// { a: 2, b: 4, c: 6 }
```

8、Object.is() 方法判断两个值是否是相同的值

```js
Object.is('foo', 'foo');     // true
Object.is(window, window);   // true

Object.is('foo', 'bar');     // false
Object.is([], []);           // false

var foo = { a: 1 };
var bar = { a: 1 };
Object.is(foo, foo);         // true
Object.is(foo, bar);         // false

Object.is(null, null);       // true

// 特例
Object.is(0, -0);            // false
Object.is(-0, -0);           // true
Object.is(NaN, 0/0);         // true
```

9、Object.isFrozen()方法判断一个对象是否被冻结

```js
// 使用Object.freeze是冻结一个对象最方便的方法.
var frozen = { 1: 81 };
Object.isFrozen(frozen) //=== false
Object.freeze(frozen);
Object.isFrozen(frozen) //=== true

// 一个冻结对象也是一个密封对象.
Object.isSealed(frozen) //=== true

// 当然,更是一个不可扩展的对象.
Object.isExtensible(frozen) //=== false
在 ES5 中，如果参数不是一个对象类型，将抛出一个TypeError异常。在 ES2015 中，非对象参数将被视为一个冻结的普通对象，因此会返回true。

Object.isFrozen(1);
// TypeError: 1 is not an object (ES5 code)

Object.isFrozen(1);
// true                          (ES2015 code)
```

10、Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致 。

```js
// simple array
var arr = ['a', 'b', 'c'];
console.log(Object.keys(arr)); // console: ['0', '1', '2']

// array like object
var obj = { 0: 'a', 1: 'b', 2: 'c' };
console.log(Object.keys(obj)); // console: ['0', '1', '2']

// array like object with random key ordering
var anObj = { 100: 'a', 2: 'b', 7: 'c' };
console.log(Object.keys(anObj)); // console: ['2', '7', '100']

// getFoo is a property which isn't enumerable
var myObj = Object.create({}, {
  getFoo: {
    value: function () { return this.foo; }
  } 
});
myObj.foo = 1;
console.log(Object.keys(myObj)); // console: ['foo']
```

11、Object.values()方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。

```js
var obj = { foo: 'bar', baz: 42 };
console.log(Object.values(obj)); // ['bar', 42]

// array like object
var obj = { 0: 'a', 1: 'b', 2: 'c' };
console.log(Object.values(obj)); // ['a', 'b', 'c']

// array like object with random key ordering
// when we use numeric keys, the value returned in a numerical order according to the keys
var an_obj = { 100: 'a', 2: 'b', 7: 'c' };
console.log(Object.values(an_obj)); // ['b', 'c', 'a']

// getFoo is property which isn't enumerable
var my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } });
my_obj.foo = 'bar';
console.log(Object.values(my_obj)); // ['bar']

// non-object argument will be coerced to an object
console.log(Object.values('foo')); // ['f', 'o', 'o']
```

性质

- [`Object.prototype.constructor`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor)

  指定创建对象原型的函数。

# 29.字符串方法

**1.concat**
将两个或多个字符的文本组合起来，返回一个新的字符串。

```js
var a = "hello";
var b = ",world";
var c = a.concat(b);
alert(c);
//c = "hello,world"
```

**2.indexOf**

返回字符串中一个子串第一处出现的索引（从左到右搜索）。如果没有匹配项，返回 -1 。

注意：indexOf()方法对大小写敏感，如果子字符串没有找到，返回-1。第二个参数表示从哪个下标开始查找，没有写则默认从下标0开始查找。

```js
var str="Hello World";
var str1=str.indexOf("o");
var str2=str.indexOf("world");
var str3=str.indexOf("o",str1+1);
console.log(str1); //4 默认只找第一个关键字位置，从下标0开始查找
console.log(str2); //-1 没有找到
console.log(str3); //7
```

**3.lastIndexOf**
返回字符串中一个子串最后一处出现的索引（从右到左搜索），如果没有匹配项，返回 -1 。

lastIndexOf()方法对大小写敏感，如果子字符串没有找到，返回-1。第二个参数表示从哪个下标开始查找，没有写则默认从最后一个字符处开始查找。

```js
var str="Hello World";
var str1=str.lastIndexOf("o");
var str2=str.lastIndexOf("world");
var str3=str.lastIndexOf("o",str1-1);
console.log(str1); //7
console.log(str2); //-1
console.log(str3); //4
```

**4.toLowerCase()**

把字符串转为小写，返回新的字符串。

```js
var str="Hello World";
var str1=str.toLowerCase();
console.log(str); //Hello World
console.log(str1); //hello world
```

**5.toUpperCase()**

把字符串转为大写，返回新的字符串。

```js
var str="hello world";
var str1=str.toUpperCase();
console.log(str); //hello world
console.log(str1); //HELLO WORLD
```

**6.charAt()**

返回指定下标位置的字符。如果index不在0-str.length(不包含str.length)之间，返回空字符串。

```js
var str="hello world";
var str1=str.charAt(6);
console.log(str1); 
```

**7.charCodeAt()**

返回指定下标位置的字符的unicode编码,这个返回值是 0 - 65535 之间的整数。如果index不在0-str.length(不包含str.length)之间，返回NaN。

```js
var str="hello world";
var str1=str.charCodeAt(1);
var str2=str.charCodeAt(-2); //NaN
console.log(str1); //101
```

**8.slice()**

 返回字符串中提取的子字符串。（不改变原数组）

```js
var str="Hello World";
var str1=str.slice(2); //如果只有一个参数，则提取开始下标到结尾处的所有字符串
var str2=str.slice(2,7); //两个参数，提取下标为2，到下标为7但不包含下标为7的字符串
var str3=str.slice(-7,-2); //如果是负数，-1为字符串的最后一个字符。提取从下标-7开始到下标-2但不包含下标-2的字符串。前一个数要小于后一个数，否则返回空字符串

console.log(str1); //llo World
console.log(str2); //llo W
console.log(str3); //o Wor
```

**9.substring()**

提取字符串中介于两个指定下标之间的字符。

注意：substring()用法与slice()一样，但不接受负值的参数

```js
var str="Hello World";
var str1=str.substring(2)
var str2=str.substring(2,2);
var str3=str.substring(2,7);
console.log(str1); //llo World
console.log(str2); //如果两个参数相等，返回长度为0的空串
console.log(str3); //llo W
```

**10.substr()**

substr(start,length)返回从指定下标开始指定长度的的子字符串

```js
var str="Hello World";
var str1=str.substr(1)
var str2=str.substr(1,3);
var str3=str.substr(-3,2);
console.log(str1); //ello World 
console.log(str2); //ell
console.log(str3); //rl
```

注意：如果没有指定length,返回从下标开始处结尾处的所有字符串

**11.split()**

把字符串分割成字符串数组

```js
var str="AA BB CC DD";
var string1="1:2:3:4:5";
var str1=str.split("");//如果把空字符串 ("")用作分割符，那么字符串的每个字符之间都会被分割
var str2=str.split(" "); //以空格为分隔符
var str3=str.split("",4); //4指定返回数组的最大长度
var str4=string1.split(":");
console.log(str1); // ["A", "A", " ", "B", "B", " ", "C", "C", " ", "D", "D"]
console.log(str2); //["AA" "BB" "CC" "DD"]
console.log(str3); //["A", "A", " ", "B"]
console.log(str4); // ["1", "2", "3", "4", "5"]
```

**12.replace()**

在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。

```js
var str="hello WORLD";
var reg=/o/ig; //o为要替换的关键字，不能加引号，否则替换不生效，i忽略大小写，g表示全局查找。
var str1=str.replace(reg,"**")
console.log(str1); //hell** W**RLD
```

**13.match()**

返回所有查找的关键字内容的数组。

```js
var str="To be or not to be";
var reg=/to/ig;
var str1=str.match(reg);
console.log(str1); //["To", "to"]
console.log(str.match("Hello")); //null
```

**14.trim()**

trim() 方法删除字符串两端的空白符

警告：Internet Explorer 8 或更低版本不支持 trim() 方法。

```js
var str = "       Hello World!        ";
alert(str.trim());  //  Hello World!
```

# 31.call、apply、bind

**1.call**

call、apply、bind都是改变this指向的方法

```react
fn.call(obj, 1, 2);
fn.apply(obj, [1, 2]);
fn.bind(obj, 1, 2);
```

把找到的`call`方法执行
当`call`方法执行的时候，内部处理了一些事情
1.首先把要操作的函数中的this关键字变为`call`方法第一个传递的实参
2.把`call`方法第二个及之后的实参获取到
3.把要操作的函数执行，并且把第二个以后传递进来的实参传递给函数

**2.apply**

- apply：和call基本上一致，唯一区别在于传参方式

**3.bind**

- bind：语法和call一模一样，区别在于立即执行还是等待执行，bind不兼容IE6~8

# 33.Diff算法与虚拟DOM中key的作用

简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。   

详细的说: 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】,                        

随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下： 

a. 旧虚拟DOM中找到了与新虚拟DOM相同的key：                    

(1).若虚拟DOM中内容没变, 直接使用之前的真实DOM             

(2).若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM                

b. 旧虚拟DOM中未找到与新虚拟DOM相同的key，根据数据创建新的真实DOM，随后渲染到到页面      



**用index作为key可能会引发的问题：**                

\1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作                       

会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低。             

\2. 如果结构中还包含输入类的DOM                        

会产生错误DOM更新 ==> 界面有问题。         

\3. 注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，            

 仅用于渲染列表用于展示，使用index作为key是没有问题的。

\3. 开发中如何选择key

1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。           

2.如果确定只是简单的展示数据，用index也是可以的。

# 34.正则匹配

http://c.biancheng.net/view/5632.html

**1.描述字符**

根据正则表达式语法规则，大部分字符仅能够描述自身，这些字符被称为普通字符，如所有的字母、数字等。

元字符就是拥有特动功能的特殊字符，大部分需要加反斜杠进行标识，以便于普通字符进行区别，而少数元字符，需要加反斜杠，以便转译为普通字符使用。JavaScript 正则表达式支持的元字符如表所示。



| 元字符 | 描述                                   |
| ------ | -------------------------------------- |
| .      | 查找单个字符，除了换行和行结束符       |
| \w     | 查找单词字符                           |
| \W     | 查找非单词字符                         |
| \d     | 查找数字                               |
| \D     | 查找非数字字符                         |
| \s     | 查找空白字符                           |
| \S     | 查找非空白字符                         |
| \b     | 匹配单词边界                           |
| \B     | 匹配非单词边界                         |
| \0     | 查找 NUL字符                           |
| \n     | 查找换行符                             |
| \f     | 查找换页符                             |
| \r     | 查找回车符                             |
| \t     | 查找制表符                             |
| \v     | 查找垂直制表符                         |
| \xxx   | 查找以八进制数 xxxx 规定的字符         |
| \xdd   | 查找以十六进制数 dd 规定的字符         |
| \uxxxx | 查找以十六进制 xxxx规定的 Unicode 字符 |


表示字符的方法有多种，除了可以直接使用字符本身外，还可以使用 ASCII 编码或者 Unicode 编码来表示。

**2.描述字符范围**

在正则表达式语法中，放括号表示字符范围。在方括号中可以包含多个字符，表示匹配其中任意一个字符。如果多个字符的编码顺序是连续的，可以仅指定开头和结尾字符，省略中间字符，仅使用连字符`~`表示。如果在方括号内添加脱字符`^`前缀，还可以表示范围之外的字符。例如：

- [abc]：查找方括号内任意一个字符。
- [^abc]：查找不在方括号内的字符。
- [0-9]：查找从 0 至 9 范围内的数字，即查找数字。
- [a-z]：查找从小写 a 到小写 z 范围内的字符，即查找小写字母。
- [A-Z]：查找从大写 A 到大写 Z 范围内的字符，即查找大写字母。
- [A-z]：查找从大写 A 到小写 z 范围内的字符，即所有大小写的字母。

**3.选择匹配**

选择匹配类似于 JavaScript 的逻辑与运算，使用竖线`|`描述，表示在两个子模式的匹配结果中任选一个。例如：
\1) 匹配任意数字或字母

```
var r = /\w+|\d+/;
```

\2) 可以定义多重选择模式。设计方法：在多个子模式之间加入选择操作符。

```
var r = /(abc)|(efg)|(123)|(456)/;
```

为了避免歧义，应该为选择操作的多个子模式加上小括号。

**4.重复匹配**

在正则表达式语法中，定义了一组重复类量词，如表所示。它们定义了重复匹配字符的确数或约数。\

| 量词   | 描述                                          |
| ------ | --------------------------------------------- |
| n+     | 匹配任何包含至少一个 n 的字符串               |
| n*     | 匹配任何包含零个或多个 n 的字符串             |
| n?     | 匹配任何包含零个或一个 n 的字符串             |
| n{x}   | 匹配包含 x 个 n 的序列的字符串                |
| n{x,y} | 匹配包含最少 x 个、最多 y 个 n 的序列的字符串 |
| n{x,}  | 匹配包含至少 x 个 n 的序列的字符串            |

**5.惰性匹配**

重复类量词都具有贪婪性，在条件允许的前提下，会匹配尽可能多的字符。

- ?、{n} 和 {n,m} 重复类具有弱贪婪性，表现为贪婪的有限性。
- *、+ 和 {n,} 重复类具有强贪婪性，表现为贪婪的无限性。

与贪婪匹配相反，惰性匹配将遵循另一种算法：在满足条件的前提下，尽可能少的匹配字符。定义惰性匹配的方法：在重复类量词后面添加问号?限制词。贪婪匹配体现了最大化匹配原则，惰性匹配则体现最小化匹配原则。

下面示例演示了如何定义匹配模式。

```js
纯文本复制
var s = "<html><head><title></title></head><body></body></html>";
var r = /<.*?>/
var a = s.match(r);  //返回单个元素数组["<html>"]
```

6.边界量词

边界就是确定匹配模式的位置，如字符串的头部或尾部，具体说明如表所示。

| 量词 | 说明                                     |
| ---- | ---------------------------------------- |
| ^    | 匹配开头，在多行检测中，会匹配一行的开头 |
| $    | 匹配结尾，在多行检测中，会匹配一行的结尾 |



# 35.loadsh常用API

原生用法
直接使用的API

**_.reject**
根据条件去除某个元素。

```js
var foo = [
    {id: 0, name: "aaa", age: 33},
    {id: 1, name: "bbb", age: 25}
]
var bar = _.reject(foo, ['id', 0])

//bar = [{id: 1, name: "bbb", age: 25}]
```

**_.pick**
根据第二个参数的key的数组，筛选第一个参数中的值并返回

```js
var foo = {id: 0, name: "aaa", age: 33}
var bar = _.pick(foo, ['name', 'age'])
//bar = {name: "aaa", age: 33}
**_.keys**
返回object中的所有key

var foo = {id: 0, name: "aaa", age: 33}
var bar = _.keys(foo)
//bar = ['id', 'name', 'age']
```

**_.cloneDeep**
深度拷贝，这个不用多说了吧，js中基础类型以外的类型，都会默认拷贝备份

```js
var bar = _.cloneDeep(foo)
```

**_.find**
查找数组

```js
var foo = [
    {id: 0, name: "aaa", age: 33},
    {id: 1, name: "bbb", age: 25}
]
var bar = _.find(foo, ['id', 0])
//bar = {id: 0, name: "aaa", age: 33}
```

注意一下如果没找到的话，会返回undefined，要处理一下

**_.keyBy**
以某个属性为键，将数组转为对象

```js
var foo = var foo = [
    {id: 0, name: "aaa", age: 33},
    {id: 1, name: "bbb", age: 25}
]
var bar = _.keyBy(foo, 'name')
//bar = {
//    aaa: {id: 0, name: "aaa", age: 33},
//    bbb: {id: 1, name: "bbb", age: 25}
//}
```

**_.filter**
根据条件过滤出符合条件的元素，返回新数组

```js
var foo = var foo = [
    {id: 0, name: "aaa", age: 33},
    {id: 1, name: "bbb", age: 25}
]
var bar = _.filter(foo, ['name', "aaa"])
//bar = {
//    aaa: {id: 0, name: "aaa", age: 33}
//}
```

**_.map**
从集合中挑出一个key，将其值作为数组返回

```js
var foo = var foo = [
    {id: 0, name: "aaa", age: 33},
    {id: 1, name: "bbb", age: 25}
]
var bar = _.map(foo, 'name')
//bar = ["aaa", "bbb"]
_.max/_.min/_.sum
数组中最大值、最小值、数组求和

var foo = [1, 2, 3, 4]
var bar = _.max(foo)
//bar = 4
bar = _.min(foo)
//bar = 1
bar = _.sum(foo)
//bar = 10
_.pad/_.padStart/_.padEnd
在两端、开头、末尾补齐字符

var foo = "helloworld"
var bar = _.pad(foo, 14, '-')
//bar = --helloworld--
bar = _.padStart(foo, 14, '-')
//bar = ----helloworld
bar = _.padEnd(foo, 14, '-')
//bar = helloworld----
```

**组合用法**
如果说上面是基础技能，那么下面奉上几个炫酷的组合技：

**选出json数组中id最大的一项**

```js
var foo = [
    {id: 0, name: "aaa", age: 33},
    {id: 1, name: "bbb", age: 25}
]
var bar = _.find(foo, ['id', _.max(_.map(foo, 'id'))])
// bar = {id: 1, name: "bbb", age: 25}
ps:也可以用maxBy某个key来代替
```

**更新json数组中某一项的值**

```js
var foo = [
    {id: 0, name: "aaa", age: 33},
    {id: 1, name: "bbb", age: 25}
]
let list = _.keyBy(foo, 'id')
list[0].name = "ccc"
var bar = _.map(list)
// bar = [
//    {id: 0, name: "ccc", age: 33},
//    {id: 1, name: "bbb", age: 25}
//]
```

# **36.数组排序**

1、冒泡排序(两两对比)

以从小到大排序为例，冒泡排序的原理就是通过两层循环把数组中两两相邻的元素进行比较，是的大的元素放到后边，元素交换位置，从而一步步的交换元素的位置，使得最大的元素放到数组的末尾，这样内部的循环就进行了一轮，再根据外部的循环依次再把次大一点的元素放到数组的末尾，从而实现数组的逐步排序。代码如下：

```js
// 冒泡排序
var arr = [52,3,8,57,75,2,1];
for (var i = 0; i<arr.length; i++) {
	for (var j =0;j<arr.length-i; j++) {
		if(arr[j]>arr[j+1]){
			var temp = arr[j];
			arr[j]=arr[j+1];
			arr[j+1]=temp; 
		}
	}
}
console.log(arr); //[1, 2, 3, 8, 52, 57, 75]
```

```js
(7) [3, 8, 52, 57, 2, 1, 75]
(7) [3, 8, 52, 2, 1, 57, 75]
(7) [3, 8, 2, 1, 52, 57, 75]
(7) [3, 2, 1, 8, 52, 57, 75]
(7) [2, 1, 3, 8, 52, 57, 75]
(7) [1, 2, 3, 8, 52, 57, 75]
(7) [1, 2, 3, 8, 52, 57, 75]
(7) [1, 2, 3, 8, 52, 57, 75]
```

这里面通过一个变量temp实现相邻两个元素的位置替换，从而循环一轮使得最大的元素放到数组的末尾。

**插入排序**

（抓住一个跟前面的对比大小，自己小的话就交换位置再继续往前对比，直到没有元素或者比自己小的元素出现才停止比较）

```js
 var arr = [5, 2, 1, 10, 8, 12, 40, 26, 30];
      var insertSort = function (arr) {
        var len = arr.length;
        var preIndex, current;
        for (var i = 1; i < len; i++) {
          preIndex = i - 1;
          current = arr[i];
          while (preIndex >= 0 && arr[preIndex] > current) {
            arr[preIndex + 1] = arr[preIndex];
            preIndex--;
            console.log("arr", arr);
          }
          arr[preIndex + 1] = current;
          console.log(arr);
        }
        return arr;
      };
      console.log("insertSort", insertSort(arr));
```

```js
arr (9) [5, 5, 1, 10, 8, 12, 40, 26, 30]
(9) [2, 5, 1, 10, 8, 12, 40, 26, 30]
arr (9) [2, 5, 5, 10, 8, 12, 40, 26, 30]
arr (9) [2, 2, 5, 10, 8, 12, 40, 26, 30]
(9) [1, 2, 5, 10, 8, 12, 40, 26, 30]
(9) [1, 2, 5, 10, 8, 12, 40, 26, 30]
arr (9) [1, 2, 5, 10, 10, 12, 40, 26, 30]
(9) [1, 2, 5, 8, 10, 12, 40, 26, 30]
(9) [1, 2, 5, 8, 10, 12, 40, 26, 30]
(9) [1, 2, 5, 8, 10, 12, 40, 26, 30]
arr (9) [1, 2, 5, 8, 10, 12, 40, 40, 30]
(9) [1, 2, 5, 8, 10, 12, 26, 40, 30]
arr (9) [1, 2, 5, 8, 10, 12, 26, 40, 40]
(9) [1, 2, 5, 8, 10, 12, 26, 30, 40]
insertSort (9) [1, 2, 5, 8, 10, 12, 26, 30, 40]
```

**快速排序**

快速排序是运用递归进行循环调用函数从而使得数组进行排序，代码如下：

```js
// 快速排序
function quickSort(arr){
  if(arr.length <= 1) return arr;
  var Temp = Math.floor(arr.length/2);
  var left = [],right = [];
  var num = arr.splice(Temp,1)[0];
  for(var i = 0;i < arr.length;i ++){
    if(arr[i] < num){
      left.push(arr[i]);
    }
    else {
      right.push(arr[i]);
    }
  }
  return quickSort(left).concat(num,quickSort(right));
}
var arr=[5,2,1,10,8,12,40,26,30];
console.log(quickSort(arr)); //[1, 2, 5, 8, 10, 12, 26, 30, 40]
```

其原理是首先创建一个递归函数，也就是函数的返回值还是函数本身，直到符合条件之后递归函数停止运行，像这个函数就是当时arr数组的长度小于等于1的时候该递归函数停止运行。基本原理就是先找到数组中的中间那个元素的索引，如果数组长度是双数，那么就默认向上取值，也就是默认取数组长度/2+1位索引，在根据索引去的数组中间的值，然后创建两个空数组，用来放置比该元素小的值和比该元素大的值，在循环数组进行判断，如果数组的元素小于该中间位置元素的值，就放到左边数组，反之放到右边的数组，在函数中返回值设置为左边数组+中间的值+右边数组的拼接新数组，然后再根据递归对左边和右边的数组分别进行刚才的操作，直到数组的长度小于或者等于1，这时候停止，这时候调用函数之后，传入一个数组，就会自动返回数组排序之后的新数组，这就是快速排序的原理。

**array.sort():**

sort() 方法用于对数组的元素进行排序，默认按“字母”升序，即使数组的元素是数字，因此，对于数字，就需要特殊的写法了。

**普通数组：**

\1. 字符串数组：

```
var fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.sort();//默认升序　　Apple,Banana,Mango,Orange
fruits.sort().reverse();//降序　　Orange,Mango,Banana,Apple
```

\2. 数字数组：

由于sort()方法默认按“字母”升序，所以对于数字组成的数组，就需要使用特殊的写法来进行排序了。

先上代码，具体写法如下：

```
arr.sort((a,b)=>{return a-b})//升序
arr.sort((a,b)=>{return b-a})//降序
```

如上，使用数字对数组进行排序，就需要通过一个函数作为参数来调用。

**对象数组：**

使用场景——已知某品牌门店列表数据（含距当前位置的距离），需要按距离由仅及远排序，具体实现方法如下：

```js
var shoplist = [{
  "name": "上塘中海锦城",
  "distance": 14307.0275
}, {
  "name": "汉堡王深圳华强北店",
  "distance": 16606.5901
}, {
  "name": "汉堡王深圳蔡屋围店",
  "distance": 18062.4395
}, {
  "name": "汉堡王深圳金丰城店",
  "distance": 18468.4439
}, {
  "name": "汉堡王深圳地王店",
  "distance": 18484.8283
}, {
  "name": "汉堡王深圳龙岗宝能店",
  "distance": 39006.9269
}, {
  "name": "汉堡王深圳龙华绿景香颂店",
  "distance": 15356.4863
}, {
  "name": "汉堡王深圳西荟城店",
  "distance": 24990.1325
}, {
  "name": "汉堡王深圳魅力时代店",
  "distance": 8228.8474
}, {
  "name": "汉堡王深圳福华三路店",
  "distance": 12693.439
}]
shoplist.sort((a, b) => {
  return a.distance - b.distance
})
```

如上，关键代码就一句： 

```
shoplist.sort((a,b)=>{return a.distance-b.distance})
```

简单分析不难发现，这跟上面数字数组排序用法是一样的，只不过是这里使用了数组中对象元素的 distance 这一数字字段进行比较排序的。

经过排序后的数据如下图，门店列表已经按距离字段进行升序排列，根据这些排序后的数据进行展示就OK了：

![img](https://img2018.cnblogs.com/blog/546882/201810/546882-20181023150935632-83581668.png)

**反序排序：**

与上面排序不同，反转排序方法 reverse() 将一个数组中的元素的顺序反转排序。

这个方法单独使用的场景不多，但是结合sort()排序方法使用的场景比较多一些，特别是对于一些复杂的数组。

如网上商城商品搜索列表页面的正序、反序，有根据价格的，有根据销量的，还有根据评价的，如果单单是正序，或者是排序，那么直接用sort()方法就好了。但如果正序排序之后又需要进行反序排列，那么直接用reverse()进行反转就OK了，没必要再用sort()进行反序排列，无论是在写法上，还是计算速度上都要快好多的：

```js
//1. sort()进行反序
shoplist.sort((a,b)=>{return b.distance-a.distance})
//2. reverse()反序
shoplist.reverse()
```

# 37.垃圾回收机制

**1. 概述**

JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。

C#、Java、JavaScript有自动垃圾回收机制，但c++和c就没有垃圾回收机制，也许是因为垃圾回收机制必须由一种平台来实现。在JS中，JS的执行环境会负责管理代码执行过程中使用的内存。

**2. 变量的生命周期**

当一个变量的生命周期结束之后它所指向的内存就应该被释放。JS有两种变量，全局变量和在函数中产生的局部变量。局部变量的生命周期在函数执行过后就结束了，此时便可将它引用的内存释放（即垃圾回收），但全局变量生命周期会持续到浏览器关闭页面。

**3. JS垃圾回收方式**

JS执行环境中的垃圾回收器怎样才能检测哪块内存可以被回收有两种方式：标记清除（mark and sweep）、引用计数(reference counting)。

**3.1 标记清除（mark and sweep）**

大部分浏览器以此方式进行垃圾回收，当变量进入执行环境（函数中声明变量）的时候，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”，在离开环境之后还有的变量则是需要被删除的变量。标记方式不定，可以是某个特殊位的反转或维护一个列表等。

垃圾收集器给内存中的所有变量都加上标记，然后**去掉环境中的变量以及被环境中的变量引用的变量的标记**。在此之后再被加上的标记的变量即为需要回收的变量，因为环境中的变量已经无法访问到这些变量。

**3.2 引用计数(reference counting)**

这种方式常常会引起内存泄漏，低版本的IE使用这种方式。机制就是跟踪一个值的引用次数，当声明一个变量并将一个引用类型赋值给该变量时该值引用次数加1，当这个变量指向其他一个时该值的引用次数便减一。当该值引用次数为0时就会被回收。

该方式会引起内存泄漏的原因是它不能解决循环引用的问题：

```
function sample(){
    var a={};
    var b={};
    a.prop = b;
    b.prop = a;
}
```

这种情况下每次调用sample()函数，a和b的引用计数都是2，会使这部分内存永远不会被释放，即内存泄漏。****

# 39.http和https

http 明文传输

https 加密传输

**1、为什么需要HTTPS？**

HTTPS 是安全版的 HTTP。

HTTP 协议在传输数据时采用的是明⽂方式传递，因此，⼀些敏感信息的传输就变得很不安全。

>  而 HTTPS 就是为了解决 HTTP 的不安全⽽产⽣的。(明文传输)

**2、HTTPS是如何保证安全的？**

HTTPS 在传输数据的过程中会对数据进行加密处理，保证安全性。

那HTTPS采用的什么样的加密方式呢？我们来了解下一些加密的基本概念。

目前常见的加密算法可以分成三类，对称加密算法，非对称加密算法和Hash算法。

hash算法 ==> 不能被反向解密

**3、什么是对称加密？**

对称加密的特点是文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥，

这种方法在密码学中叫做对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难

通信的双⽅都使⽤同⼀个秘钥进⾏加解密。⽐如，两个人事先约定的暗号，就属于对称加密。



![img](http://weldon.flywen.top/image/20210527233628.png)

对称加密的特点是：

-  优点:
   计算量小、加密速度快、加密效率高。 

-  缺点:
   在数据传送前，发送方和接收方必须商定好秘钥，然后双方保存好秘钥。
   如果一方的秘钥被泄露，那么加密信息也就不安全了

使用场景：本地数据加密、https通信、网络传输等

常见算法：AES、DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6

**4、什么是非对称加密？**

传输密钥

而加密和解密其实可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，

这样就避免了直接传递密钥。这种新的加密模式被称为"非对称加密算法"。

通信的双方使用不同的秘钥进行加密解密，即秘钥对（私钥 + 公钥）。

特征: 私钥可以解密公钥加密的内容,  公钥可以解密私钥加密的内容

![img](http://weldon.flywen.top/image/20210527234705.png)

非对称加密的特点是：

-  优点：非对称加密与对称加密相比其安全性更好 

-  缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。 

使用场景：https会话前期、CA数字证书、信息加密、登录认证等

常见算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）

**HTTPS 加密解决方案**

结合了两种加密⽅式：

-  将 `对称加密的密钥` ⽤非对称加密的公钥, 进⾏加密并发送出去，接收⽅使⽤私钥解密得到 `对称加密密钥` 

-  双⽅沟通时使⽤ `对称加密密钥` 进⾏ 

**可以看到，只有在发送秘钥阶段才使用非对称加密，而后续的通信都使用对称加密，这样解决了性能问题。**

HTTPS 目前所使用的 TLS或SSL协议,  就是目前采用的加密通道的规范协议

它利用对称加密、(公私钥)非对称加密, 以及其密钥交换算法，可完成可信任的信息传输

**6、数字证书**

为了安全性, 一般还需要签发数字证书!

客户端 和 服务器端要初步互通消息时,  客户端发送请求可以拿到公开的公钥信息

进而进行非对称加密, 使用公钥, 加密`对称加密密钥`, 传递给服务器, 后续通信都使用对称加密!

![img](http://weldon.flywen.top/image/20210527235153.png)



**问题是: 初步互通消息时, 如果请求拿到的公钥信息, 就是假的, 或者不安全的! 那么后续的所有操作, 都将是不安全的!**

所以, 就需要有数字证书(CA证书),  一般是CA机构颁发的, 证明这个公钥是安全可靠的!

**CA证书中心会对你网站的公钥, 网站的域名地址,  证书到期时间, 等一些相关信息一起加密签发数字证书, 保证你网站的安全性**

![img](http://weldon.flywen.top/image/20210527233637.png)



当公司申请了 CA 证书后, 就应该在响应时, 将数字证书一起发送给客户端



![img](http://weldon.flywen.top/image/20210527233641.png)



而客户端, 接收到消息后, 就可以查看证书

1.  如果正在访问的网站 和 证书记载的网址 不一致, 说明不安全,  可能被冒用, 浏览器就会发出警告!!! 

1.  如果签发证书的机构, 不权威, 发出警告
    ![img](http://weldon.flywen.top/image/20210527233644.png) 

1.  如果证书过期了, 浏览器也会发出警告 

**7、数字签名**

但这还是有问题：如果证书被篡改了怎么办?

这时就需要用⼀个技术：**数字签名**。 (根据证书内容, 生成的一个唯一标识)

数字签名就是先⽤ **CA ⾃带的 Hash 算法来计算出证书内容的⼀个摘要**，然后使⽤ CA 私钥进行加密，组成数字签名。

当别⼈把他的证书发过来时，**接收方⽤同样的算法再次⽣成摘要**，⽤ CA 公钥解密后得到CA生成的摘要，两者进行对⽐后,

就能确定中间是否被⼈篡改。这样就能最⼤程度的保证通信的安全了。

# 40.es6的promise，async，await，Generator 函数有什么区别

**async 函数与 Promise、Generator 函数的比较**

 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（then、catch等等），操作本身的语义反而不容易看出来。

 Generator 函数语义比 Promise 写法更清晰，这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数。

 Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。

 它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。

 如果使用 Generator 写法，自动执行器需要用户自己提供。

**Generator函数**

Generator是协程在ES6的实现，最大的特点就是可以交出函数的执行权，懂得退让。

```jsx
function* gen(x) {
    var y = yield x +2;
    return y;
  }
  
  var g = gen(1);
  console.log( g.next()) // { value: 3, done: false }
  console.log( g.next()) // { value: undefined, done: true }
```

上面代码中，函数多了*号，用来表示这是一个Generator函数，和普通函数不一样，不同之处在于执行它不会返回结果，

返回的是指针对象g，这个指针g有个next方法，调用它会执行异步任务的第一步。
 对象中有两个值，value和done，value 属性是 yield 语句后面表达式的值，表示当前阶段的值，done表示是否Generator函数是否执行完毕。

下面看看Generator函数如何执行一个真实的异步任务

```jsx
var fetch = require('node-fetch');

function* gen(){
  var url = 'https://api.github.com/users/github';
  var result = yield fetch(url);
  console.log(result.bio);
}
```

```kotlin
var g = gen();
var result = g.next();

result.value.then( data => return data.json)
                  .then (data => g.next(data))
```

上面代码中，首先执行Generator函数，得到对象g，调用next方法，此时
 `result ={ value: Promise { <pending> }, done: false }`
 因为fetch返回的是一个Promise对象，（即value是一个Promise对象）所以要用then才能调用下一个next方法。

# **41.强缓存和协商缓存**

![img](https://images2015.cnblogs.com/blog/408483/201605/408483-20160525182943272-204994049.png)

从上图可以知道，浏览器缓存包含两种类型，即强缓存（也叫本地缓存）和协商缓存，浏览器在第一次请求发生后，再次请求时：

- 浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息），若命中直接从缓存中获取资源信息，包括缓存header信息；本次请求根本就不会与服务器进行通信；在firebug下可以查看某个具有强缓存资源返回的信息，例如本地firebug查看的一个强缓存js文件
- 如果没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/If-Modified-Since和Etag/If-None-Match），由服务器根据请求中的相关header信息来比对结果是否协商缓存命中；若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容

**（一）、强缓存**

强缓存主要包括 `expires` 和 `cache-control`。

**1、expires**

当我们请求一个资源，服务器返回时会带有一个 `expires` 字段表示资源的过期时间。

它是一个**时间戳**（准确点应该叫格林尼治时间），当客户端再次请求该资源的时候，会把客户端时间与该时间戳进行对比，如果大于该时间戳则已过期，否则直接使用该缓存资源。

但是，有个大问题，

发送请求时是使用的**客户端时间**去对比。

一、是客户端和服务端时间可能快慢不一致，

二、是客户端的时间是可以自行修改的（比如浏览器是跟随系统时间的，修改系统时间会影响到），所以不一定满足预期。

**2、cache-control**

所以当 `cache-control` 和 `expires` 都存在时，`cache-control` 优先级更高。该字段是一个时间长度，单位秒，表示该资源过了多少秒后失效。当客户端请求资源的时候，发现该资源还在有效时间内则使用该缓存，它**不依赖客户端时间**

**3.pragma**

他的值有 `no-cache` 和 `no-store`，表示意思同 `cache-control`，优先级高于 `cache-control` 和 `expires`，即三者同时出现时，先看 `pragma` -> `cache-control` -> `expires`。

**（二）、协商缓存**

如果没有命中强缓存，浏览器会发送请求到服务器，验证资源是否更新，如果没更新才继续使用本地缓存，此时返回的是 304，这就是协商缓存。协商缓存主要包括 `last-modified` 和 `etag`。

**1、last-modified**

last-modified` 记录资源最后修改的时间。启用后，请求资源之后的响应头会增加一个 `last-modified

服务端会对比该字段和资源的最后修改时间，若一致则证明没有被修改，告知浏览器可直接使用缓存并返回 304；若不一致则直接返回修改后的资源，并修改 `last-modified` 为新的值。

但 `last-modified` 有以下两个缺点：

- 只要编辑了，不管内容是否真的有改变，都会以这最后修改的时间作为判断依据，当成新资源返回，从而导致了没必要的请求响应，而这正是缓存本来的作用即避免没必要的请求。
- 时间的精确度只能到秒，如果在一秒内的修改是检测不到更新的，仍会告知浏览器使用旧的缓存。

**2、etag**

为了解决 `last-modified` 上述问题，有了 `etag`。 `etag` 会基于资源的内容编码生成一串唯一的标识字符串，只要内容不同，就会生成不同的 `etag`。当再次请求该资源时，请求头会带有 `if-none-match` 字段，值是之前返回的 `etag` 值，服务端会根据该资源当前的内容生成对应的标识字符串和该字段进行对比，若一致则代表未改变可直接使用本地缓存并返回 304；若不一致则返回新的资源（状态码200）并修改返回的 `etag` 字段为新的值。

可以看出 `etag` 比 `last-modified` 更加精准地感知了变化，所以 `etag` 优先级也更高。不过从上面也可以看出 `etag` 存在的问题，就是每次生成标识字符串会增加服务器的开销

**访问刷新分析**

- 标签进入、输入url回车进入

  强缓存、协商缓存都生效

- 按刷新按钮、F5 刷新、网页右键“重新加载”

  强缓存过期、协商缓存生效

- ctrl + F5 强制刷新

  强缓存、协商缓存都失效

# 42.git

**新增文件**的命令：git add file或者git add .
**提交文件**的命令：git commit –m或者git commit –a
查看**工作区状况**：git status –s
**拉取合并远程分支**的操作：git fetch/git merge或者git pull
查看**提交记录命令**：git reflog

创建本地分支：$ git branch [name] ----注意新分支创建后不会自动切换为当前分支

切换分支：$ git checkout [name]

创建新分支并立即切换到新分支：$ git checkout -b [name]

删除分支：$ git branch -d [name] ---- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项

合并分支：$ git merge [name] ----将名称为[name]的分支与当前分支合并

创建远程分支(本地分支push到远程)：$ git push origin [name]

删除远程分支：$ git push origin :heads/[name] 或 $ gitpush origin :[name] 

如果想撤销提交到索引区的文件，可以通过git reset HEAD file；

如果想撤销提交到本地仓库的文件，可以通过**git reset –soft HEAD^n**恢复当前分支的版本库至上一次提交的状态，索引区和工作空间不变更；

可以通过**git reset –mixed HEAD^n**恢复当前分支的版本库和索引区至上一次提交的状态，工作区不变更；

可以通过**git reset –hard HEAD^n**恢复当前分支的版本库、索引区和工作空间至上一次提交的状态。

**1.提交时发生冲突，你能解释冲突是如何产生的吗？你是如何解决的？**
		开发过程中，我们都有自己的特性分支，所以冲突发生的并不多，但也碰到过。诸如公共类的公共方法，我和别人同时修改同一个文件，他提交后我再提交就会报冲突的错误。
		发生冲突，在IDE里面一般都是对比本地文件和远程分支的文件，然后把远程分支上文件的内容手工修改到本地文件，然后再提交冲突的文件使其保证与远程分支的文件一致，这样才会消除冲突，然后再提交自己修改的部分。特别要注意下，修改本地冲突文件使其与远程仓库的文件保持一致后，需要提交后才能消除冲突，否则无法继续提交。必要时可与同事交流，消除冲突。
发生冲突，也可以使用命令。

​	通过git stash命令，把工作区的修改提交到栈区，目的是保存工作区的修改；
​	通过git pull命令，拉取远程分支上的代码并合并到本地分支，目的是消除冲突；
​	通过git stash pop命令，把保存在栈区的修改部分合并到最新的工作空间中；

**如果本次提交误操作，如何撤销？**
如果想撤销提交到索引区的文件，可以通过git reset HEAD file；如果想撤销提交到本地仓库的文件，可以通过git reset –soft HEAD^n恢复当前分支的版本库至上一次提交的状态，索引区和工作空间不变更；可以通过git reset –mixed HEAD^n恢复当前分支的版本库和索引区至上一次提交的状态，工作区不变更；可以通过

**git reset –hard HEAD^n**

恢复当前分支的版本库、索引区和工作空间至上一次提交的状态。

**你使用过git stash命令吗？你一般什么情况下会使用它？**
命令git stash是把工作区修改的内容存储在栈区。
以下几种情况会使用到它：

解决冲突文件时，会先执行git stash，然后解决冲突；
遇到紧急开发任务但目前任务不能提交时，会先执行git stash，然后进行紧急任务的开发，然后通过git stash pop取出栈区的内容继续开发；
切换分支时，当前工作空间内容不能提交时，会先执行git stash再进行分支切换；

**能不能说一下git fetch和git pull命令之间的区别？**
简单来说：git fetch branch是把名为branch的远程分支拉取到本地；而git pull branch是在fetch的基础上，把branch分支与当前分支进行merge；因此pull = fetch + merge



# 43.如何实现左右垂直居中

实现居中效果的方法：
**1、absolute + 负margin**

```css
father{
           position: relative;//父元素设置绝对定位
       }
       .son{
           position: absolute;
           width:100px;
     		height:100px;
           top: 50%;
           left: 50%;
           margin-left: -50px;
           margin-top: -50px;
       }
```

**2、absolute + margin auto**

```css
.father{
          position: relative;//父元素设置绝对定位
      }
      .son{
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          margin: auto;
      }
```

**3、absolute + transform**

```css
.father{
          position: relative;//父元素设置绝对定位
      }
      .son{
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%,-50%);
      }
```

4.flex布局

```css
.father{
        display: flex;
        justify-content: center; /*显示在主轴的中间*/
        align-items: center; /*子项在侧轴中间位置*/
    }
```



# 44.伪类和伪元素区别

- `CSS` 伪类用于向某些选择器添加特殊的效果。
- `CSS` 伪元素用于将特殊的效果添加到某些选择器。

**伪类种类**

![请输入图片描述](http://segmentfault.com/img/bVcccn)

**伪元素种类**

![请输入图片描述](http://segmentfault.com/img/bVccco)

# 45.HTTP请求行、请求头、请求体以及响应行、响应头、**响应体**

一、HTTP请求报文

HTTP请求报文由3部分组成（请求行+请求头+请求体）：

![img](https://img-blog.csdn.net/20170707143243946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGV5dWVfOTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

请求行：

①是请求方法，GET和POST是最常见的HTTP方法，除此以外还包括DELETE、HEAD、OPTIONS、PUT、TRACE。

②为请求对应的URL地址，它和报文头的Host属性组成完整的请求URL。

③是协议名称及版本号。

请求头：

④是HTTP的报文头，报文头包含若干个属性，格式为“属性名:属性值”，服务端据此获取客户端的信息。

与缓存相关的规则信息，均包含在header中

请求体：

⑤是报文体，它将一个页面表单中的组件值通过param1=value1&param2=value2的键值对形式编码成一个格式化串，它承载多个请求参数的数据。不但报文体可以传递请求参数，请求URL也可以通过类似于“/chapter15/user.html? param1=value1&param2=value2”的方式传递请求参数。 

二、HTTP响应报文

HTTP的响应报文也由三部分组成（响应行+响应头+响应体）

![img](https://img-blog.csdn.net/20170707145557633?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaGV5dWVfOTk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

响应行：

①报文协议及版本； 
②状态码及状态描述；

响应头：

③响应报文头，也是由多个属性组成；

响应体：

④响应报文体，即我们真正要的“干货”

# **46.vue和react区别**

**实现上，Vue跟React的最大区别在于数据的reactivity，就是反应式系统上。**Vue提供反应式的数据，当数据改动时，界面就会自动更新，而React里面需要调用方法SetState。我把两者分别称为**[Push-based](https://www.zhihu.com/search?q=Push-based&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A1066629375})**和**Pull-based**。所谓Push-based就是说，改动数据之后，数据本身会把这个改动推送出去，告知渲染系统自动进行渲染。在React里面，它是一个Pull的形式，用户要给系统一个明确的信号说明现在需要重新渲染了，这个系统才会重新渲染。两者并没有绝对的优劣之分，更多的也是思维模式和开发习惯的不同

# **47.react生命周期**

![img](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F13617804-d074e34a83769a92.png&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1641449201&t=3e2a4984e45dc6aecb409a09359fa1b1)

![img](https://img-blog.csdnimg.cn/c9668cce90ab4840b7a2be0c60f0a86b.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54yr6ICB5p2_55qE6LGG,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

**1. 挂载卸载过程**

1. 父constructor
2. 父componentWillMount
3. 父render
4. 子constructor
5. 子componentWillMount
6. 子render
7. 子componentDidMount
8. 父componentDidMount

**1.1.constructor()**

constructor()中完成了React数据的初始化，它接受两个参数：props和context，当想在函数内部使用这两个参数时，需使用super()传入这两个参数。
 注意：只要使用了constructor()就必须写super(),否则会导致this指向错误。

**1.2.componentWillMount()**

componentWillMount()一般用的比较少，它更多的是在服务端渲染时使用。它代表的过程是组件已经经历了constructor()初始化数据后，但是还未渲染DOM时。

**1.3.componentDidMount()**

组件第一次渲染完成，此时dom节点已经生成，可以在这里调用ajax请求，返回数据setState后组件会重新渲染

**1.4.componentWillUnmount ()**

在此处完成组件的卸载和数据的销毁。

1. clear你在组建中所有的setTimeout,setInterval
2. 移除所有组建中的监听 removeEventListener
3. 有时候我们会碰到这个warning:

```csharp
Can only update a mounted or mounting component. This usually      means you called setState() on an unmounted component. This is a   no-op. Please check the code for the undefined component.
```

原因：因为你在组件中的ajax请求返回setState,而你组件销毁的时候，请求还未完成，因此会报warning
 解决方法：

```kotlin
componentDidMount() {
    this.isMount === true
    axios.post().then((res) => {
    this.isMount && this.setState({   // 增加条件ismount为true时
      aaa:res
    })
})
}
componentWillUnmount() {
    this.isMount === false
}
```

**2. 更新过程**

**2.1. componentWillReceiveProps (nextProps)**

1. 在接受父组件改变后的props需要重新渲染组件时用到的比较多
2. 接受一个参数nextProps
3. 通过对比nextProps和this.props，将nextProps的state为当前组件的state，从而重新渲染组件



```kotlin
  componentWillReceiveProps (nextProps) {
    nextProps.openNotice !== this.props.openNotice&&this.setState({
        openNotice:nextProps.openNotice
    }，() => {
      console.log(this.state.openNotice:nextProps)
      //将state更新为nextProps,在setState的第二个参数（回调）可以打         印出新的state
  })
}
```





**2.2.shouldComponentUpdate(nextProps,nextState)**

1. 主要用于**性能优化**(部分更新)
2. 唯一用于控制组件重新渲染的生命周期，由于在react中，setState以后，state发生变化，组件会进入重新渲染的流程，在这里**return false**可以阻止组件的更新
3. 因为react父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断



**2.3.componentWillUpdate (nextProps,nextState)**

shouldComponentUpdate返回true以后，组件进入重新渲染的流程，进入componentWillUpdate,这里同样可以拿到nextProps和nextState。

**2.4.componentDidUpdate(prevProps,prevState)**

组件更新完毕后，react只会在第一次初始化成功会进入componentDidmount,之后每次重新渲染后都会进入这个生命周期，这里可以拿到prevProps和prevState，即更新前的props和state。

**2.5.render()**

render函数会插入jsx生成的dom结构，react会生成一份虚拟dom树，在每一次组件更新时，在此react会通过其diff算法比较更新前后的新旧DOM树，比较以后，找到最小的有差异的DOM节点，并重新渲染。

**3. React新增的生命周期(个人补充)**

![img](https:////upload-images.jianshu.io/upload_images/16775500-102dbe772034e8fa.png?imageMogr2/auto-orient/strip|imageView2/2/w/1002/format/webp)

React新增生命周期

**3.1. static-getDerivedStateFromProps(nextProps, prevState)**

**				state的值在任何时候都取决于props         return null**

代替componentWillReceiveProps()。      <u>派生状态会导致代码冗余,使组件难以维护</u>
 老版本中的componentWillReceiveProps()方法判断前后两个 props 是否相同，如果不同再将新的 props 更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。

这两者最大的不同就是:
 在 componentWillReceiveProps 中，我们一般会做以下两件事，一是根据 props 来更新 state，二是触发一些回调，如动画或页面跳转等。

1. 在老版本的 React 中，这两件事我们都需要在 componentWillReceiveProps 中去做。
2. 而在新版本中，官方将更新 state 与触发回调重新分配到了 getDerivedStateFromProps 与 componentDidUpdate 中，使得组件整体的更新逻辑更为清晰。而且在 getDerivedStateFromProps 中还禁止了组件去访问 this.props，强制让开发者去比较 nextProps 与 prevState 中的值，以确保当开发者用到 getDerivedStateFromProps 这个生命周期函数时，就是在根据当前的 props 来更新组件的 state，而不是去做其他一些让组件自身状态变得更加不可预测的事情。

**3.2. getSnapshotBeforeUpdate(prevProps, prevState)**

代替componentWillUpdate。
 常见的 componentWillUpdate 的用例是在组件更新前，读取当前某个 DOM 元素的状态，并在 componentDidUpdate 中进行相应的处理。
 这两者的区别在于：

1. 在 React 开启异步渲染模式后，在 render 阶段读取到的 DOM 元素状态并不总是和 commit 阶段相同，这就导致在
    componentDidUpdate 中使用 componentWillUpdate 中读取到的 DOM 元素状态是不安全的，因为这时的值很有可能已经失效了。
2. getSnapshotBeforeUpdate 会在最终的 render 之前被调用，也就是说在 getSnapshotBeforeUpdate 中读取到的 DOM 元素状态是可以保证与 componentDidUpdate 中一致的。
    此生命周期返回的任何值都将作为参数传递给componentDidUpdate（）

# 48.react hooks

**组件的创建方式：**

用过react的都了解，传统react创建组件提供了两种方式，函数式与类（class）

**1.useState**

作用：添加状态管理

**2.useEffect**

作用：周期函数

useEffect涉及三个周期函数 componentDidMount 、componentDidUpdate、 compinentWillUmount 

我们可以看一下执行周期

useEffect接受两个参数：

- 第一个参数是函数（这里叫effect函数），它的作用是，在页面渲染后执行这个函数。因此你可以把ajax请求等放在这里执行；
- 第二个参数是一个数组，这里注意：

| 参数情况  |                             效果                             |                             注意                             |
| :-------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   不传    |              每次渲染后都执行清理或者执行effect              |       这可能会导致性能问题，比如两次渲染的数据完全一样       |
| 传空数组  |       只运行一次的 effect（仅在组件挂载和卸载时执行）        | 这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行 |
| 传[count] | React 将对前一次渲染的count和后一次渲染的count进行比较。若相等React 会跳过这个 effect， |                       实现了性能的优化                       |

上面例子中之所以造成页面的死循环，是因为在JavaScript中，`{} === {}`结果是false，`{a:1} === {a:1}`同样，由此造成了react以为两个值不同，就一直的渲染最终页面死循环。

**实现useState**

```react
var val;
function useState(initVal) {
  let resultVal = val || initVal;
  function setVal(newVal) {
    resultVal = newVal;
    render();
  }
  return [resultVal, setVal]
}
```

**实现useEffect**

```react
var watchArr = [];
function useEffect(fn, watch) {
  var hasWatchChange = true;
  hasWatchChange = watchArr && watch.every((val, i) => val === watchArr[i])
  if (hasWatchChange) {
    fn();
    watchArr = watch;
  }
}
```

hooks里面最常用的两个API就是useState与useEffect，现在是不是已经了解了呢，下面我们介绍一些其他API

**3.useContext**

作用：越级别获取组件内容

javascript:void(0);)

**Hooks实现方式**

```react
const AppContext = React.createContext('target');

function App() {
  useEffect(
    () => { },
    []
  );
  return <AppContext.Provider value="dark">
    <Target />
  </AppContext.Provider>;
}

function Target() {
  const value = useContext(AppContext);
  console.log(value);
  return <div></div>;
}
```

在需要订阅多个 context 的时候，就更能体现出useContext的优势。

**hooks实现**

```
function App() {
  const user = useContext(CurrentUser);
  const notifications = useContext(Notifications);

  return (
    <header>
      Welcome back, {user.name}!
      You have {notifications.length} notifications.
    </header>
  );
}
```

是不是比传统的要简单的多

**4.useReducer**

作用：复杂状态管理，跟redux本质上是一样的

函数式组件如果涉及到状态管理，我们需要借助redux，那么hooks需要吗，答案也是一样的，简单的状态管理我们可以通过useState来进行管理，如果比较复杂的状态管理呢，react hook给我们提供了方法 useReducer

```react
function init(initialCount) {
  return { count: initialCount };
}

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return init(action.payload);
    default:
      throw new Error();
  }
}

function Counter({ initialCount }) {
  const [state, dispatch] = useReducer(reducer, initialCount, init);
  return (
    <>
      Count: {state.count}
      <button
        onClick={() => dispatch({ type: 'reset', payload: initialCount })}>
        Reset
      </button>
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
    </>
  );
}
```

**5.useCallback**

作用：提升性能，缓存事件，减少没必要的渲染

```react
function App() {
  let [count, setCount] = useState(0);
  return <div>
    <button onClick={() => setCount(1)} ></button>
  </div>
}
```

同样的问题这么写也是存在的，改进如下

```react
function App() {
  let [count, setCount] = useState(0);
  let handleSetCount = useCallback(() => {
    setCount(1);
  })
  return <div>
    <button onClick={handleSetCount} ></button>
  </div>
}
```

我们通过useCallback来缓存这个事件达到优化效果

**6.useMemo**

作用：提升性能，选择性的渲染变化组件

```react
function App(target, target2) {
  const target = useMemo(() => {
    return <Target />
  }, [target])
  const target2 = useMemo(() => {
    return <Target2 />
  }, [target2])
  return <div>
    {target}
    {target2}
  </div>
}
```

当target变化仅渲染Target组件，同理也作用与Target2组件

**React.memo**

作用：提升性能

如果想实现class中的shouldComponentUpdate方法呢 ，区别是它只能比较 props，不会比较 state：

```react
const App = React.mome((target, target2) => {
  const target = useMemo(() => {
    return <Target />
  }, [target])
  const target2 = useMemo(() => {
    return <Target2 />
  }, [target2])
  return <div>
    {target}
    {target2}
  </div>
})
```

**7.useRef**

作用：获取dom依赖关系

```jsx
function App() {
  let [value, setValue] = useState('')
  const inputRef = useRef();

  useEffect(
    () => {
    },
    [inputRef]
  )

  let handleSetValue = function (e) {
    setValue(e.target.value);
  }

  return <React.Fragment>
    <input
      ref={inputRef}
      value={value}
      onChange={handleSetValue}
    ></input>

  </React.Fragment>
}
```

# 49.react组件通信，跨组件通信

- 父组件向子组件通信：使用 props
- 子组件向父组件通信：使用 props 回调
- 非嵌套组件间通信：使用事件订阅、redux（集中式状态管理）
- 跨级组件间通信：使用 context 对象、redux（集中式状态管理）

# 50.setState 是同步还是异步？

![image-20211226150313308](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20211226150313308.png)

我的回答是执行过程代码同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，所以表现出来有时是同步，有时是“异步”。

**1.何时是同步，何时是异步呢？**

只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout/setInterval等原生 API 中都是同步的。简单的可以理解为被 React 控制的函数里面就会表现出“异步”，反之表现为同步。

**2.那为什么会出现异步的情况呢？**

为了做性能优化，将 state 的更新延缓到最后批量合并再去渲染对于应用的性能优化是有极大好处的，如果每次的状态改变都去重新渲染真实 dom，那么它将带来巨大的性能消耗。

**3.那如何在表现出异步的函数里可以准确拿到更新后的 state 呢？**

通过第二个参数 setState(partialState, callback) 中的 callback 拿到更新后的结果。

或者可以通过给 setState 传递函数来表现出同步的情况：

```kotlin
this.setState((state) => {
    return { val: newVal }
})
```

# **51.redux**

![image-20211208093302673](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211208093302673.png)

# **52.跨域**

所谓同源是指"协议+域名+端口"三者相同，不是同源进行资源交换就是跨域

同源策略限制以下几种行为：

```mipsasm
1.) Cookie、LocalStorage 和 IndexDB 无法读取
2.) DOM 和 Js对象无法获得
3.) AJAX 请求不能发送
```

**跨域解决方案**

1、 通过jsonp跨域
2、后端 跨域资源共享（CORS）或 nginx代理跨域
3、 nodejs中间件代理跨域
4、Vue中配置了代理服务器，自带vue.config.js，React使用中间件 http-proxy-middleware插件创建代理服务器

**通过jsonp跨域**

```js
前端代码
<script type='text/javascript'>
后端返回直接执行的方法，相当于执行这个方法，由于后端把返回的数据放在方法的参数里，所以这里能拿到res。
cb = function(res) {
    console.log(res)
}
</script>
<!-- 传入数据是msg，传入一个回调方式cb -->
<script src='http://xxxxx/api/jsonp?msg=helloWorld&cb=cb' type='text/javascript'></script>
```

**多种解决react中跨域问题方案**

一、最简单的操作
在package.json中加入

"proxy": "http://localhost:8000"
然后你页面中的请求fetch('/api/userdata/')就会转发到proxy中的地址

也就是真实的请求是http://0.0.2.89:7300/api/userdata/，而且也不会有跨域问题

因为在浏览器看来，你只是发了fetch('/api/userdata/')，没有跨域问题

二、添加多个代理
在package.json中加入

```js
"proxy": {
   "/api": {
     "target": "http://localhost:8000",
     "changeOrgin": true
   },
    "/app": {
     "target": "http://localhost:8001",
     "changeOrgin": true
   }
},
```

使用方法

axios.post('/api/users').then(res =>{
    console.log(res)
})
但是当重新执行npm start时会报错，说"proxy"的值应该是一个字符串类型，而不能是Object。

其原因是由于react-scripts模块的版本过高，需要删除到原目录下node_modules中的react-scripts文件夹，安装低版本

npm install react-script@1.1.1 --save
的确跨域问题可以解决了，但是又出现了新的问题，我在项目中使用了sass，当把react-scripts改为低版本后并不支持对sass的解析，如果要想支持sass的话，需要到 node_modules/react-scripts/config中进行配置，但是并不推荐你这样做。

三、最佳推荐
下载 http-proxy-middleware

npm i http-proxy-middleware --save
创建 src/setupProxy.js

```js
const proxy = require('http-proxy-middleware')

module.exports = function(app) {
  // /api 表示代理路径
  // target 表示目标服务器的地址
  app.use(
    proxy('/api', {
    // http://localhost:4000/ 地址只是示例，实际地址以项目为准
      target: 'http://localhost:4000',
      // 跨域时一般都设置该值 为 true
      changeOrigin: true,
      // 重写接口路由
      pathRewrite: {
        '^/api': '' // 这样处理后，最终得到的接口路径为： http://localhost:8080/xxx
      }
    })
  )
}
```

# 53.react-thunk原理

react-thunk源码：

```react
function createThunkMiddleware(extraArgument) {
  return ({ dispatch, getState }) => next => action => {
    /**
     *如果action是函数，就调用这个函数，并且传入dispatch和getState及 extraArgument 为参数
     *extraArgument是给返回函数传入的额外参数
     *后面applyMiddleware函数相当于是对dispatch(action)派发到reducer之前进行了拦截
     *拦截过程中就是经过了一系列中间件处理
     *reducer是个纯函数到达reducer的action必须是一个plain object类型
     *所以后面applyMiddleware函数处理完所有中间件之后返回的是一个普通的对象
     *react-thunk就是充分利用了applyMiddleware函数最后会返回普通对象的原理！！！
     *所以react-thunk的作用就只是将函数类型的action传递进了applyMiddleware！仅此而已！！
     *经典到不能再经典的中间件！
    */
    if (typeof action === 'function') {
     // 这里的dispatch是在applyMiddleware中改写过的
      return action(dispatch, getState, extraArgument);
    }
    

    // 如果传过来的是普通对象，直接调用下一个middleware
    return next(action);

  };
}

//向外暴露
const thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;

export default thunk;
```


# 54.BFC

https://blog.csdn.net/sinat_36422236/article/details/88763187

**BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。**

**1.BFC的布局规则**
内部的Box会在垂直方向，一个接一个地放置。

Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。

每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。

BFC的区域不会与float box重叠。

BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。

计算BFC的高度时，浮动元素也参与计算。

**2.如何创建BFC**
1、float的值不是none。
2、position的值不是static或者relative。
3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex
4、overflow的值不是visible

### **3.BFC的作用**

1.利用BFC避免margin重叠。

2.自适应两栏布局(float+overflow

3.清楚浮动。

##### 4.触发BFC的条件

- 根元素或其它包含它的元素
- 浮动元素 (元素的 `float` 不是 `none`)
- 绝对定位元素 (元素具有 `position` 为 `absolute` 或 `fixed`)
- 内联块 (元素具有 `display: inline-block`)
- 表格单元格 (元素具有 `display: table-cell`，HTML表格单元格默认属性)
- 表格标题 (元素具有 `display: table-caption`, HTML表格标题默认属性)
- 具有`overflow` 且值不是 `visible` 的块元素
- 弹性盒（`flex`或`inline-flex`）
- `display: flow-root`
- `column-span: all`

##### 5.BFC的约束规则

- 内部的盒会在垂直方向一个接一个排列（可以看作BFC中有一个的常规流）
- 处于同一个BFC中的元素相互影响，可能会发生外边距重叠
- 每个元素的margin box的左边，与容器块border box的左边相接触(对于从左往右的格式化，否则相反)，即使存在浮动也是如此
- BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素，反之亦然
- 计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算
- 浮动盒区域不叠加到BFC上

##### 5.BFC可以解决的问题

- 垂直外边距重叠问题
- 去除浮动
- 自适用两列布局（`float` + `overflow`）





# **55.sessionStorage、localStorage和cookie的区别** 

https://www.cnblogs.com/jing-tian/p/10991431.html

共同点：都是保存在浏览器端、且同源的 
区别： 
1、cookie数据始终在同源的http请求中携带（即使不需要），<u>**即cookie在浏览器和服务器间来回传递**</u>，而sessionStorage和localStorage**<u>不会自动把数据发送给服务器，仅在本地保存</u>**。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下 
2、**<u>存储大小</u>**限制也不同，cookie数据不能超过4K，同时因为**<u>每次http请求都会携带cookie</u>**、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大 
3、**<u>数据存储有效期不同</u>**，sessionStorage：仅在当前**浏览器窗口关闭之前有效**；localStorage：**始终有效**，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的**cookie过期时间之前有效**，即使窗口关闭或浏览器关闭 
4、**<u>作用域不同</u>**，sessionStorage不在  不同的浏览器窗口中共享，即使是同一个页面；localstorage在<u>所有同源窗口中都是共享</u>的；cookie也是在所有同源窗口中都是共享的 
5、web Storage（sessionStorage、localStorage）支持事件通知机制，可以将数据更新的通知发送给监听者 
6、web Storage（sessionStorage、localStorage）的<u>**api接口使用更方便**</u>



**web Storage和Cookie的区别** 
Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的，cookie的大小是受限的，并且每次请求一个新的页面的时候cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可跨域调用。 
除此之外，web storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。 
但是cookie也是不可或缺的，cookie的作用是与服务器进行交互，作为http规范的一部分而存在的，而web Storage仅仅是为了在本地“存储”数据而生 
sessionStorage、localStorage、cookie都是在浏览器端存储的数据，其中sessionStorage的概念很特别，引入了一个“浏览器窗口”的概念，sessionStorage是在同源的同窗口中，始终存在的数据，也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一个页面，数据仍然存在，关闭窗口后，sessionStorage就会被销毁，同时“独立”打开的不同窗口，即使是同一页面，sessionStorage对象也是不同的

Web Storage带来的好处： 
1、<u>减少网络流量</u>：一旦数据保存在本地之后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数

据在浏览器和服务器间不必要的来回传递 
2、<u>快速显示数据</u>：性能好，从本地读数据比通过网络从服务器上获得数据快得多，本地数据可以及时获得，再加上网

页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示 
3、<u>临时存储</u>：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage非常方便

# 56.xss和csrf区别

1.CSRF的基本概念、缩写、全称

CSRF（Cross-site request forgery）：跨站请求伪造。

PS：中文名一定要记住。英文全称，如果记不住也拉倒。

2.CSRF的攻击原理

![img](https://img2018.cnblogs.com/blog/941968/201904/941968-20190422203527996-279231194.jpg)

用户是网站A的注册用户，且登录进去，于是网站A就给用户下发cookie。

从上图可以看出，要完成一次CSRF攻击，受害者必须满足两个必要的条件：

（1）登录受信任网站A，并在本地生成Cookie。（如果用户没有登录网站A，那么网站B在诱导的时候，请求网站A的api接口时，会提示你登录）

（2）在不登出A的情况下，访问危险网站B（其实是利用了网站A的漏洞）。

我们在讲CSRF时，一定要把上面的两点说清楚。

温馨提示一下，cookie保证了用户可以处于登录状态，但网站B其实拿不到 cookie。

3、CSRF如何防御

方法一、Token 验证：（用的最多）

（1）服务器发送给客户端一个token；

（2）客户端提交的表单中带着这个token。

（3）如果这个 token 不合法，那么服务器拒绝这个请求。

方法二：隐藏令牌：

把 token 隐藏在 http 的 head头中。

方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。

方法三、Referer 验证：

Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。

XSS

1、XSS的基本概念

XSS（Cross Site Scripting）：跨域脚本攻击。

XSS的攻击原理

XSS攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）。

最后导致的结果可能是：

盗用Cookie破坏页面的正常结构，插入广告等恶意内容D-doss攻击

XSS的攻击方式

1、反射型

发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。

2、存储型存

储型XSS和反射型XSS的差别在于，提交的代码会存储在服务器端（数据库、内存、文件系统等），下次请求时目标页面时不用再提交XSS代码。

XSS的防范措施（encode + 过滤）

XSS的防范措施主要有三个：

1、编码：

对用户输入的数据进行

HTML Entity 编码。

如上图所示，把字符转换成 转义字符。

Encode的作用是将

$var

等一些字符进行转化，使得浏览器在最终输出结果上是一样的。

比如说这段代码：

<script>alert(1)</script>

若不进行任何处理，则浏览器会执行alert的js操作，实现XSS注入。

进行编码处理之后，L在浏览器中的显示结果就是

<script>alert(1)</script>

，实现了将$var作为纯文本进行输出，且不引起JavaScript的执行。

2、过滤：

移除用户输入的和事件相关的属性。如onerror可以自动触发攻击，还有onclick等。（总而言是，过滤掉一些不安全的内容）移除用户输入的Style节点、Script节点、Iframe节点。（尤其是Script节点，它可是支持跨域的呀，一定要移除）。

3、校正

避免直接对HTML Entity进行解码。使用DOM Parse转换，校正不配对的DOM标签。备注：我们应该去了解一下

DOM Parse

这个概念，它的作用是把文本解析成DOM结构。

比较常用的做法是，通过第一步的编码转成文本，然后第三步转成DOM对象，然后经过第二步的过滤。

还有一种简洁的答案：

首先是encode，如果是富文本，就白名单。

CSRF 和 XSS 的区别

区别一：

CSRF：需要用户先登录网站A，获取 cookie。XSS：不需要登录。

区别二：（原理的区别）

CSRF：是利用网站A本身的漏洞，去请求网站A的api。XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。



# 57.图片懒加载

###### 

![image-20211228100935039](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20211228100935039.png)

![image-20211228150323207](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20211228150323207.png)

# 58.TS 相比js的优点

<img src="C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20211228145531121.png" alt="image-20211228145531121" style="zoom:150%;" />