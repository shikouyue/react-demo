 

# 与知识点无关部分

## 你前端是怎么学的?

一开始学习前端，主要靠视频以及书籍，主要是总结很多知识点，但是发现学习过程中理论大于实操，所以自己把知识点总结后就开始找项目实操，这样一步一步成长起来的，那么在公司中也会碰到很多问题值得学习，一般都是自己查找原因或者和同事交流进行解决，然后自己总结出文档，方便日后查看和积攒经验。所以我感觉我的学习都是实操加总结}

## 你还有什么想问的吗?

入职的部门现状

人员配置、开发的项目

使用的技术栈

公司发展现状

##  说一下你是如何与后端进行数据交互的?

答：我和后端通过ajax来进行数据交互的，通过统一制定的接口文档，来实现前后端高效开发，如果接口文档不能详细说明，或者接口文档上的参数请求不出数据，我会主动和后端工程师沟通，直到完成跟接口相关的业务开发。当然这其中为了验证一些接口问题，会用到一些辅助工具，比方说，runapi这种在线测试工具



##  如果后端数据接口没有准备好，你是如何工作的

如果后端接口还没有准备好，我会和后端沟通，通过制定接口返回数据的格式，然后前端通过一些mock数据的工具（上家公司使用的是easymock,贼简单）来批量生成假数据，可以让前端和后端同时开发，而无需等待后端数据接口写好再开发，这样提升项目整体的开发效率



## 平时怎么学习新技术的？ 

答：上官网看文档，上github上找相关开源项目练手，上技术社区博客园，csdn,51cto,掘金，简书参加技术问题讨论，上知乎，通过专业书籍（例如：高程三，javascript权威指南即犀牛书）系统学习，加入相关技术群参考讨论

## 未来的职业规划是什么？

答：2年内先做好技术，小有所成后，其他机会也就慢慢来了



## 离职原因

1. 公司资金链断裂.两个月发不出工资.领导让我出来找工作的


2. 行业整体不怎么景气.公司这边.浮动工资(绩效工资)占比增大.


3. 公司这边需要长期外派出差,我个人的一些朋友人脉都在北京这边,所以不想出去.


4. 公司项目完成了.剩下的都是一些维护的工作.公司新招了两个大学生.我带了他们查不多两个月,

## 拿到一个需求后你会做什么?

**项目分哪几个阶段：**

通常一个项目简单分为 四步：

- 需求阶段
  • 收集需求 • 分析需求 • 产出需求 • 需求文档 • 评审需求 • 分配资源 • 技术调研 • 评估工作量 • 制定排期

  产品经理明确需求并协调好各方人力之后，一般会发起需求评审，将开发、测试等相关人员聚集在一起，阐述需求具体内容并接受反馈和建议。
  **需求评审主要意义在于：**

  - 明确需求，确保各方理解一致。避免实现过程与预期效果背道而驰。
  - 风险评估，问题及早暴露。若产品经理预期方案中存在较大的技术问题，技术人员可在评审时予以指出，从而及早思考对策。
  - 交流碰撞，方案权衡。技术人员反馈各内容实现难度和实现成本，PM权衡哪些内容优先实现，哪些内容采用替代方案，哪些内容予以舍弃。

  **需求评审环节咱们前端应做的事：**

  阅读、梳理需求文档。产品一般会先发需求文档，后进行需求评审。评审前应先阅读好文档，并梳理其中的疑惑点和技术难点。
  明确需求。评审过程应充分理解自己所需要完成的内容，不清晰之处应向产品经理确认、明确。
  沟通反馈。有潜在的技术问题/风险，应及时向PM反馈，使其提前思考应对/替代方案。
  理解目的。理解产品经理此次需求的主要目的，明白需求中哪些内容应重点保证，哪些内容可以适当取舍，避免在某些棘手却无关紧要的小功能上面浪费过多精力。
  注意：
  需求评审主要目的在于需求，具体实现细节应在会后相关人员自行沟通，避免耽误其他人时间

- 开发阶段
  • 接口评审 • 测试用例评审 • Coding • 自测 • 联调 • 提测

  **开发阶段前端拿到一个需求后该做什么?**

  理清需求中：
  依赖哪些外部资源，如：需要后端提供哪些接口、需要产品经理提供哪些数据（埋点、分享文案、分享图片...）、ui图中哪些需要切图，如何布局，哪部会后期可能频繁改动，等等。

  需要实现哪些效果，如：下拉刷新、无限加载、tab吸顶、动画特效等
  有哪些交互，如：按钮点击响应、下拉响应等
  有哪些模块，如：Banner模块、分类入口模块、商品列表模块等

- 测试阶段
  • 冒烟测试 • 功能测试 • 兼容性测试 • 性能测试 • 回归测试

- 上线阶段
  • 总结

1.为什么要做这个功能，

2.初步该怎样实现，

3.如果后期有变化，怎么好扩展，如果后期其他地方要用到这个模块，能不能直接移植

4.后端讨论接口

5.大概就这些吧，现在前端都走框架了，都是组件化，模块化的思想，所以，做一个地方的时候尽量会向着高内聚低耦合的方向走，这样才能实现后期的复用以及缩小需求变更带来的修改和维护成本。



**分析需求**：评估需求完成时间，具体到每个需求花的时间、测试、上线，如果和需求方定的时间节点不对，那么就要和需求方协商砍需求或者要求时间节点更改，或者加班赶需求...

**需求意义：**这个需求的意义是啥...做来到底有啥用

**技术调研**：有哪些需求是没有用技术实现过的，因此需要留一点缓冲时间进行调研。

**技术沉淀**：经过这个项目，会有哪些技术点或者技术方案可以沉淀下来。



## 项目中碰到过哪些问题?是怎么解决的?

1.div不对齐的问题

一个father父容器里有4个子容器,每个子容器里面都有三段话,是用br来换行的,然后我放第5个子盒子的时候我只放了一句话,然后第5个盒子就掉下去了 ,跟其他四个子盒子不在一条水平线上,按理说每个子元素都设置了display:inlineblock是不会掉下去的,应该在一行显示的,当时调式了蛮久也没弄出来,百度也没有结果,最后是自己把这些子盒子的背景颜色去掉之后发现了端倪,就是这些文字都是底部对齐的,然后就上MDN查了一个,找到了一个vertical-align的属性, 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式,它的默认值是baseline,baseline是什么意思呢,MDN上写的是使元素的基线与父元素的基线对齐,才会导致第5个盒子往下掉,所以解决这个问题就是把这个属性值改成top,就不会出现盒子往下掉的情况

![64052407827](C:\Users\86187\AppData\Local\Temp\1640524078276.png)

![64052409192](C:\Users\86187\AppData\Local\Temp\1640524091925.png)

权限由每个员工都有的公共权限和私有权限
权限管理可以分配每个角色可以操作的权限
登录时根据分配给这个员工的角色去返回一个动态路由，
拿动态路由通过filter去总得动态路由数组中筛选出来，得到动态路由，和静态路由合并返回该员工该有的路由并渲染到左侧菜单栏

# html部分

## h5有哪些新特性 h5新标签的浏览器兼容问题如何处理?

![img](https://cdn.nlark.com/yuque/0/2021/png/22330294/1639448457928-c7b0ff78-7b17-4026-9a03-a53c3d951e06.png)

![img](https://cdn.nlark.com/yuque/0/2021/png/22330294/1639448477077-3911446c-2a27-404e-a166-e97ec972a5bb.png)

## 简述一下你对HTML语义化的理解?

1.提升可访问性 2.seo 3.结构清晰，利于维护

![img](https://cdn.nlark.com/yuque/0/2021/png/22330294/1639448632192-b2b17288-5ca5-4927-a8d3-830c0b4ae812.png)

## Doctype作用?

目的是告知浏览器的解析器，用什么文档类型规范来解析这个文档。

Doctype声明也是用于区分html和html5的方法之一。

# CSS部分

## 三栏布局方式两边固定中间自适应

1. margin负值法：左右两栏均左浮动，左右两栏采用负的margin值。中间栏被宽度为100%的浮动元素包起来

2. 自身浮动法：左栏左浮动，右栏右浮动，中间栏放最后

3. 绝对定位法：左右两栏采用绝对定位，分别固定于页面的左右两侧，中间的主体栏用左右margin值撑开距离。

   4.flex  左右固定宽  中间flex：1

## 行内元素/块级元素有哪些？

行内元素：相邻的行内元素会排列在同一行，不会独占一行 设置宽高无效 span

块级元素：会独占一行 可以设置宽高等属性div

块级元素：div h1-h6 hr p ul ol table address blockquote dir from menu

行内元素：a br I em img input select span sub sup u textarea

## CSS选择器的优先级是怎么样的？

- 内联样式 > ID选择器> 类选择器>标签选择器

- 优先级（权重）：

  元素选择器1

  伪元素选择器1

  class选择器10

  伪类选择器10

  属性选择器10

  Id选择器100

  内联样式的权重1000

## 谈谈你对 BFC 的理解？

BFC就是页面上一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。

1. 了解BFC ： 块级格式化上下文。
2. BFC的原则：如果一个元素具有BFC，那么内部元素再怎么弄，都不会影响到外面的元素。
3. 如何触发BFC：
           float的值非none
      	overflow的值非visible
      	display的值为：inline-block、table-cell...
      	position的值为:absoute、fixed

- 解决的问题
  - 1、防止两个相邻块级元素的上下 margin 发生重叠 (上下margin合并问题)
  - 2、清除浮动
    - 通过给父盒子设置BFC，防止父盒子高度塌陷
  - 3、实现自适应布局
    - 防止元素被浮动元素覆盖(左边固定, 右边自适应)

## css3的新特性有哪些?

答：css3比css2多了好多针对移动端的特性，比如：圆角：border-radius,盒阴影：box-shadow,还有动画：transition(过渡),transform（实现位移，倾斜，旋转，绽放）,animation（关键帧动画）等>

## 如何实现左右垂直居中

1. 子元素相对于父元素绝对定位，子元素top，left设置50%，子元素margin-top和margin-left减去各自宽高的一半
2. 子元素相对于父元素绝对定位，子元素上下左右全为0，然后设置子元素margin：auto
3. 子元素相对父元素绝对定位，子元素top，left值为50%，transform：translate（-50%，-50%）
4. 父元素设置弹性盒子，
   display：flex； justfy-content：center ；align-item：center； justfy-content：center

实现居中效果的方法：
**1、absolute + 负margin**

```css
father{
           position: relative;//父元素设置绝对定位
       }
       .son{
           position: absolute;
           width:100px;
     		height:100px;
           top: 50%;
           left: 50%;
           margin-left: -50px;
           margin-top: -50px;
       }
```

**2、absolute + margin auto**

```css
.father{
          position: relative;//父元素设置绝对定位
      }
      .son{
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          margin: auto;
      }
```

**3、absolute + transform**

```css
.father{
          position: relative;//父元素设置绝对定位
      }
      .son{
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%,-50%);
      }
```

4.flex布局

```css
.father{
        display: flex;
        justify-content: center; /*显示在主轴的中间*/
        align-items: center; /*子项在侧轴中间位置*/
    }
```

## 伪类和伪元素区别

- `CSS` 伪类用于向某些选择器添加特殊的效果。
- `CSS` 伪元素用于将特殊的效果添加到某些选择器。

**伪类种类**

![请输入图片描述](http://segmentfault.com/img/bVcccn)

**伪元素种类**

![请输入图片描述](http://segmentfault.com/img/bVccco)

## px、em、rem之间有什么区别？

- px:绝对单位。代表像素数量，页面会按照给出的精确像素进行展示
- em:相对单位。默认的基准点为父元素的字体大小，而如果自身定义了字体大小则按自身的来算。所以即使在同一个页面内，1em可能不是一个固定的值。
- rem: 相对单位。可以理解为 root em，即基准点为根元素<html>的字体大小。rem是CSS3中新增单位，Chrome/FireFox/IE9+都支持, 一般用于做移动端适配
- rem布局的原理
  - 1.使用 rem 为单位
  - 2.动态的设置 html font-size (媒体查询, js设置, 插件设置都可以)

## z-index有什么用？

z-index 属性设置元素的堆叠顺序。拥有更高堆叠顺序的元素总是会处于堆叠顺序较低的元素的前面。

Z-index 仅能在定位元素上奏效（例如 position:absolute;）！

## 什么是浮动?

浮动使元素脱离文档普通流，漂浮在普通流之上的。浮动元素依然按照其在普通流的位置上出现，然后尽可能的根据设置的浮动方向向左或者向右浮动，直到浮动元素的外边缘遇到包含框或者另一个浮动元素为止

float 属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。

## 清除浮动的方法?

![63963655477](C:\Users\86187\AppData\Local\Temp\1639636554776.png)

- 1.定高法
- 2.使用一个空的div，并设置样式
-  3.定义一个 clearfix 样式类
  - ![](C:\Users\86187\Desktop\assets\6E75522F-C43A-4F66-8C40-06175C9D92D0.png)
- 4.为父元素添加 overflow: hidden
  - BFC
- 注意点：当前 flex 已成为主流布局方式，适应性强, 且稳定, 所以浮动使用率目前已逐步降低。

## 移动端适配

目前对于移动端适配的内容布局效果是这样的：

- **百分比布局（流式布局）**，所有需要动态调整的元素宽高采用百分比，字号固定像素。

- **rem**，通过计算或者JavaScript获取到设备像素/CSS像素的比例，确定根元素的字体像素，然后所有单位根据根元素字体像素进行rem设置，确定大小。而基础rem会根据设备变化而变化。

- **vw和vh:**vw和vh分别相对于屏幕宽度和屏幕高度的，1vw相当于屏幕宽度的1%,100vw相当于满屏宽度100%,

  vh和vw类似，只不过是相对于屏幕高度的，1vh相当于屏幕高度的1%,100vh相当于满屏高度的100%,

- **Media Query(媒体查询)**：查询设备的宽度来执行不同的 css 代码，完成适配最小和最大边界值设定

  ​	  优点：统一对pc和移动进行调试，调整屏幕宽度 不需要刷新页面，是响应式的

  ​	  缺点：代码量大，不利于维护， 可能造成设备资源的浪费

  ![63996447941](C:\Users\86187\AppData\Local\Temp\1639964479412.png)

目前我在项目中用的多的是rem，flex布局，有时会用到媒体查询，在做pc响应式布局时用

主要是用了一个手淘的js库[flexible.js](http://caibaojian.com/t/flexible-js),在页面变化时,检测页面宽度,除以10份,动态的赋值给font-size.属性.;而页面的布局我是通过rem来进行布局的,所以就可以适配所有的移动端设备了



**在css中单位长度用的最多的是px、em、rem，这三个的区别是**：

　　px是固定的像素，一旦设置了就无法因为适应页面大小而改变。

　　em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。

对于em和rem的区别一句话概括：**em相对于父元素，rem相对于根元素。**



### flex布局（弹性布局）

**一、Flex 布局是什么？**

```bash
Flex 是 Flexible Box 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。
flex 是 flex-grow、flex-shrink、flex-basis的缩写
任何一个容器都可以指定为 Flex 布局。
行内元素也可以使用 Flex 布局。
Webkit 内核的浏览器，必须加上-webkit前缀。
注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。
```

**2、Flex的属性**

![64007718466](C:\Users\86187\AppData\Local\Temp\1640077184661.png)

![64007722819](C:\Users\86187\AppData\Local\Temp\1640077228191.png)

**以下6个属性设置在容器上**。

```js
1.flex-direction  //属性决定主轴的方向
2.flex-wrap       //换行 
3.flex-flow       //（flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row 						nowrap。）
4.justify-content  //定义了项目在主轴上(即横向)的对齐方式。
5.align-items      //定义项目在交叉轴上(即纵向,垂直)如何对齐。
6.align-content    //定义了侧轴多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用
```

**1.flex-direction属性**

```css
flex-direction属性决定主轴的方向（即项目的排列方向）。
.box {
    flex-direction: row | row-reverse | column | column-reverse;
}
row（默认值）：主轴为水平方向，起点在左端。
row-reverse：主轴为水平方向，起点在右端。
column：主轴为垂直方向，起点在上沿,自上而下。
column-reverse：主轴为垂直方向，起点在下沿,自下而上。
```

**2.flex-wrap属性**

```css
默认情况下，项目都排在一条线（又称"轴线"）上。flex-wrap属性定义，如果一条轴线排不下，应该如何换行。
.box{
  flex-wrap: nowrap | wrap | wrap-reverse;
}
 nowrap（默认）：不换行,宽度自动压缩。
 wrap：换行，第一行在上方。
 wrap-reverse：换行，第一行在下方。
```

**3.flex-flow**

```css
 flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。
.box {
  flex-flow: <flex-direction> || <flex-wrap>;
}
.box{
  flex-flow:row||nowrap;
}
```

**4.justify-content属性**

```ruby
justify-content属性定义了项目在主轴上(即横向)的对齐方式。

flex-start（默认值）：左对齐
flex-end：右对齐
center： 居中
space-between：两端对齐，组件之间的间隔都相等。
space-around：距边界两侧的间隔相等，元素之间的间隔比项目与边框的间隔大一倍。
```

**5.align-items属性**

```css
align-items属性定义项目在交叉轴上(即纵向,垂直)如何对齐。
.box {
  align-items: flex-start | flex-end | center | baseline | stretch;
}
flex-start：交叉轴的起点(顶部)对齐。
flex-end：交叉轴的终点(底部)对齐。
center：交叉轴的中点(中间)对齐。
baseline: 项目的第一行文字的基线(即根据内容对齐,不再根据容器)对齐。
stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
```

**6.align-content属性(说的是垂直方向的交叉轴)**

```css
align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
.box {
  align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}
flex-start：与交叉轴的起点对齐。
flex-end：与交叉轴的终点对齐。
center：与交叉轴的中点对齐。
space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
stretch（默认值）：轴线占满整个交叉轴
```

### flex布局碰到的问题

**1.flex布局会导致文本省略失效**

![64005915450](C:\Users\86187\AppData\Local\Temp\1640059154500.png)

比如上面这段代码在浏览器会显示成，因为受flex布局的影响，导致省略号显示失败

![64005946988](C:\Users\86187\AppData\Local\Temp\1640059469881.png)

但是有时候你又想使用flex布局怎么办？很简单在套一层标签就好了

![64005921873](C:\Users\86187\AppData\Local\Temp\1640059218739.png)
这样也是能正常显示的

2. **flex布局会让子元素拉伸**

   ![64005932379](C:\Users\86187\AppData\Local\Temp\1640059323792.png)

   ![64005933871](C:\Users\86187\AppData\Local\Temp\1640059338715.png)

这是由于align-items属性造成的，它的默认值是normal，normal在大多数情况下和stretch是一样的，会造成子元素在垂直方向被拉伸，把align-items的值设置成flex-start就可以了



二、项目的属性**

**以下6个属性设置在项目上。**

```js
1.order				//属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
2.flex-grow			//属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
3.flex-shrink		//flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
4.flex-basis		//flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。
5.flex				//flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 						auto。后两个属性可选。
6.align-self		//align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属						性。
```

**1.order属性**

```css
order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。
.item {
  order: <integer>;
}
```

**2.flex-grow属性**

```css
flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
.item {
  flex-grow: <number>; /* default 0 */
}
如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。
如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。
```

**3.flex-shrink属性**

```css
flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
.item {
  flex-shrink: <number>; /* default 1 */
}
如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。
如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。
注:负值对该属性无效。
```

**4.flex-basis属性**

```css
flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。
浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。
.item {
    flex-basis: <length> | auto; /* default auto */
}
它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。
```

### **5.flex属性是哪三个属性的缩写**

```css
flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。
.item {
  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
}
该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。
建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。
```

**6.align-self属性**

```css
align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。
默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。
.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
```

flex默认：0  1   auto

flex：1等于 flex：1    1    0

## 移动端兼容问题

面试官问到：在项目有有哪些移动端兼容问题

可以这样回答：哦～兼容问题有很多，可能我一时半会也想不到那么多，我就说一下，我能想起来的吧

**1.html5标签在低版本浏览器如何兼容？**

 使用：html5shiv.js

代码：body之后,布局之前加入

​	

​		<!-- [if lt ie 9]>

​		<script src="shiv.js"></script>

​		<![endif]-->

**2.移动端touch事件有穿透（点透）的问题，怎么解决？**

**touch事件**
1.touchstart----> touchmove----> touchend
touchstart :触摸(点击 按下)开始执行，在touchmove之前执行
touchmove:触摸移动的时候执行 , 在touchend之前执行
touchend:触摸结束的时候执行，在touchmove之后执行,在click事件之前执行

**什么是点击穿透**
点击穿透:设置B盒子在A盒子的上方,给B盒子绑定touchstart事件,给A盒子设置click事件.点击B盒子触发touchstart事件(使B盒子,overflow:hidden),同时也会触发A盒子的click事件.这个就是点击穿透.(主要是click事件不是立马 执行，而是有300ms的延迟)点击穿透的解决办法

**解决办法(直接都用touchstart,最简单!!!):**

```
//给下面的A盒子同样设置一个touchstart事件
a.ontouchstart = function() {
            console.log("点击了A")
  }

```

**3.input 的placeholder会出现文本位置偏上的情况**

​		input 的placeholder会出现文本位置偏上的情况：PC端设置line-height等于height能够对齐，而移动端仍然是偏上，解决是设置line-height：normal

**在移动端中，如果给元素设置一个1px的像素边框的话，那么在手机上看起来是会比一个像素粗的。**

解决方法:使用伪类元素模拟边框使用transform缩放。

![64022629510](C:\Users\86187\AppData\Local\Temp\1640226295100.png)

## 说下你对盒模型的理解?

答：盒模型其实就是浏览器把一个个标签都看一个个的盒子，那每个盒子（即标签）都会有内容(width,height)，边框(border)，以及内容和边框中间的缝隙（即内间距padding），还有盒子与盒子之间的外间距（即margin）,

![https://bkimg.cdn.bcebos.com/pic/a9d3fd1f4134970a37cf81a69fcad1c8a6865dfe?x-bce-process=image/resize,m_lfit,w_268,limit_1/format,f_jpg](https://img-blog.csdnimg.cn/img_convert/f11de33b13140acd86e4cb13dcbbb7d8.png)

答:一个css盒子从外到内可以分成四个部分：margin（外边距），border（边框），padding（内边距），content（内容）

默认情况下，盒子的width和height属性只是设置content（内容）的宽和高

盒子真正的宽应该是：内容宽度+左右填充+左右边距+左右边框

盒子真正的高应该是：内容高度+上下填充+上下边距+上下边框

## 标准盒模型和怪异盒模型有哪些区别？

Content-box 标准盒模型 width不包括padding和border

 Border-box 怪异盒模型width包括padding和border

- 区别：两者的区别主要体现在元素尺寸的表示上。
- content-box 标准盒模型
  - Width = 不包含padding的实际的宽
- border-box 怪异盒模型
  - width = width + padding + border


## css中的定位方式

Position有四个属性值：relative absolute fixed static

Relative相对定位 不脱离文档流，相对于自身定位

Absolute 绝对定位，脱离文档流 相对于父级定位

Fixed 固定定位，脱离文档流，相对于浏览器窗口定位

Static 默认值，元素出现在正常的流中

- static
  - 正常文档流定位
    - 此时设置 top、right、bottom、left 以及 z-index 都无效
    - 如何定位：块级元素遵循从上往下纵向排列，行级元素遵循从左到右排列
- relative
  - 相对定位
    - 这个 相对”是指相对于正常文档流的位置。
- absolute
  - 绝对定位
    - 当前元素相对于最近的非 static 定位的祖先元素来确定自己的偏移位置
- fixed
  - 固定定位
    - 当前元素相对于屏幕视口 viewport 来确定自己的位置。并且当屏幕滚动时，当前元素的位置也不会发生改变
- sticky
  - 粘性定位
    - 这个定位方式有点像 relative 和 fixed 的结合。当它的父元素在视口区域、并进入 top 值给定的范围内时，当前元素就以 fixed 的方式进行定位，否则就以 relative 的方式进行定位



# js部分

## 数组方法

push() 从后面添加元素，返回值为添加完后的数组的长度

arr.pop() 从后面删除元素，只能是一个，返回值是删除的元素

arr.shift() 从前面删除元素，只能删除一个 返回值是删除的元素

arr.unshift() 从前面添加元素, 返回值是添加完后的数组的长度

 arr.splice(i,n) 删除从i(索引值)开始之后的那个元素。返回值是删除的元素

arr.concat() 连接两个数组 返回值为连接后的新数组

str.split() 将字符串转化为数组

 arr.sort() 将数组进行排序,返回值是排好的数组，默认是按照最左边的数字进行排序，不是按照数字大小排序的

arr.reverse() 将数组反转,返回值是反转后的数组

 arr.slice(start,end) 切去索引值start到索引值end的数组，不包含end索引的值，返回值是切出来的数组

 arr.forEach(callback) 遍历数组,无return  即使有return，也不会返回任何值，并且会影响原来的数组

 arr.map(callback) 映射数组(遍历数组),有return 返回一个新数组 。

 arr.filter(callback) 过滤数组，返回一个满足要求的数组 

![64007276739](C:\Users\86187\AppData\Local\Temp\1640072767399.png)

**影响原数组：**sort(callback)、reverse()、push、pop、unshift、shift、splice、delete、fill、copyWithin

**不影响原数组:** filter、map、some、every、forEach、for…in、for…of、reduce&reduceRight、find、finIndexOf、indexOf、lastIndexOf、flat、includes、from、slice、join、concat。

**纯函数**

纯函数有两个特点：1. 不改变原数组（没有副作用）；2. 返回一个数组

除了上面提到的 `forEach`, `every`, `some`, `filter` 属于非纯函数外，我们常用的 `push`, `pop`, `shift`, `unshift` 、splice方法也属于非纯函数

- join()
- push()和pop()
- shift() 和 unshift()
- sort()
- reverse()
- concat()
- slice()
- splice()
- indexOf()和 lastIndexOf() （ES5新增）
- forEach() （ES5新增）
- map() （ES5新增）
- filter() （ES5新增）
- every() （ES5新增）
- some() （ES5新增）
- reduce()
- flat()

### **1.join()**

join，就是把数组转换成字符串，然后给他规定个连接字符，默认的是逗号( ，)

　　书写格式：join(" ")，括号里面写字符串 ("要加引号"),

```js
var arr = [1,2,3];
console.log(arr.join()); 　　　　// 1,2,3
console.log(arr.join("-")); 　　// 1-2-3
console.log(arr); 　　　　　　　　// [1, 2, 3]（原数组不变）
```

### **2.push()和pop()**

push(): 把里面的内容添加到数组末尾，并返回修改后的长度。

pop()：移除数组最后一项，返回移除的那个值，减少数组的length。

​		书写格式：arr.push(" ")，括号里面写内容 ("字符串要加引号"),

​		书写格式：arr.pop( )

```js
var arr = ["Lily","lucy","Tom"];
var count = arr.push("Jack","Sean");
console.log(count); 　　　　　　　　　　// 5
console.log(arr); 　　　　　　　　　　　// ["Lily", "lucy", "Tom", "Jack", "Sean"]
var item = arr.pop();
console.log(item); 　　　　　　　　　　 // Sean
console.log(arr); 　　　　　　　　　　  // ["Lily", "lucy", "Tom", "Jack"]
```

### **3.shift() 和 unshift()**  

(和上面的push，pop相反，针对第一项内容)

shift()：删除原数组第一项，并返回删除元素的值；如果数组为空则返回undefined 。

unshift:将参数添加到原数组开头，并返回数组的长度 。

​		书写格式：arr.shift(" ")，括号里面写内容 ("字符串要加引号"),

```js
var arr = ["Lily","lucy","Tom"];
var count = arr.unshift("Jack","Sean");
console.log(count); 　　　　　　　　　　　　　　// 5
console.log(arr); 　　　　　　　　　　　　　　　//["Jack", "Sean", "Lily", "lucy", "Tom"]
var item = arr.shift();
console.log(item); 　　　　　　　　　　　　　　// Jack
console.log(arr); 　　　　　　　　　　　　　　 // ["Sean", "Lily", "lucy", "Tom"]
```

### **4.sort()**

sort()：将数组里的项从小到大排序

​		书写格式：arr.sort( )

```js
var arr1 = ["a", "d", "c", "b"];
console.log(arr1.sort()); 　　　　　　　　　　// ["a", "b", "c", "d"]
```

sort()方法比较的是字符串，没有按照数值的大小对数字进行排序，要实现这一点，就必须使用一个排序函数



```js
function sortNumber(a,b)
{
　　return a - b
}
```



```js
arr = [13, 24, 51, 3]; console.log(arr.sort()); 　　　　　　　　　　// [13, 24, 3, 51] 
console.log(arr.sort(sortNumber)); 　　　　// [3, 13, 24, 51](数组被改变)
```

### **5.reverse()**

reverse()：反转数组项的顺序。

　　　  书写格式：arr.reverse( )

```js
var arr = [13, 24, 51, 3];
console.log(arr.reverse()); 　　　　　　　　//[3, 51, 24, 13]
console.log(arr); 　　　　　　　　　　　　　　//[3, 51, 24, 13](原数组改变)
```

### **6.concat()**

concat() ：将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本。

　　　　书写格式：arr.concat()，括号里面写内容 ("字符串要加引号"),



```js
var arr = [1,3,5,7];
var arrCopy = arr.concat(9,[11,13]);
console.log(arrCopy); 　　　　　　　　　　　　//[1, 3, 5, 7, 9, 11, 13]
console.log(arr); 　　　　　　　　　　　　　　// [1, 3, 5, 7](原数组未被修改)
```

### **7.slice()**

slice()：返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项。

　　　　书写格式：arr.slice( 1 , 3 )

```js
var arr = [1,3,5,7,9,11];
var arrCopy = arr.slice(1);
var arrCopy2 = arr.slice(1,4);
var arrCopy3 = arr.slice(1,-2);
var arrCopy4 = arr.slice(-4,-1);
console.log(arr); 　　　　　　　　　　　　　　//[1, 3, 5, 7, 9, 11](原数组没变)
console.log(arrCopy); 　　　　　　　　　　　 //[3, 5, 7, 9, 11]
console.log(arrCopy2); 　　　　　　　　　　　//[3, 5, 7]
console.log(arrCopy3); 　　　　　　　　　　　//[3, 5, 7]
console.log(arrCopy4); 　　　　　　　　　　　//[5, 7, 9]
```

　　arrCopy只设置了一个参数，也就是起始下标为1，所以返回的数组为下标1（包括下标1）开始到数组最后。 

　　arrCopy2设置了两个参数，返回起始下标（包括1）开始到终止下标（不包括4）的子数组。 

　　arrCopy3设置了两个参数，终止下标为负数，当出现负数时，将负数加上数组长度的值（6）来替换该位置的数，因此就是从1开始到4（不包括）的子数组。 

　　arrCopy4中两个参数都是负数，所以都加上数组长度6转换成正数，因此相当于slice(2,5)。

### **8.splice()**

splice()：删除、插入和替换。

删除：指定 2 个参数：要删除的第一项的位置和要删除的项数。

　　　　书写格式：arr.splice( 1 , 3 )

插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。

　　　　书写格式：arr.splice( 2,0,4,6 )
替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。

　　　　书写格式：arr.splice( 2,0,4,6 )

```js
var arr = [1,3,5,7,9,11];
var arrRemoved = arr.splice(0,2);
console.log(arr); 　　　　　　　　　　　　　　　//[5, 7, 9, 11]
console.log(arrRemoved); 　　　　　　　　　　　//[1, 3]
var arrRemoved2 = arr.splice(2,0,4,6);
console.log(arr); 　　　　　　　　　　　　　　　// [5, 7, 4, 6, 9, 11]
console.log(arrRemoved2); 　　　　　　　　　　// []
var arrRemoved3 = arr.splice(1,1,2,4);
console.log(arr); 　　　　　　　　　　　　　　　// [5, 2, 4, 4, 6, 9, 11]
console.log(arrRemoved3); 　　　　　　　　　　//[7]
```

### **9.indexOf()和 lastIndexOf()**

**indexOf()：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。**

　　　　书写格式：arr.indexof( 5 )

***\*lastIndexOf：接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的末尾开始向前查找。\**** 

　　　　书写格式：arr.lastIndexOf( 5,4 )

```js
var arr = [1,3,5,7,7,5,3,1];
console.log(arr.indexOf(5)); 　　　　　　//2
console.log(arr.lastIndexOf(5)); 　　　 //5
console.log(arr.indexOf(5,2)); 　　　　 //2
console.log(arr.lastIndexOf(5,4)); 　　//2
console.log(arr.indexOf("5")); 　　　　 //-1
```

### **10.forEach()**

**forEach()：对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。**

　　　　书写格式：arr.forEach()



```js
var arr = [1, 2, 3, 4, 5];
arr.forEach(function(x, index, a){
console.log(x + '|' + index + '|' + (a === arr));
});
// 输出为：
// 1|0|true
// 2|1|true
// 3|2|true
// 4|3|true
// 5|4|true
```

### **11.map()**

**map()：指“映射”，对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。**

创建一个新数组并返回，新数组的每个元素由原数组中的每一个元素执行提供的函数而来，其中原始数组不会发生改变。

　　　　书写格式：arr.map()



```js
var arr = [1, 2, 3, 4, 5];
var arr2 = arr.map(function(item){
return item*item;
});
console.log(arr2); 　　　　　　　　//[1, 4, 9, 16, 25]
```

### **12.filter()**

**filter()：“过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。**

　　　　书写格式：arr.filter()



```js
var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
var arr2 = arr.filter(function(x, index) {
return index % 3 === 0 || x >= 8;
}); 
console.log(arr2); 　　　　　　　　//[1, 4, 7, 8, 9, 10]
```

### **13.every()**

**every()：判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。**

　　　　书写格式：arr.every()



```js
var arr = [1, 2, 3, 4, 5];
var arr2 = arr.every(function(x) {
return x < 10;
}); 
console.log(arr2); 　　　　　　　　//true
var arr3 = arr.every(function(x) {
return x < 3;
}); 
console.log(arr3); 　　　　　　　　// false
```

### **14.some()**

**some()：判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。**

　　　　**书写格式：arr.some()**



```js
var arr = [1, 2, 3, 4, 5];
var arr2 = arr.some(function(x) {
return x < 3;
}); 
console.log(arr2); 　　　　　　　　//true
var arr3 = arr.some(function(x) {
return x < 1;
}); 
console.log(arr3); 　　　　　　　　// false
```

### **15.reduce**

```js
arr.reduce(callback,[initialValue])
```

reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（或者上一次回调函数的返回值），当前元素值，当前索引，调用 reduce 的数组。

```js
callback （执行数组中每个值的函数，包含四个参数）

    1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））
    2、currentValue （数组中当前被处理的元素）
    3、index （当前元素在数组中的索引）
    4、array （调用 reduce 的数组）

initialValue （作为第一次调用 callback 的第一个参数。）
```

**reduce的简单用法**

当然最简单的就是我们常用的数组求和，求乘积了。

```jsx
var  arr = [1, 2, 3, 4];
var sum = arr.reduce((x,y)=>x+y)
var mul = arr.reduce((x,y)=>x*y)
console.log( sum ); //求和，10
console.log( mul ); //求乘积，24
```

**reduce的高级用法**

**（1）计算数组中每个元素出现的次数**

```jsx
let names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice'];

let nameNum = names.reduce((pre,cur)=>{
  if(cur in pre){
    pre[cur]++
  }else{
    pre[cur] = 1 
  }
  return pre
},{})
console.log(nameNum); //{Alice: 2, Bob: 1, Tiff: 1, Bruce: 1}
```

**（2）数组去重**

```jsx
let arr = [1,2,3,4,4,1]
let newArr = arr.reduce((pre,cur)=>{
    if(!pre.includes(cur)){
      return pre.concat(cur)
    }else{
      return pre
    }
},[])
console.log(newArr);// [1, 2, 3, 4]
```

**（3）将二维数组转化为一维**

```jsx
let arr = [[0, 1], [2, 3], [4, 5]]
let newArr = arr.reduce((pre,cur)=>{
    return pre.concat(cur)
},[])
console.log(newArr); // [0, 1, 2, 3, 4, 5]
```

**（3）将多维数组转化为一维**

```jsx
let arr = [[0, 1], [2, 3], [4,[5,6,7]]]
const newArr = function(arr){
   return arr.reduce((pre,cur)=>pre.concat(Array.isArray(cur)?newArr(cur):cur),[])
}
console.log(newArr(arr)); //[0, 1, 2, 3, 4, 5, 6, 7]
```

**（4）、对象里的属性求和**

```jsx
var result = [
    {
        subject: 'math',
        score: 10
    },
    {
        subject: 'chinese',
        score: 20
    },
    {
        subject: 'english',
        score: 30
    }
];

var sum = result.reduce(function(prev, cur) {
    return cur.score + prev;
}, 0);
console.log(sum) //60
```

### **16.findIndex方法**

findIndex() 方法对数组的每个元素执行一次给定的函数

语法：arr.findIndex(arr.forEach(function (currentValue, currentIndex, currentArray){}）

```js
<script>
    let arr = [1, 5, 3, 3, 9];
    let result = arr.findIndex(function(currentValue) {
        if (currentValue == 3) {
            return true;
        }
    })
    console.log(result); // 找得到返回指定元素的索引，找不到返回-1
</script>

```

### **17.find方法**

```js
<script>
    let arr = [1, 5, 3, 3, 9];
    let result = arr.find(function(currentValue) {
        if (currentValue == 33) {
            return true;
        }
    })
    console.log(result); // 找得到返回指定元素的索引，找不到返回undefined
</script>
```

### **18.flat **

 此方法 需要浏览器兼容 IE浏览器不支持 chrome 需要 69及以上版本才支持 可采用其他方法

```js
// flat 将数组扁平化 可传入一个参数为 要扁平化的层数 传入`Infinity`则代表不管多少层 全部扁平化为一层
const arr = [1, [1,2,3,[4,5,6]], 6, 7, 9, 3] // 三维数组
const newArr1 = arr.flat(1)
console.log(newArr1) // 输出 [ 1, 1, 2, 3, [ 4, 5, 6, [ 7, 8, 9 ] ], 6 ]
const newArr2 = arr.flat(2)
console.log(newArr2) // 输出 [ 1, 1, 2, 3, 4, 5, 6, [ 7, 8, 9 ], 6 ]
const newArr3 = arr.flat(Infinity)
console.log(newArr3) // 输出 [1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 6]
```

**19.from (将类数组转换为真数组)**

```js
// from 转换有length的类数组 可传入三个参数（转换的数组-参数一，转换数组的每一个值-参数三，映射参数二的this-参数三）
 const arr = Array.from('abc') // 输出 [a, b, c]
 const arr1 = Array.from([1,2,3],v => v + 1) // 输出 [2,3,4]
 // 用 Set 和 from 去重
 const arr2 = Array.from(new Set([1,2,1,2,3,4,5,3,5,4])) // 输出 [ 1, 2, 3, 4, 5 ]
 const arr3 = [...new Set([1,2,1,2,3,4,5,3,5,4])] // 输出 [ 1, 2, 3, 4, 5 ]
```

**20. delete (删除元素值-删除后位置还在-值为undefined)**

```javascript
const arr = [1, 2, 3, 4]
delete arr[1] // 删除arr 索引为1的值 不删除位置
console.log(arr[1]) // 输出 undefined
```

**21.fill (填充数组-影响原数组)**

```js
// fill 接收三个参数fill(填充的值,填充开始位置,填充结束位置) 如果开始位置或者结束位置值为负数 则表示从结尾往前算
const arr = [1, 2, 3, 4]
arr.fill(6) // [6, 6, 6, 6]
arr.fill(6, 1) // [1, 6, 6, 6] 
arr.fill(6, -1) // [6, 6, 6, 4]
arr.fill(6, 1, -1) // [1, 6, 6, 4]
```

**22.copyWithin (替换元素-影响原数组)**

```js
// copyWithin 有三个参数copyWithin(开始替换的位置,开始截取元素的位置,结束截取元素的位置) 会将截取的元素 从参数以的位置开始替换。如果第二个或者第三个参数为负数 则会从后往前
let arr = [1,2,3,4,5,6];
// 从索引3 截取到索引5(不包括5) (截取到[4,5]) 然后将[4,5]从索引1开始替换
arr.copyWithin(1,3,5);
 console.log(arr); // 输出 [ 1, 4, 5, 4, 5, 6 ]
```

## 对象方法

**Object构造方法**

- [`Object.assign()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)

  将所有可枚举的自身属性的值从一个或多个源对象复制到目标对象。

- [`Object.create()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create)

  用指定的原型对象和属性创建一个新对象。

- [`Object.defineProperty()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)

  将给定描述符描述的命名属性添加到对象。

- [`Object.defineProperties()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties)

  将给定描述符描述的命名属性添加到对象。

- [`Object.entries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)

  返回一个包含`[key, value]`给定对象**自己的**可枚举字符串属性的所有对的数组。

- [`Object.freeze()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)

  冻结对象。其他代码无法删除或更改其属性。

- [`Object.fromEntries()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/fromEntries)

  从可迭代的`[key, value]`对中返回一个新对象。（这是的反向 [`Object.entries`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries)）。

- [`Object.getOwnPropertyDescriptor()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor)

  返回对象的命名属性的属性描述符。

- [`Object.getOwnPropertyDescriptors()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptors)

  返回一个包含对象自身所有属性描述符的对象。

- [`Object.getOwnPropertyNames()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames)

  返回一个数组，其中包含给定对象**自己**的所有可枚举和不可枚举属性的名称。

- [`Object.getOwnPropertySymbols()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols)

  返回直接在给定对象上找到的所有符号属性的数组。

- [`Object.getPrototypeOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf)

  返回`prototype`指定对象的。

- [`Object.is()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is)

  比较两个值是否相同。求所有`NaN`值（不同于“抽象相等比较”和“严格相等比较”）。

- [`Object.isExtensible()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible)

  确定是否允许扩展对象。

- [`Object.isFrozen()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isFrozen)

  确定对象是否冻结。

- [`Object.isSealed()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/isSealed)

  确定对象是否密封。

- [`Object.keys()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)

  返回一个数组，其中包含给定对象**自己**的所有可枚举字符串属性的名称。

- [`Object.preventExtensions()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions)

  防止对象的任何扩展。

- [`Object.seal()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)

  防止其他代码删除对象的属性。

- [`Object.setPrototypeOf()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf)

  设置对象的原型（其内部`[[Prototype]]`属性）。

- [`Object.values()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values)

  返回一个数组，该数组包含与给定对象**自己的所有**可枚举字符串属性相对应的值。

**Object实例和Object原型对象**

JavaScript中的所有对象均来自`Object`。所有对象都继承自的方法和属性[`Object.prototype`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype)，尽管它们可能会被覆盖。

例如，其他构造函数的原型将覆盖`constructor`属性并提供自己的`toString()`方法。对`Object`原型对象的更改将传播到所有对象，除非经受这些更改的属性和方法在原型链中进一步被覆盖。

**方法**

1、Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。

```js
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };
const returnedTarget = Object.assign(target, source);
console.log(target);
// expected output: Object { a: 1, b: 4, c: 5 }
console.log(returnedTarget);
// expected output: Object { a: 1, b: 4, c: 5 }
```

2、Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 

```js
const person = {
  isHuman: false,
  printIntroduction: function () {
    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);
  }
};

const me = Object.create(person);

me.name = "Matthew"; // "name" is a property set on "me", but not on "person"
me.isHuman = true; // inherited properties can be overwritten

me.printIntroduction();
// expected output: "My name is Matthew. Am I human? true"
```

3、Object.defineProperties() 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。

```
 语法   Object.defineProperties(obj, props)   obj在其上定义或修改属性的对象。props要定义其可枚举属性或修改的属性描述符的对象。对象中存在的属性描述符主要有两种：数据描述符和访问器描述符（更多详情，请参阅Object.defineProperty()）。描述符具有以下键：configurabletrue 当且仅当该属性描述符的类型可以被改变并且该属性可以从对应对象中删除。 默认为 falseenumerabletrue 当且仅当在枚举相应对象上的属性时该属性显现。 默认为 falsevalue与属性关联的值。可以是任何有效的JavaScript值（数字，对象，函数等）。 默认为 undefined.writabletrue当且仅当与该属性相关联的值可以用assignment operator改变时。 默认为 falseget作为该属性的 getter 函数，如果没有 getter 则为undefined。函数返回值将被用作属性的值。 默认为 undefinedset作为属性的 setter 函数，如果没有 setter 则为undefined。函数将仅接受参数赋值给该属性的新值。 默认为 undefined返回值节 传递给函数的对象。


```

```js
var obj = {};
Object.defineProperties(obj, {
  'property1': {
    value: true,
    writable: true
  },
  'property2': {
    value: 'Hello',
    writable: false
  }
  // etc. etc.
});
```

4、Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。

```
语法 Object.defineProperty(obj, prop, descriptor)      obj要在其上定义属性的对象。prop要定义或修改的属性的名称。descriptor将被定义或修改的属性描述符。返回值节    被传递给函数的对象。在ES6中，由于 Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而Object.defineProperty 是定义key为Symbol的属性的方法之一。


```

5、Object.entries()方法返回一个给定对象自身可枚举属性的键值对数组，其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环也枚举原型链中的属性）

```js
const object1 = { foo: 'bar', baz: 42 };
console.log(Object.entries(object1)[1]);
// expected output: Array ["baz", 42]

const object2 = { 0: 'a', 1: 'b', 2: 'c' };
console.log(Object.entries(object2)[2]);
// expected output: Array ["2", "c"]

const result = Object.entries(object2).sort((a, b) => a - b);
console.log(Object.entries(result)[1]);
// expected output: Array ["1", Array ["1", "b"]]
```

6、Object.freeze() 方法可以冻结一个对象。一个被冻结的对象再也不能被修改；冻结了一个对象则不能向这个对象添加新的属性，不能删除已有属性，不能修改该对象已有属性的可枚举性、可配置性、可写性，以及不能修改已有属性的值。此外，冻结一个对象后该对象的原型也不能被修改。freeze() 返回和传入的参数相同的对象。

```js
const object1 = {
  property1: 42
};

const object2 = Object.freeze(object1);

object2.property1 = 33;
// Throws an error in strict mode

console.log(object2.property1);
// expected output: 42
```

7、Object.fromEntries() 把键值对列表转换为一个对象。

```js
Map 转化为 Object
通过 Object.fromEntries， 可以将 Map 转化为 Object:

const map = new Map([ ['foo', 'bar'], ['baz', 42] ]);
const obj = Object.fromEntries(map);
console.log(obj); // { foo: "bar", baz: 42 }

Array 转化为 Object
通过 Object.fromEntries， 可以将 Array 转化为 Object:

const arr = [ ['0', 'a'], ['1', 'b'], ['2', 'c'] ];
const obj = Object.fromEntries(arr);
console.log(obj); // { 0: "a", 1: "b", 2: "c" }
对象转换为Object
Object.fromEntries 是 Object.entries() 的反转函数， 借用 array manipulation methods 可以转换对象，如下：

const object1 = { a: 1, b: 2, c: 3 };

const object2 = Object.fromEntries(
  Object.entries(object1)
  .map(([ key, val ]) => [ key, val * 2 ])
);

console.log(object2);
// { a: 2, b: 4, c: 6 }
```

8、Object.is() 方法判断两个值是否是相同的值

```js
Object.is('foo', 'foo');     // true
Object.is(window, window);   // true

Object.is('foo', 'bar');     // false
Object.is([], []);           // false

var foo = { a: 1 };
var bar = { a: 1 };
Object.is(foo, foo);         // true
Object.is(foo, bar);         // false

Object.is(null, null);       // true

// 特例
Object.is(0, -0);            // false
Object.is(-0, -0);           // true
Object.is(NaN, 0/0);         // true
```

9、Object.isFrozen()方法判断一个对象是否被冻结

```js
// 使用Object.freeze是冻结一个对象最方便的方法.
var frozen = { 1: 81 };
Object.isFrozen(frozen) //=== false
Object.freeze(frozen);
Object.isFrozen(frozen) //=== true

// 一个冻结对象也是一个密封对象.
Object.isSealed(frozen) //=== true

// 当然,更是一个不可扩展的对象.
Object.isExtensible(frozen) //=== false
在 ES5 中，如果参数不是一个对象类型，将抛出一个TypeError异常。在 ES2015 中，非对象参数将被视为一个冻结的普通对象，因此会返回true。

Object.isFrozen(1);
// TypeError: 1 is not an object (ES5 code)

Object.isFrozen(1);
// true                          (ES2015 code)
```

10、Object.keys() 方法会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致 。

```js
// simple array
var arr = ['a', 'b', 'c'];
console.log(Object.keys(arr)); // console: ['0', '1', '2']

// array like object
var obj = { 0: 'a', 1: 'b', 2: 'c' };
console.log(Object.keys(obj)); // console: ['0', '1', '2']

// array like object with random key ordering
var anObj = { 100: 'a', 2: 'b', 7: 'c' };
console.log(Object.keys(anObj)); // console: ['2', '7', '100']

// getFoo is a property which isn't enumerable
var myObj = Object.create({}, {
  getFoo: {
    value: function () { return this.foo; }
  } 
});
myObj.foo = 1;
console.log(Object.keys(myObj)); // console: ['foo']
```

11、Object.values()方法返回一个给定对象自身的所有可枚举属性值的数组，值的顺序与使用for...in循环的顺序相同 ( 区别在于 for-in 循环枚举原型链中的属性 )。

```js
var obj = { foo: 'bar', baz: 42 };
console.log(Object.values(obj)); // ['bar', 42]

// array like object
var obj = { 0: 'a', 1: 'b', 2: 'c' };
console.log(Object.values(obj)); // ['a', 'b', 'c']

// array like object with random key ordering
// when we use numeric keys, the value returned in a numerical order according to the keys
var an_obj = { 100: 'a', 2: 'b', 7: 'c' };
console.log(Object.values(an_obj)); // ['b', 'c', 'a']

// getFoo is property which isn't enumerable
var my_obj = Object.create({}, { getFoo: { value: function() { return this.foo; } } });
my_obj.foo = 'bar';
console.log(Object.values(my_obj)); // ['bar']

// non-object argument will be coerced to an object
console.log(Object.values('foo')); // ['f', 'o', 'o']
```

性质

- [`Object.prototype.constructor`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor)

  指定创建对象原型的函数。



## 字符串方法

**1.concat**
将两个或多个字符的文本组合起来，返回一个新的字符串。

```js
var a = "hello";
var b = ",world";
var c = a.concat(b);
alert(c);
//c = "hello,world"
```

**2.indexOf**

返回字符串中一个子串第一处出现的索引（从左到右搜索）。如果没有匹配项，返回 -1 。

注意：indexOf()方法对大小写敏感，如果子字符串没有找到，返回-1。第二个参数表示从哪个下标开始查找，没有写则默认从下标0开始查找。

```js
var str="Hello World";
var str1=str.indexOf("o");
var str2=str.indexOf("world");
var str3=str.indexOf("o",str1+1);
console.log(str1); //4 默认只找第一个关键字位置，从下标0开始查找
console.log(str2); //-1 没有找到
console.log(str3); //7
```

**3.lastIndexOf**
返回字符串中一个子串最后一处出现的索引（从右到左搜索），如果没有匹配项，返回 -1 。

lastIndexOf()方法对大小写敏感，如果子字符串没有找到，返回-1。第二个参数表示从哪个下标开始查找，没有写则默认从最后一个字符处开始查找。

```js
var str="Hello World";
var str1=str.lastIndexOf("o");
var str2=str.lastIndexOf("world");
var str3=str.lastIndexOf("o",str1-1);
console.log(str1); //7
console.log(str2); //-1
console.log(str3); //4
```

**4.toLowerCase()**

把字符串转为小写，返回新的字符串。

```js
var str="Hello World";
var str1=str.toLowerCase();
console.log(str); //Hello World
console.log(str1); //hello world
```

**5.toUpperCase()**

把字符串转为大写，返回新的字符串。

```js
var str="hello world";
var str1=str.toUpperCase();
console.log(str); //hello world
console.log(str1); //HELLO WORLD
```

**6.charAt()**

返回指定下标位置的字符。如果index不在0-str.length(不包含str.length)之间，返回空字符串。

```js
var str="hello world";
var str1=str.charAt(6);
console.log(str1); 
```

**7.charCodeAt()**

返回指定下标位置的字符的unicode编码,这个返回值是 0 - 65535 之间的整数。如果index不在0-str.length(不包含str.length)之间，返回NaN。

```js
var str="hello world";
var str1=str.charCodeAt(1);
var str2=str.charCodeAt(-2); //NaN
console.log(str1); //101
```

**8.slice()**

 返回字符串中提取的子字符串。（不改变原数组）

```js
var str="Hello World";
var str1=str.slice(2); //如果只有一个参数，则提取开始下标到结尾处的所有字符串
var str2=str.slice(2,7); //两个参数，提取下标为2，到下标为7但不包含下标为7的字符串
var str3=str.slice(-7,-2); //如果是负数，-1为字符串的最后一个字符。提取从下标-7开始到下标-2但不包含下标-2的字符串。前一个数要小于后一个数，否则返回空字符串

console.log(str1); //llo World
console.log(str2); //llo W
console.log(str3); //o Wor
```

**9.substring()**

提取字符串中介于两个指定下标之间的字符。

注意：substring()用法与slice()一样，但不接受负值的参数

```js
var str="Hello World";
var str1=str.substring(2)
var str2=str.substring(2,2);
var str3=str.substring(2,7);
console.log(str1); //llo World
console.log(str2); //如果两个参数相等，返回长度为0的空串
console.log(str3); //llo W
```

**10.substr()**

substr(start,length)返回从指定下标开始指定长度的的子字符串

```js
var str="Hello World";
var str1=str.substr(1)
var str2=str.substr(1,3);
var str3=str.substr(-3,2);
console.log(str1); //ello World 
console.log(str2); //ell
console.log(str3); //rl
```

注意：如果没有指定length,返回从下标开始处结尾处的所有字符串

**11.split()**

把字符串分割成字符串数组

```js
var str="AA BB CC DD";
var string1="1:2:3:4:5";
var str1=str.split("");//如果把空字符串 ("")用作分割符，那么字符串的每个字符之间都会被分割
var str2=str.split(" "); //以空格为分隔符
var str3=str.split("",4); //4指定返回数组的最大长度
var str4=string1.split(":");
console.log(str1); // ["A", "A", " ", "B", "B", " ", "C", "C", " ", "D", "D"]
console.log(str2); //["AA" "BB" "CC" "DD"]
console.log(str3); //["A", "A", " ", "B"]
console.log(str4); // ["1", "2", "3", "4", "5"]
```

**12.replace()**

在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。

```js
var str="hello WORLD";
var reg=/o/ig; //o为要替换的关键字，不能加引号，否则替换不生效，i忽略大小写，g表示全局查找。
var str1=str.replace(reg,"**")
console.log(str1); //hell** W**RLD
```

**13.match()**

返回所有查找的关键字内容的数组。

```js
var str="To be or not to be";
var reg=/to/ig;
var str1=str.match(reg);
console.log(str1); //["To", "to"]
console.log(str.match("Hello")); //null
```

**14.trim()**

trim() 方法删除字符串两端的空白符

警告：Internet Explorer 8 或更低版本不支持 trim() 方法。

```js
var str = "       Hello World!        ";
alert(str.trim());  //  Hello World!
```



## WeakMap与Map的区别，Set与WeakSet的区别

https://blog.csdn.net/qq_34543438/article/details/97136068

### Map

1. 可以使用任何类型当作键
2. 可迭代遍历


1. add、delete、has、clear、entries、forEach、keys、values

### WeakMap

1. 只能用Object类型作为键
2. 不可迭代遍历


1. get、set、has、delete


1. **键会被垃圾回收机制回收**

### Set

1. 可以保存任何类型的值
2. 可迭代遍历
3. add、delete、has、clear、entries、forEach、keys、values

### WeakSet

1. 只能保存Object类型的值


1. 不可迭代遍历
2. add、delete、has
3. 值会被垃圾回收机制回收，一般用来保存DOM节点



## 数组去重

**一、利用ES6中的 Set 方法去重**

　　注：Set为ES6新增的一个对象，允许存储任何类型（原始值或引用值）的唯一值

```js
let arr = [1, 0, 0, 2, 9, 8, 3, 1, 3, 1];
const newArr = new Set(arr);
console.log(newArr);  //Set(6) {1, 0, 2, 9, 8, …}
console.log([...newArr]); //[1, 0, 2, 9, 8, 3]
console.log(Array.from(newArr)); //[1, 0, 2, 9, 8, 3]
```

**二、使用双重for循环，再利用数组的splice方法去重（ES5常用）**

```js
var arr = [1, 5, 6, 0, 7, 3, 0, 5, 9, 5, 5];
function unique(arr) {
  for (var i = 0, len = arr.length; i < len; i++) {
    for (var j = i + 1, len = arr.length; j < len; j++) {
      if (arr[i] === arr[j]) {
        arr.splice(j, 1);
        j--; // 每删除一个数j的值就减1
        len--; // j值减小时len也要相应减1（减少循环次数，节省性能）
        // console.log(j,len)
      }
    }
  }
  return arr;
}
console.log(unique(arr)); //  [1, 5, 6, 0, 7, 3, 9]
```

**三、利用数组的indexOf方法去重**

　　注：array.indexOf(item,statt) 返回数组中某个指定的元素的位置，没有则返回-1

```js
var arr =[1,-5,-4,0,-4,7,7,3];
function unique(arr){
   var arr1 = [];       // 新建一个数组来存放arr中的值
   for(var i=0,len=arr.length;i<len;i++){
       if(arr1.indexOf(arr[i]) === -1){
           arr1.push(arr[i]);
       }
   }
   return arr1;
}
console.log(unique(arr));    // 1, -5, -4, 0, 7, 3
```

**四、利用数组的sort方法去重（相邻元素对比法）**

　　注：array.sort( function ) 参数必须是函数，可选，默认升序

```js
var arr =  [5,7,1,8,1,8,3,4,9,7];
function unique( arr ){
    arr = arr.sort();
    console.log(arr);

    var arr1 = [arr[0]];
    for(var i=1,len=arr.length;i<len;i++){
        if(arr[i] !== arr[i-1]){
            arr1.push(arr[i]);
        }
    }
    return arr1;
}
console.log(unique(arr))l;   //  1, 1, 3, 4, 5, 7, 7, 8, 8, 9
```

**六、利用数组的includes去重**

　　注：arr.includes(指定元素(必填),指定索引值(可选,默认值为0) )，有值返回true，没有则返回false

```js
var arr = [-1,0,8,-3,-1,5,5,7];
   function unique( arr ){
       var arr1 = [];
       for(var i=0,len=arr.length;i<len;i++){
           if( !arr1.includes( arr[i] ) ){      // 检索arr1中是否含有arr中的值
               arr1.push(arr[i]);
           }
    }
       return arr1;
  }
console.log(unique(arr));      //  -1, 0, 8, -3, 5, 7
```

**七、利用数组的filter方法去重**

注：filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，array.filter(function(currentValue,index,arr), thisValue)

currentValue：当前元素的值(必选参数)、index：当前元素的索引值(可选)、arr：当前元素属于的数组对象(可选)、thisValue：对象作为该执行回调时使用，传递给函数，用作 "this" 的值，默认undefined(可选)

```js
var arr = [1,2,8,9,5,8,4,0,4];
function unique( arr ){
    // 如果新数组的当前元素的索引值 == 该元素在原始数组中的第一个索引，则返回当前元素
    return arr.filter(function(item,index){
        return arr.indexOf(item,0) === index;
    });
}
console.log(unique(arr));    //  [1, 2, 8, 9, 5, 4, 0]
```

**八、利用函数递归去重**

```js
var arr = [1,1,5,6,0,9,3,0,6]
function unique( arr ){
     var arr1 = arr;
     var len = arr1.length;
     arr1.sort((a,b)=>{
         return a-b
     })
     function loop(index){
         if(index >= 1){
            if(arr1[index] === arr1[index-1] ){
                arr1.splice(index,1);
           }
            loop(index - 1);  // 递归loop，然后数组去重
       }
   }
   loop(len-1);
   return arr1
}
console.log(unique(arr));    //   [0, 1, 3, 5, 6, 9]
```

**九、利用ES6中的Map方法去重**

```js
/*
              　　　　创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果。
                */
let arr = [1, 0, 8, 3, -9, 1, 0, -9, 7]
function unique(arr) {
	let map = new Map();
	console.log(map)
	//let arr1 = new Array();      // 数组用于返回结果
	let arr1 = []
    	for (let i = 0, len = arr.length; i < len; i++) {
        	if (map.has(arr[i])) {      // 判断是否存在该key值
            	map.set(arr[i], true);
        	}
        	else {
            	map.set(arr[i], false);
            	arr1.push(arr[i]);
        	}
    	}
    	return arr1;
	}
console.log(unique(arr)); // [1, 0, 8, 3, -9, 7]
```

**十、reduce数组去重**

```jsx
let arr = [1,2,3,4,4,1]
let newArr = arr.reduce((pre,cur)=>{
    if(!pre.includes(cur)){
      return pre.concat(cur)
    }else{
      return pre
    }
},[])
console.log(newArr);// [1, 2, 3, 4]
```

## **找出数组最大值**

1.es6拓展运算符...

```js
Math.max(...arr)
```

2.es5 apply(与方法1原理相同)

```js
Math.max.apply(null,arr)
```

3.for循环

```js
let max = arr[0];
for (let i = 0; i < arr.length - 1; i++) {
    max = max < arr[i+1] ? arr[i+1] : max
}
```

4.数组sort()

```js
arr.sort((num1, num2) => {
    return num1 - num2 < 0
})
arr[0]
```

5.数组reduce

```js
arr.reduce((num1, num2) => {
    return num1 > num2 ? num1 : num2}
)
```



## 数组扁平化

**flat()**

------

console.log([1 ,[2, 3]].flat()); // [1, 2, 3]

// 指定转换的嵌套层数

console.log([1, [2, [3, [4, 5]]]].flat(2)); // [1, 2, 3, [4, 5]]

// 不管嵌套多少层

console.log([1, [2, [3, [4, 5]]]].flat(Infinity)); // [1, 2, 3, 4, 5]

// 自动跳过空位

console.log([1, [2, , 3]].flat()); // [1, 2, 3] 

**1. reduce**

遍历数组每一项，若值为数组则递归遍历，否则concat。

```js
function flatten(arr) {  
    return arr.reduce((result, item)=> {
        return result.concat(Array.isArray(item) ? flatten(item) : item);
    }, []);
}
```

reduce是数组的一种方法，它接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。

reduce包含两个参数：回调函数，传给total的初始值

```js
// 求数组的各项值相加的和： 
arr.reduce((total, item)=> {  // total为之前的计算结果，item为数组的各项值
    return total + item;
}, 0);
```

**2. toString & split**

调用数组的toString方法，将数组变为字符串然后再用split分割还原为数组

```js
function flatten(arr) {
    return arr.toString().split(',').map(function(item) {
        return Number(item);
    })
} 
```

因为split分割后形成的数组的每一项值为字符串，所以需要用一个map方法遍历数组将其每一项转换为数值型

**3. join & split**

和上面的toString一样，join也可以将数组转换为字符串

```js
function flatten(arr) {
    return arr.join(',').split(',').map(function(item) {
        return parseInt(item);
    })
}
```

**4. 递归**

递归的遍历每一项，若为数组则继续遍历，否则concat

```js
function flatten(arr) {
    var res = [];
    arr.map(item => {
        if(Array.isArray(item)) {
            res = res.concat(flatten(item));
        } else {
            res.push(item);
        }
    });
    return res;
}
```





## **数组排序**

1、冒泡排序(两两对比)

以从小到大排序为例，冒泡排序的原理就是通过两层循环把数组中两两相邻的元素进行比较，是的大的元素放到后边，元素交换位置，从而一步步的交换元素的位置，使得最大的元素放到数组的末尾，这样内部的循环就进行了一轮，再根据外部的循环依次再把次大一点的元素放到数组的末尾，从而实现数组的逐步排序。代码如下：

```js
// 冒泡排序
var arr = [52,3,8,57,75,2,1];
for (var i = 0; i<arr.length; i++) {
	for (var j =0;j<arr.length-i; j++) {
		if(arr[j]>arr[j+1]){
			var temp = arr[j];
			arr[j]=arr[j+1];
			arr[j+1]=temp; 
		}
	}
}
console.log(arr); //[1, 2, 3, 8, 52, 57, 75]
```

```js
(7) [3, 8, 52, 57, 2, 1, 75]
(7) [3, 8, 52, 2, 1, 57, 75]
(7) [3, 8, 2, 1, 52, 57, 75]
(7) [3, 2, 1, 8, 52, 57, 75]
(7) [2, 1, 3, 8, 52, 57, 75]
(7) [1, 2, 3, 8, 52, 57, 75]
(7) [1, 2, 3, 8, 52, 57, 75]
(7) [1, 2, 3, 8, 52, 57, 75]
```

这里面通过一个变量temp实现相邻两个元素的位置替换，从而循环一轮使得最大的元素放到数组的末尾。

**插入排序**

（抓住一个跟前面的对比大小，自己小的话就交换位置再继续往前对比，直到没有元素或者比自己小的元素出现才停止比较）

```js
 var arr = [5, 2, 1, 10, 8, 12, 40, 26, 30];
      var insertSort = function (arr) {
        var len = arr.length;
        var preIndex, current;
        for (var i = 1; i < len; i++) {
          preIndex = i - 1;
          current = arr[i];
          while (preIndex >= 0 && arr[preIndex] > current) {
            arr[preIndex + 1] = arr[preIndex];
            preIndex--;
            console.log("arr", arr);
          }
          arr[preIndex + 1] = current;
          console.log(arr);
        }
        return arr;
      };
      console.log("insertSort", insertSort(arr));
```

```js
arr (9) [5, 5, 1, 10, 8, 12, 40, 26, 30]
(9) [2, 5, 1, 10, 8, 12, 40, 26, 30]
arr (9) [2, 5, 5, 10, 8, 12, 40, 26, 30]
arr (9) [2, 2, 5, 10, 8, 12, 40, 26, 30]
(9) [1, 2, 5, 10, 8, 12, 40, 26, 30]
(9) [1, 2, 5, 10, 8, 12, 40, 26, 30]
arr (9) [1, 2, 5, 10, 10, 12, 40, 26, 30]
(9) [1, 2, 5, 8, 10, 12, 40, 26, 30]
(9) [1, 2, 5, 8, 10, 12, 40, 26, 30]
(9) [1, 2, 5, 8, 10, 12, 40, 26, 30]
arr (9) [1, 2, 5, 8, 10, 12, 40, 40, 30]
(9) [1, 2, 5, 8, 10, 12, 26, 40, 30]
arr (9) [1, 2, 5, 8, 10, 12, 26, 40, 40]
(9) [1, 2, 5, 8, 10, 12, 26, 30, 40]
insertSort (9) [1, 2, 5, 8, 10, 12, 26, 30, 40]
```

**快速排序**

快速排序是运用递归进行循环调用函数从而使得数组进行排序，代码如下：

```js
// 快速排序
function quickSort(arr){
  if(arr.length <= 1) return arr;
  var Temp = Math.floor(arr.length/2);
  var left = [],right = [];
  var num = arr.splice(Temp,1)[0];
  for(var i = 0;i < arr.length;i ++){
    if(arr[i] < num){
      left.push(arr[i]);
    }
    else {
      right.push(arr[i]);
    }
  }
  return quickSort(left).concat(num,quickSort(right));
}
var arr=[5,2,1,10,8,12,40,26,30];
console.log(quickSort(arr)); //[1, 2, 5, 8, 10, 12, 26, 30, 40]
```

其原理是首先创建一个递归函数，也就是函数的返回值还是函数本身，直到符合条件之后递归函数停止运行，像这个函数就是当时arr数组的长度小于等于1的时候该递归函数停止运行。基本原理就是先找到数组中的中间那个元素的索引，如果数组长度是双数，那么就默认向上取值，也就是默认取数组长度/2+1位索引，在根据索引去的数组中间的值，然后创建两个空数组，用来放置比该元素小的值和比该元素大的值，在循环数组进行判断，如果数组的元素小于该中间位置元素的值，就放到左边数组，反之放到右边的数组，在函数中返回值设置为左边数组+中间的值+右边数组的拼接新数组，然后再根据递归对左边和右边的数组分别进行刚才的操作，直到数组的长度小于或者等于1，这时候停止，这时候调用函数之后，传入一个数组，就会自动返回数组排序之后的新数组，这就是快速排序的原理。

**array.sort():**

sort() 方法用于对数组的元素进行排序，默认按“字母”升序，即使数组的元素是数字，因此，对于数字，就需要特殊的写法了。

**普通数组：**

\1. 字符串数组：

```
var fruits = ["Banana", "Orange", "Apple", "Mango"];
fruits.sort();//默认升序　　Apple,Banana,Mango,Orange
fruits.sort().reverse();//降序　　Orange,Mango,Banana,Apple


```

\2. 数字数组：

由于sort()方法默认按“字母”升序，所以对于数字组成的数组，就需要使用特殊的写法来进行排序了。

先上代码，具体写法如下：

```
arr.sort((a,b)=>{return a-b})//升序
arr.sort((a,b)=>{return b-a})//降序


```

如上，使用数字对数组进行排序，就需要通过一个函数作为参数来调用。

**对象数组：**

使用场景——已知某品牌门店列表数据（含距当前位置的距离），需要按距离由仅及远排序，具体实现方法如下：

```js
var shoplist = [{
  "name": "上塘中海锦城",
  "distance": 14307.0275
}, {
  "name": "汉堡王深圳华强北店",
  "distance": 16606.5901
}, {
  "name": "汉堡王深圳蔡屋围店",
  "distance": 18062.4395
}, {
  "name": "汉堡王深圳金丰城店",
  "distance": 18468.4439
}, {
  "name": "汉堡王深圳地王店",
  "distance": 18484.8283
}, {
  "name": "汉堡王深圳龙岗宝能店",
  "distance": 39006.9269
}, {
  "name": "汉堡王深圳龙华绿景香颂店",
  "distance": 15356.4863
}, {
  "name": "汉堡王深圳西荟城店",
  "distance": 24990.1325
}, {
  "name": "汉堡王深圳魅力时代店",
  "distance": 8228.8474
}, {
  "name": "汉堡王深圳福华三路店",
  "distance": 12693.439
}]
shoplist.sort((a, b) => {
  return a.distance - b.distance
})
```

如上，关键代码就一句： 

```
shoplist.sort((a,b)=>{return a.distance-b.distance})


```

简单分析不难发现，这跟上面数字数组排序用法是一样的，只不过是这里使用了数组中对象元素的 distance 这一数字字段进行比较排序的。

经过排序后的数据如下图，门店列表已经按距离字段进行升序排列，根据这些排序后的数据进行展示就OK了：

![img](https://img2018.cnblogs.com/blog/546882/201810/546882-20181023150935632-83581668.png)

**反序排序：**

与上面排序不同，反转排序方法 reverse() 将一个数组中的元素的顺序反转排序。

这个方法单独使用的场景不多，但是结合sort()排序方法使用的场景比较多一些，特别是对于一些复杂的数组。

如网上商城商品搜索列表页面的正序、反序，有根据价格的，有根据销量的，还有根据评价的，如果单单是正序，或者是排序，那么直接用sort()方法就好了。但如果正序排序之后又需要进行反序排列，那么直接用reverse()进行反转就OK了，没必要再用sort()进行反序排列，无论是在写法上，还是计算速度上都要快好多的：

```js
//1. sort()进行反序
shoplist.sort((a,b)=>{return b.distance-a.distance})
//2. reverse()反序
shoplist.reverse()
```

## 函数的柯里化

**概念:**”函数柯里化”是指将多变量函数拆解为单变量的多个函数的依次调用 

就是利用函数执行，可以形成一个不销毁的私有作用域，把预先处理的内容都存在这个不销毁的作用域里面，并且返回一个函数，以后要执行的就是这个函数。

**数据柯里化的作用是什么?**

在处理表单时,可以通过ref的三种方式都可以获取表单控件数据,但是若是很多控件,都去定义一个ref(过多的使用会有性能问题),或者定义多个函数,那么就太臃肿了,那么数据柯里化可以解决

**函数的柯里化:通过函数调用继续返回函数的方式,实现多次接受参数最后统一处理的函数编码形式.**

## 什么是重绘回流

- 回流

  - render树中一部分或全部元素需要改变尺寸、布局、或着需要隐藏而需要重新构建，这个过程叫做回流
  - 回流必将引起重绘

- 重绘

  - render树中一部分元素改变，而不影响布局的，只影响外观的，比如颜色。该过程叫做重绘

  页面至少经历一次回流和重绘(第一次加载的时候)

## 解释下什么是变量声明提升？

- 变量提升（hoisting），是负责解析执行代码的 JavaScript 引擎的工作方式产生的一个特性。
- 首先，对代码进行预解析，并获取声明的所有变量
- 然后，将这些变量的声明语句统一放到代码的最前面。
- 最后，开始一行一行运行代码
- 注意：这是不规范, 不合理的, 我们用的  let 就没有这个变量提升的问题。

## 说一下你对JS面向对象的理解

面向对象是一种思想，是基于面向过程而言的，就是说面向对象是将功能等通过对象来实现，将功能封装进对象之中，让对象去实现具体的细节；这种思想是将数据作为第一位，这是对数据一种优化，操作起来更加的方便，简化了过程。

面向对象有三个特点：

封装（隐藏对象的属性和实现细节，对外提供公共访问方式），

继承（提高代码复用性，继承是多态的前提），

多态（是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象）

## 谈谈你对 JavaScript 作用域链的理解？

核心概念：函数内部可以访问到函数外部作用域的变量,  而外部函数还可以访问到全局作用域的变量,这样的变量作用域访问的链式结构, 被称之为作用域链

## 说说你对this的理解?

this表示当前对象,this的指向是根据调用的上下文来决定的,默认指向window对象

![img](https://cdn.nlark.com/yuque/0/2021/png/22330294/1639473192911-d3370204-0e31-44ff-a5a8-defb9d37d9d9.png)

## 闭包

**1.1什么是闭包？**

闭包是指有权访问另外一个函数作用域中的变量的函数。可以理解为(一个函数作用域能够访问另一个函数作用域的变量的函数)

**1.2闭包的实际应用**

**（1）react中函数柯里化**、

**（2）React中函数式组件hooks的React.useEffect模仿生命周期即将销毁钩子时候用到**

  **(3)   防抖**

**（3）在函数执行之前为要执行的函数提供具体参数，如react表单传值**

```react
<Input value = {this.state.name} onChange = {(e) => {this.changeInput(‘name’,e)} } style = {undefined{width:“150px”}} placeholder=“姓名” />
<Input value = {this.state.phone} onChange = {this.changeInput('phone') } style = {undefined{width:“150px”}} placeholder=“手机号” />
```

在[react](https://so.csdn.net/so/search?from=pc_blog_highlight&q=react)中input的value是通过this.state.value动态绑定的,动态的修改需要通过onChange事件,但是如果有好多个input需要动态修改,但是事件又是一样的,只是value的值不一样,这时候就需要onChange事件的复用了

```react
/input onchange触发
	changeInput = (type, e) => {
		return ()=>{
            this.setState({
			//setState 里 key如果传一个变量会自动被处理为一个字符串而不是变 解决方案 给key加一个[]
			[type] : e.target.value
		})
        }
	}
```

**（4）变量私有化，使用闭包代替全局变量**

全局变量有变量污染和变量安全等问题

假设我们在做一个游戏，在写其中关于「还剩几条命」的代码。

所以我们不能让别人「直接访问」这个变量。怎么办呢？

用局部变量。

但是用局部变量别人又访问不到，怎么办呢？

暴露一个访问器（函数），让别人可以「间接访问」。

```text
function(){

  var lives = 50

  window.奖励一条命 = function(){
    lives += 1
  }

  window.死一条命 = function(){
    lives -= 1
  }

}()
```

## 如何解决闭包变量污染?

**使用闭包的注意点**
（1）IE中由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

```
function  showId() {
    var el = document.getElementById("app")
    var id  = el.id
    el.onclick = function(){
      aler(id)   // 这样会导致闭包引用外层的el，当执行完showId后，el无法释放
    }
    el = null    // 主动释放el
}
```

（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。



## 前端做本地数据存储的方式有哪些？

- Cookies
  - 1.会为**每个请求自动携带所有的Cookies数据**，比较方便，但是也是缺点，浪费资源
  - 2.每个domain(站点)限制存储20个cookie；
  - 3.容量只有4K
  - 4.浏览器API比较原始，需要自行封装操作。 (js-cookie)
- localStorage
  - 1.兼容IE8+，操作方便
  - 2.永久存储，除非手动删除
    - localstorage.removeItem('')
  - 3.容量为5M
- sessionStorage
  - 1.功能基本与 localStorage 相似，但当前页面关闭后即被自动清理
  - 2.与Cookies、localStorage 不同点是不能在所有同源窗口间共享，属于会话级别的存储
  - 场景: 记住页面滚动条

## sessionStorage、localStorage和cookie的区别

Cookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的

**答：cookie可以设置失效时间，但没有自己的存取取的方法，需要自己封装，每次请求时跟随请求发送,而localStorage和sessionStorage可以有自己存取的方法例如：setItem(),getItem(),removeItem(),**

![63991815672](C:\Users\86187\AppData\Local\Temp\1639918156720.png)



**web Storage和Cookie的区别** 
Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的，cookie的大小是受限的，并且每次请求一个新的页面的时候cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可跨域调用。 
除此之外，web storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。 
但是cookie也是不可或缺的，cookie的作用是与服务器进行交互，作为http规范的一部分而存在的，而web Storage仅仅是为了在本地“存储”数据而生 
sessionStorage、localStorage、cookie都是在浏览器端存储的数据，其中sessionStorage的概念很特别，引入了一个“浏览器窗口”的概念，sessionStorage是在同源的同窗口中，始终存在的数据，也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一个页面，数据仍然存在，关闭窗口后，sessionStorage就会被销毁，同时“独立”打开的不同窗口，即使是同一页面，sessionStorage对象也是不同的

Web Storage带来的好处： 
1、减少网络流量：一旦数据保存在本地之后，就可以避免再向服务器请求数据，因此减少不必要的数据请求，减少数

据在浏览器和服务器间不必要的来回传递 
2、快速显示数据：性能好，从本地读数据比通过网络从服务器上获得数据快得多，本地数据可以及时获得，再加上网

页本身也可以有缓存，因此整个页面和数据都在本地的话，可以立即显示 
3、临时存储：很多时候数据只需要在用户浏览一组页面期间使用，关闭窗口后数据就可以丢弃了，这种情况使用sessionStorage非常方便

## 解释一下js的同源策略?

**同源**指的是两个 URL 的协议、域名、端口一致，反之，则是**跨域**

## 跨域

所谓同源是指"协议+域名+端口"三者相同，不是同源进行资源交换就是跨域

同源策略限制以下几种行为：

```mipsasm
1.) Cookie、LocalStorage 和 IndexDB 无法读取
2.) DOM 和 Js对象无法获得
3.) AJAX 请求不能发送
```

**跨域解决方案**

1、 通过jsonp跨域
2、后端 跨域资源共享（CORS）或 nginx代理跨域
3、 nodejs中间件代理跨域
4、Vue中配置了代理服务器，自带vue.config.js，React使用中间件 http-proxy-middleware插件创建代理服务器

**通过jsonp跨域**

jsonp实现原理：主要是利用动态创建script标签请求后端接口地址，然后传递callback参数，后端接收callback，后端经过数据处理，返回callback函数调用的形式，callback中的参数就是json

```js

```

**多种解决react中跨域问题方案**

一、最简单的操作
在package.json中加入

"proxy": "http://localhost:8000"
然后你页面中的请求fetch('/api/userdata/')就会转发到proxy中的地址

也就是真实的请求是http://0.0.2.89:7300/api/userdata/，而且也不会有跨域问题

因为在浏览器看来，你只是发了fetch('/api/userdata/')，没有跨域问题

二、添加多个代理
在package.json中加入

```js
"proxy": {
   "/api": {
     "target": "http://localhost:8000",
     "changeOrgin": true
   },
    "/app": {
     "target": "http://localhost:8001",
     "changeOrgin": true
   }
},
```

使用方法

axios.post('/api/users').then(res =>{
    console.log(res)
})
但是当重新执行npm start时会报错，说"proxy"的值应该是一个字符串类型，而不能是Object。

其原因是由于react-scripts模块的版本过高，需要删除到原目录下node_modules中的react-scripts文件夹，安装低版本

npm install react-script@1.1.1 --save
的确跨域问题可以解决了，但是又出现了新的问题，我在项目中使用了sass，当把react-scripts改为低版本后并不支持对sass的解析，如果要想支持sass的话，需要到 node_modules/react-scripts/config中进行配置，但是并不推荐你这样做。

三、最佳推荐
下载 http-proxy-middleware

npm i http-proxy-middleware --save
创建 src/setupProxy.js

```js
const proxy = require('http-proxy-middleware')

module.exports = function(app) {
  // /api 表示代理路径
  // target 表示目标服务器的地址
  app.use(
    proxy('/api', {
    // http://localhost:4000/ 地址只是示例，实际地址以项目为准
      target: 'http://localhost:4000',
      // 跨域时一般都设置该值 为 true
      changeOrigin: true,
      // 重写接口路由
      pathRewrite: {
        '^/api': '' // 这样处理后，最终得到的接口路径为： http://localhost:8080/xxx
      }
    })
  )
}
```

注意: 开发阶段, 可以配置webpack的反向代理, 解决跨域问题, 但是如果项目上线, 那么webpack的反向代理就失效了!!! 上线nginx 配置反向代理,由后台人员操作

## ES6新特性

**1. let const**

let 表示声明变量。const 表示声明常量

**let**

- 使用let，声明的变量仅在块级作用域内有效
- 不存在变量提升
- 暂时性死区：在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）



**const** 
const声明一个只读的常量。一旦声明，常量的值就不能改变。
const一旦声明变量，就必须立即初始化，不能留到以后赋值。
只在声明所在的块级作用域内有效，也是不提升，同样存在暂时性死区，也与let一样不可重复声明
const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。把一个对象定义为常量，但对象本身是可变的，所以依然可以为其添加新属性。

**2. 模块字符串``**

可以使用反引号````来进行字符拼接。${}

**3. 解构**

可以使用{}来对数组和对象进行解构。

{A:{B:C}} 连续解构赋值加重命名 => {A:{B:D}},重命名为D

**4. 函数的参数默认值**

function printText(text = 'default') {    console.log(text); }

**5. Spread / Rest 操作符...**

1.数组（扩展运算符）

（1）解构赋值
扩展运算符(spread)就是我们知道的三个点(...)，它就好像rest参数的逆运算，***将一个数组转为用逗号分隔的参数序列。***

（2）复制数组

（3）合并数组

2.对象

拓展运算符（...）用于**取出 \*参数对象\* 所有 \*可遍历属性\* 然后拷贝到当前对象。**
**基本用法**

合并对象

3.函数

不定参数用来表示不确定参数个数，形如，...变量名，由...加上一个具名参数标识符组成。**具名参数只能放在参数组的最后，并且有且只有一个不定参数。**
**基本用法**

```
function f(...values){
    console.log(values.length);
}
f(1,2);      //2
f(1,2,3,4);  //4
function f(x,y,z,v,w){
    console.log(x,y,z,v,w)
}
var args = [0,1,5];
var args1 = [0,1];
f(-1,...args,2,...[3]);//-1, 0, 1, 5, 2
f(-1,...args1,2,...[3]);//-1, 0, 1, 2, 3

```

**6. 箭头函数**

- 不需要 function 关键字来创建函数
- 省略 return 关键字
- this始终指向函数申明时所在作用域下的this值

**7. for of遍历数组**

for-in循环存在缺陷：循环会遍历对象自身的和继承的可枚举属性(不含Symbol属性)



1. for-of 无法遍历 不可迭代对象
2. for-of这个方法避开了for-in循环的所有缺陷
3. 与forEach()不同的是，它可以正确响应break、continue和return语句 

可迭代对象包括: Array，Map，Set，String，TypedArray，arguments等等



for-of 遍历的是值，for-in遍历的是key

- for of遍历的是键值对中的值
- for in遍历的是键值对中的键

**导入导出**

- 导入improt
- 导出export default

**promise**

Promise 用于更优雅地处理异步请求。

 **async/await**

比promise更好的解决了回调地狱

**Symbol**

ES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。

Symbol 函数栈不能用 new 命令，因为 Symbol 是原始数据类型，不是对象

**Set集合**

存储任何类型的唯一值，即集合中所保存的元素是不重复的。类数组结构。

```js
arr = [1,2,3,1]
let arrNew = new Set(arr)
arrNew = [1,2,3]
```

类数组不是数组，要转化为数组`Array.form(arrNew)`这样arrNew才是数组了

## Promise

**promise理解**

从语法上来说: Promise 是一个构造函数

从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/

失败的结果值

**解决问题**
- 回调地狱 ==> 链式调用形式

**三个状态**
- pending(默认)
- fulfilled(成功)
- rejected(失败)

**状态如何流转**
- resolve函数被执行时, 会将promise的状态从 pending 改成 fulfilled 成功
- reject函数被执行时, 会将promise的状态从pending 改成 rejected 失败

**Promise.all和Promise.race的区别和使用**

  Promise.all成功返回成功数组,

​        失败返回失败数据,一但失败就不会继续往下走

![64015903376](C:\Users\86187\AppData\Local\Temp\1640159033764.png)

**promise.race()**

Promise.race是赛跑的意思，也就是说Promise.race([p1, p2, p3])里面的结果哪个获取的快，就返回哪个结果，不管结果本身是成功还是失败

![64015909357](C:\Users\86187\AppData\Local\Temp\1640159093572.png)

**Promise.all和Promise.race都是有使用场景的。**
有些时候我们做一个操作可能得同时需要不同的接口返回的数据，这时我们就可以使用Promise.all；
有时我们比如说有好几个服务器的好几个接口都提供同样的服务，我们不知道哪个接口更快，就可以使用Promise.race，哪个接口的数据先回来我们就用哪个接口的数据。

**常见静态方法**

**promise.all([…promises])**

该方法提供了并行执行异步操作的能力，并且在所有异步操作执行完后并且执行结果都是成功的时候才执行回调。all接收一个数组参数，这组参数为需要执行异步操作的所有方法，里面的值最终都算返回Promise对象

all会把所有异步操作的结果放进一个数组中传给then，然后再执行then方法的成功回调将结果接收

- 执行时机
  - 什么时候走成功:所有成功走成功
  - 什么时候走失败；只要有一个失败就会走失败



**promise.race([…promises])**  

all是等所有的异步操作都执行完了再执行then方法，那么race方法就是相反的，谁先执行完成就先执行回调。先执行完的不管是进行了race的成功回调还是失败回调，其余的将不会再进入race的任何回调

**执行时机**
- 完全按照最快拿到结果的promise来决定结果

如果子promise全部是请求，请求会不会被执行

场景：
- 从最快的服务器检索资源

any([…promises])
- 执行时机
  - 只要有一个成功就走成功，全部失败走失败
  - 获取到的结果为成功的promise的结果

allSettled([…promises])
- 执行时机
  - 只要所有的promise结束都会fullfilled
  - 会获取到所有promise执行的结果以及状态


**5.3手写promise步骤**

1.（基本）resolve与reject函数实现=>添加属性PromiseState（pending等待、fulfilled成功、rejected失败）、PromiseResult存放接下来要处理的值（resolve和reject传进来的参数）为了接下来和.then方法共用

2.throw抛出异常错误要用try catch接一下，不然会报错，然后在用catch中用reject把错误处理成失败的结果

3.状态只能修改一次，就根据构造函数定义过的变量PromiseState判断是否为pending，是的话才能继续执行resolve和reject函数

4.then要定义在原型对象上，这样实例对象才能用过原型链访问到then方法

5.正常new promise实例对象和调用then方法是同步的，当promise中有异步任务执行时，then方法会先调用，这时就应该给promise指定成功和失败的事件，可以给promise构造函数中添加一个存放成功或失败回调函数的属性，等promise异步任务执行完再调用这个属性

6.then方法要返回一个promise对象，这时就要在then方法中return一个promise对象，返回的promise状态和值要根据实例对象传进来的是普通值还是promise函数，非Promise值直接返回状态成功，值的话有返回值就是返回值，没有返回值 值就是undfined，传进来的是promise函数就通过then方法进行递归，直到不是promise对象是普通值结束，将这个最终值传递给promise

7.promise的中的catch方法可以捕获异常进行异常穿透，核心原理是先在then方法判断是否是一个错误的值，是错误的值就直接throw错误的值给下一个then方法，因为try catch不会执行成功的回调 最后catth方法

捕获错误并输出

8.resolve、reject、all、race都是定义在构造函数上的静态方法（只能由构造函数Promise调用，不能由实例对象调用）

9.all就是返回一个新的 promise 对象, 只有 promises 中所有 promise 都产生成功 value 时, 才最终成功, 只要有一个失败就直接失败，我的方法是定义一个全部变量用来计数，成功一个变量就加一，直到变量值等于promise.all数组长度值时在执行成功的回调，有一个失败就直接执行失败的回调函数，因为有peeding判断，状态只能修改一次，最后会返回一个有这个失败的状态和值的promise，谁在数组前面最先失败就返回谁

10.race返回一个 promise，一旦某个 promise最先 成功或失败， 返回的 promise 就是成功或失败的，这个就是挨个执行，哪个执行的快就直接执行成功或失败的回调，因为有peeding判断，状态只能修改一次，最后会返回一个有这个失败的状态和值的promise



## async/await是什么？

- 概念：ES7 标准中新增的async函数，从目前的内部实现来说其实就是 Generator 函数的语法糖。(promise)

- 用法

  - async

    - 1. async 关键字用于声明⼀个异步函数（如 async function asyncTask1() {...}）

         1. async 会⾃动将普通函数转换成 Promise，返回值也是⼀个 Promise 对象

            .	async 函数内部可以使⽤ await

  - await

    - 1. await 用于等待异步的功能执⾏完毕 var result = await someAsyncCall()

         1. await 放置在 Promise 调⽤之前，会强制async函数中其他代码等待，直到 Promise 完成并返回结果

            .	await 只能与 Promise ⼀起使⽤

            .	await 只能在 async 函数内部使⽤

**async/await的内部实现**

generator结合了promise函数时，就出现了async/await

```
    const run = generator => {
        return new Promise((resolve, reject) => {
            const g = generator()
            const next = res => {
            //执行器，自动执行
            const result = g.next(res)
            //这里判断generator函数执行完毕没有；
            if (result.done) {
                return resolve(result.value)
            }
            //await后面跟的是可以是 Promise 对象和原始类型的值
            //这里设generator的value为一个promise对象；
            result.value
                .then(
                next,
                err => reject(gen.throw(err).value)
                )
            }
            next()
        })
        }

```

Promise函数中内置一个generator函数，这个generator函数在promise里面会立即自动执行，然后直到generator函数的done值为true，即执行到最后为止

async/await大概就是封装了generator和自动执行器函数的语法糖；
将generator 函数的星号（*）替换成 async，将 yield 替换成await



## es6的promise，async，await，Generator 函数有什么区别

**async 函数与 Promise、Generator 函数的比较**

 Promise 的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是 Promise 的 API（then、catch等等），操作本身的语义反而不容易看出来。

 Generator 函数语义比 Promise 写法更清晰，这个写法的问题在于，必须有一个任务运行器，自动执行 Generator 函数。

 Async 函数的实现简洁，最符合语义，几乎没有语义不相关的代码。

 它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。

 如果使用 Generator 写法，自动执行器需要用户自己提供。

**Generator函数**

Generator是协程在ES6的实现，最大的特点就是可以交出函数的执行权，懂得退让。

```jsx
function* gen(x) {
    var y = yield x +2;
    return y;
  }
  
  var g = gen(1);
  console.log( g.next()) // { value: 3, done: false }
  console.log( g.next()) // { value: undefined, done: true }
```

上面代码中，函数多了*号，用来表示这是一个Generator函数，和普通函数不一样，不同之处在于执行它不会返回结果，

返回的是指针对象g，这个指针g有个next方法，调用它会执行异步任务的第一步。
 对象中有两个值，value和done，value 属性是 yield 语句后面表达式的值，表示当前阶段的值，done表示是否Generator函数是否执行完毕。

下面看看Generator函数如何执行一个真实的异步任务

```jsx
var fetch = require('node-fetch');

function* gen(){
  var url = 'https://api.github.com/users/github';
  var result = yield fetch(url);
  console.log(result.bio);
}
```

```kotlin
var g = gen();
var result = g.next();

result.value.then( data => return data.json)
                  .then (data => g.next(data))
```

上面代码中，首先执行Generator函数，得到对象g，调用next方法，此时
 `result ={ value: Promise { <pending> }, done: false }`
 因为fetch返回的是一个Promise对象，（即value是一个Promise对象）所以要用then才能调用下一个next方法。

## JS数据类型和如何判断数据类型

**js** 中数据类型分为原始数据类型与引用数据类型

**基本数据类型**

- number
- string
- boolean
- null
- undefined
- symbol (ES6)
- bigint (ES10)

**引用数据类型**

- object

在引用数据类型 **object** 中包括**function**/**array**/**object**

看到这里我们可以发现总共是 **8** 种数据类型

**ES6新增：Symbol**

这种数据类型主要用于创建一个独一无二的标识

**ES10新增：Bigint**

JavaScript 中 `Number` 类型只能安全的表示`-(2^53-1)`至 `2^53-1` 范的值，即 `Number.MIN_SAFE_INTEGER` 至 `Number.MAX_SAFE_INTEGER`，超出这个范围的整数计算或者表示会丢失精度。****

为解决此问题，ES2020 提供一种新的数据类型：`BigInt`。使用 `BigInt` 有两种方式：

1. 在整数字面量后面加`n`。

```go
var bigIntNum = 9007199254740993n;
```

1. 使用 `BigInt` 函数。

```go
var bigIntNum = BigInt(9007199254740);
var anOtherBigIntNum = BigInt('9007199254740993');
```



**判断数据类型**

**1: typeof**

返回数据类型，包含这7种： number、boolean、symbol、string、object、undefined、function。

typeof null  返回类型错误，返回object

引用类型，除了function返回function类型外，其他均返回object。

其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型，没有错，但不是我们想要的结果。

```js
typeof ''; // string 有效
typeof 1; // number 有效
typeof true; //boolean 有效
typeof undefined; //undefined 有效
typeof null; //object 无效
typeof [] ; //object 无效
typeof new Function(); // function 有效
typeof new Date(); //object 无效
typeof new RegExp(); //object 无效
```

**2.instanceof**

instanceof 是用来判断 A 是否为 B 的实例对，表达式为：A instanceof B，如果A是B的实例，则返回true,否则返回false。 在这里需要特别注意的是：**instanceof检测的是原型**

```js
 console.log("123" instanceof String); //false
 console.log(new String("111") instanceof String); //true
 console.log(123 instanceof Number); //false
 console.log(false instanceof Boolean); //false
 console.log(NaN instanceof Number); //false
 console.log(bigIntNum instanceof BigInt); //false
 console.log(a instanceof Symbol); //false

 console.log(function fn() {} instanceof Function); //true
 console.log([] instanceof Array); //true
 console.log({} instanceof Object); //true
 console.log(new Date() instanceof Date); //true
```

**3.toString 这个是最完美的**

toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。

对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息

```js
console.log(Object.prototype.toString({})); //[object Object]
console.log(Object.prototype.toString.call("")); // [object String]
console.log(Object.prototype.toString.call(1)); // [object Number]
console.log(Object.prototype.toString.call(true)); // [object Boolean]
console.log(Object.prototype.toString.call(Symbol())); //[object Symbol]
console.log(Object.prototype.toString.call(undefined)); // [object Undefined]
console.log(Object.prototype.toString.call(null)); // [object Null]
console.log(Object.prototype.toString.call(new Function())); // [object Function]
console.log(Object.prototype.toString.call(new Date())); // [object Date]
console.log(Object.prototype.toString.call([])); // [object Array]
console.log(Object.prototype.toString.call(new RegExp())); // [object RegExp]
console.log(Object.prototype.toString.call(new Error())); // [object Error]
console.log(Object.prototype.toString.call(document)); // [object HTMLDocument]
console.log(Object.prototype.toString.call(window)); //[object Window] window 是全局对象 
```



## 什么是原型链?

**一、原型**

**概念**:  任何对象实例都有一个原型，也叫原型对象，这个原型对象由对象的内置属性_proto_指向它的构造函数的prototype指向的对象，即任何对象都是由一个构造函数创建的，但是不是每一个对象都有prototype，只有方法才有prototype

> ①所有`引用类型`都有一个`__proto__(隐式原型)`属性，属性值是一个普通的对象
> ②所有`函数`都有一个`prototype(原型)`属性，属性值是一个普通的对象
> ③所有`引用类型的__proto__`属性`指向`它`构造函数的prototype`
>
> ```
> var a = [1,2,3];
> a.__proto__ === Array.prototype; // true
> ```



> **二、原型链**
> 当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的proto隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的proto中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。
>
> ①一直往上层查找，直到到null还没有找到，则返回undefined
> ②Object.prototype.__proto__ === null
> ③所有从原型或更高级原型中的得到、执行的方法，其中的this在执行时，指向当前这个触发事件执行的对象

![img](https://cdn.nlark.com/yuque/0/2021/png/22330294/1639481664958-37912007-be80-4fc4-a933-256b13ae91ab.png)

## 实现继承的方法有什么?

**原型链继承**

![img](https://cdn.nlark.com/yuque/0/2021/png/22330294/1639484303503-222111c4-1847-4c0f-995b-14fc7dc5f6a9.png)

**构造函数继承**

![img](https://cdn.nlark.com/yuque/0/2021/png/22330294/1639484551859-7ea77883-a762-470a-8d82-b7270a1a778c.png)

**组合继承**

![img](https://cdn.nlark.com/yuque/0/2021/png/22330294/1639484850358-126e733f-d663-4848-b2fe-f1ff0cd1fcd7.png)

***

**ES6 extends继承**

- ****extends关键字
- 如果子类重写了constructor必须手动调用super()

## call和apply的区别?

call、apply 和 bind 的作用都是改变 this 的指向，

其中 call 和 apply 的区别在于它们传参的方式不同

call可以传多个形参，

而apply只能传一个数组形参。

而bind和call、apply的区别在于bind不会立即调用，而是返回一个函数对象，下次调用的时候才会执行,因此开发中一般用bind比较多

bind为什么下次调用的时候执行? 

是因为bind返回的是一个新的函数,是不用再去重新调用这个函数的,而这个函数只不过是改变了this指向 

## new操作符创建对象的四个步骤

- 创建一个空对象
- 将所创建对象的__proto__属性值设为构造函数的prototype的属性值
- 执行构造函数中的代码，构造函数中的this指向该对象
- 返回对象

## 在 script 标签上使用 defer 和 async 的区别是什么？

- 目标：defer 和 async 的使用, 可以用于提升网页性能
- 用法
  - ![](C:/WeChat%20Files/wxid_fa87xwx7dtox22/FileStorage/File/2021-12/%E5%89%8D%E7%AB%AF%E5%8A%A0%E5%BC%BA%E8%AF%BE.md/%E5%89%8D%E7%AB%AF%E5%8A%A0%E5%BC%BA%E8%AF%BE.md/assets/7AD5EB36-B960-4AB5-B9C9-0A5BA2E90A95.png)
- 区别
  - ![](C:/WeChat%20Files/wxid_fa87xwx7dtox22/FileStorage/File/2021-12/%E5%89%8D%E7%AB%AF%E5%8A%A0%E5%BC%BA%E8%AF%BE.md/%E5%89%8D%E7%AB%AF%E5%8A%A0%E5%BC%BA%E8%AF%BE.md/assets/F01F08B5-523E-42DA-AED0-A1C0EDF22A76.png)
    - 绿线：HTML 的解析时间
    - 蓝线：JS 脚本的加载时间
    - 红色：JS 脚本的执行时间
  - 共同点：加载脚本都是异步执行
  - 不同点
    - async: 立刻执行脚本
    - defer:会前面的defer脚本执行, 等dom的加载
- 作用：js脚本加上async或defer, 放在头部可以减少网页的下载加载时间
- 考察点：性能优化

## 什么是DOM事件流

![img](https://cdn.nlark.com/yuque/0/2021/png/22330294/1639487373739-fcc8eab4-63ce-4051-807e-d57c31cb2700.png)

- DOM事件流
  - 分为三个阶段
    - 捕获阶段
    - 目标阶段
    - 冒泡阶段
  - 在addeventListener()的第三个参数(useCapture)设为true，就会在捕获阶段运行，默认是false冒泡

## 什么是事件冒泡/捕获?

![img](https://cdn.nlark.com/yuque/0/2021/png/22330294/1639487317747-d0ba6d76-dac0-4570-a4dd-f7b25009412d.png)

## 事件委托

利用冒泡原理(子向父一层层穿透)，把事件绑定到父元素中，以实现事件委托

## js的垃圾回收机制?

**1. 概述**

JS的垃圾回收机制是为了以防内存泄漏，内存泄漏的含义就是当已经不需要某块内存时这块内存还存在着，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。

**什么是内存泄漏**

 内存泄露是指不再用的内存没有被及时释放出来，导致该段内存无法被使用就是内存泄漏

**为什么会导致的内存泄漏**

内存泄漏指我们无法在通过js访问某个对象，而垃圾回收机制却认为该对象还在被引用，因此垃圾回收机制不会释放该对象，导致该块内存永远无法释放，积少成多，系统会越来越卡以至于崩溃

**2. 变量的生命周期**

当一个变量的生命周期结束之后它所指向的内存就应该被释放。JS有两种变量，全局变量和在函数中产生的局部变量。局部变量的生命周期在函数执行过后就结束了，此时便可将它引用的内存释放（即垃圾回收），但全局变量生命周期会持续到浏览器关闭页面。

**3. JS垃圾回收方式**

JS执行环境中的垃圾回收器怎样才能检测哪块内存可以被回收有两种方式：标记清除（mark and sweep）、引用计数(reference counting)。

**3.1 标记清除（mark and sweep）**

- 垃圾回收机制获取根并标记他们，然后访问并标记所有来自它们的引用，然后在访问这些对象并标记它们的引用…如此递进结束后若发现有没有标记的(不可达的)进行删除，进入执行环境的不能进行删除

**3.2 引用计数(reference counting)**

- 当声明一个变量并给该变量赋值一个引用类型的值时候，该值的计数+1，当该值赋值给另一个变量的时候，该计数+1，当该值被其他值取代的时候，该计数-1，当计数变为0的时候，说明无法访问该值了，垃圾回收机制清除该对象

## 从一个url地址到最终页面渲染完成?发生了什么

> 当我们在 web浏览器的地址栏中输入 : `www.baidu.com`, 具体发生了什么 ?

```js
1. 首页对 www.baidu.com 这个网址进行DNS域名解析，得到对应的IP地址
2. 根据这个IP，找到对应的服务器，发起TCP的三次握手
3. 建立TCP连接后发起HTTP请求
4. 服务器响应HTTP请求，浏览器得到html代码
5. 浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）（先得到html代码，才能去找这些资源）
6. 浏览器对页面进行渲染呈现给用户
7. 服务器关闭TCP连接
```

**1.DNS解析:将域名地址解析为ip地址**

- 浏览器DNS缓存
- 系统DNS缓存
- 路由器DNS缓存
- 网络运营商DNS缓存

**2.TCP连接,TCP三次握手**

- 第一次握手:由浏览器发起,告诉服务器我要发起请求了
- 第二次握手:由服务器发起.告诉浏览器我要准备接收了,你赶紧发送吧
- 第三次握手:由浏览器发送,告诉服务器,我马上就发了,准备接收把

![64057305240](C:\Users\86187\AppData\Local\Temp\1640573052409.png)

![64057312999](C:\Users\86187\AppData\Local\Temp\1640573129995.png)

**3.发送请求**

- 建立TCP连接后发起HTTP请求

**4.接收响应**

- 服务器响应HTTP请求，浏览器得到html代码

**5.渲染页面**

浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）（先得到html代码，才能去找这些资源）

浏览器对页面进行渲染呈现给用户

- 遇见HTML标记,浏览器用HTML解析器解析成Token并构建成dom树
- 遇见style/link标记,浏览器调用css解析器,处理css标记并构建cssom树
- 遇见sript标记,调用javascript解析器,处理script代码(绑定事件,修改dom树/cssom树)
- 将dom树和cssom树合并成一个渲染树
- 根据渲染树来计算布局,计算每个节点的几何信息(布局)
- 将各个节点颜色绘制到屏幕上(渲染)

**6.服务器关闭TCP连接:TCP四次挥手**

- 第一次挥手:由浏览器发起的,发送给服务器,我东西发送完了(请求报文),你准备关闭吧
- 第二次挥手:由服务器发起的,告诉浏览器,我都系接收完了(请求报文),我准备关闭了,你也准备吧
- 第三次挥手:由服务器发起,告诉浏览器,我东西发送完了(响应报文),你准备关闭吧
- 第四次挥手:由浏览器发起,告诉服务器,我东西接收完了,我准备关闭了(响应报文),你也准备吧

![64057317590](C:\Users\86187\AppData\Local\Temp\1640573175907.png)

![64057323190](C:\Users\86187\AppData\Local\Temp\1640573231904.png)

## http和https

http 明文传输

https 加密传输

**1、为什么需要HTTPS？**

HTTPS 是安全版的 HTTP。

HTTP 协议在传输数据时采用的是明⽂方式传递，因此，⼀些敏感信息的传输就变得很不安全。

> 而 HTTPS 就是为了解决 HTTP 的不安全⽽产⽣的。(明文传输)

**2、HTTPS是如何保证安全的？**

HTTPS 在传输数据的过程中会对数据进行加密处理，保证安全性。

那HTTPS采用的什么样的加密方式呢？我们来了解下一些加密的基本概念。

目前常见的加密算法可以分成三类，对称加密算法，非对称加密算法和Hash算法。

hash算法 ==> 不能被反向解密

**3、什么是对称加密？**

对称加密的特点是文件加密和解密使用相同的密钥，即加密密钥也可以用作解密密钥，

这种方法在密码学中叫做对称加密算法，对称加密算法使用起来简单快捷，密钥较短，且破译困难

通信的双⽅都使⽤同⼀个秘钥进⾏加解密。⽐如，两个人事先约定的暗号，就属于对称加密。



![img](http://weldon.flywen.top/image/20210527233628.png)

对称加密的特点是：

- 优点:
  计算量小、加密速度快、加密效率高。 
- 缺点:
  在数据传送前，发送方和接收方必须商定好秘钥，然后双方保存好秘钥。
  如果一方的秘钥被泄露，那么加密信息也就不安全了

使用场景：本地数据加密、https通信、网络传输等

常见算法：AES、DES、3DES、DESX、Blowfish、IDEA、RC4、RC5、RC6

**4、什么是非对称加密？**

传输密钥

而加密和解密其实可以使用不同的规则，只要这两种规则之间存在某种对应关系即可，

这样就避免了直接传递密钥。这种新的加密模式被称为"非对称加密算法"。

通信的双方使用不同的秘钥进行加密解密，即秘钥对（私钥 + 公钥）。

特征: 私钥可以解密公钥加密的内容,  公钥可以解密私钥加密的内容

![img](http://weldon.flywen.top/image/20210527234705.png)

非对称加密的特点是：

- 优点：非对称加密与对称加密相比其安全性更好 
- 缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。 

使用场景：https会话前期、CA数字证书、信息加密、登录认证等

常见算法：RSA、ECC（移动设备用）、Diffie-Hellman、El Gamal、DSA（数字签名用）

**HTTPS 加密解决方案**

结合了两种加密⽅式：

- 将 `对称加密的密钥` ⽤非对称加密的公钥, 进⾏加密并发送出去，接收⽅使⽤私钥解密得到 `对称加密密钥` 
- 双⽅沟通时使⽤ `对称加密密钥` 进⾏ 

**可以看到，只有在发送秘钥阶段才使用非对称加密，而后续的通信都使用对称加密，这样解决了性能问题。**

HTTPS 目前所使用的 TLS或SSL协议,  就是目前采用的加密通道的规范协议

它利用对称加密、(公私钥)非对称加密, 以及其密钥交换算法，可完成可信任的信息传输

**6、数字证书**

为了安全性, 一般还需要签发数字证书!

客户端 和 服务器端要初步互通消息时,  客户端发送请求可以拿到公开的公钥信息

进而进行非对称加密, 使用公钥, 加密`对称加密密钥`, 传递给服务器, 后续通信都使用对称加密!

![img](http://weldon.flywen.top/image/20210527235153.png)



**问题是: 初步互通消息时, 如果请求拿到的公钥信息, 就是假的, 或者不安全的! 那么后续的所有操作, 都将是不安全的!**

所以, 就需要有数字证书(CA证书),  一般是CA机构颁发的, 证明这个公钥是安全可靠的!

**CA证书中心会对你网站的公钥, 网站的域名地址,  证书到期时间, 等一些相关信息一起加密签发数字证书, 保证你网站的安全性**

![img](http://weldon.flywen.top/image/20210527233637.png)



当公司申请了 CA 证书后, 就应该在响应时, 将数字证书一起发送给客户端



![img](http://weldon.flywen.top/image/20210527233641.png)



而客户端, 接收到消息后, 就可以查看证书

1. 如果正在访问的网站 和 证书记载的网址 不一致, 说明不安全,  可能被冒用, 浏览器就会发出警告!!! 
2. 如果签发证书的机构, 不权威, 发出警告
   ![img](http://weldon.flywen.top/image/20210527233644.png) 
3. 如果证书过期了, 浏览器也会发出警告 

**7、数字签名**

但这还是有问题：如果证书被篡改了怎么办?

这时就需要用⼀个技术：**数字签名**。 (根据证书内容, 生成的一个唯一标识)

数字签名就是先⽤ **CA ⾃带的 Hash 算法来计算出证书内容的⼀个摘要**，然后使⽤ CA 私钥进行加密，组成数字签名。

当别⼈把他的证书发过来时，**接收方⽤同样的算法再次⽣成摘要**，⽤ CA 公钥解密后得到CA生成的摘要，两者进行对⽐后,

就能确定中间是否被⼈篡改。这样就能最⼤程度的保证通信的安全了。

## http状态码

**1XX：通知**

1XX系列响应代码仅在与HTTP服务器沟通时使用。

**2XX: 成功**

2XX系列响应代码表明操作成功了。

**3XX 重定向**

3XX系列响应代码表明：客户端需要做些额外工作才能得到所需要的资源。它们通常用于GET请求。他们通常告诉客户端需要向另一个URI发送GET请求，才能得到所需的表示。那个URI就包含在Location响应报头里。

- 301永久重定向
- 302临时重定向
- 304表示可以在缓存中取数据(协商缓存)

**4XX：客户端错误**

这些响应代码表明客户端出现错误。不是认证信息有问题，就是表示格式或HTTP库本身有问题。客户端需要自行改正。

- 403跨域
- 404请求资源不存在

**5XX 服务端错误**

这些响应代码表明服务器端出现错误。一般来说，这些代码意味着服务器处于不能执行客户端请求的状态，此时客户端应稍后重试。有时，服务器能够估计客户端应在多久之后重试。并把该信息放在Retry-After响应报头里。

**常见状态码**

- 200 - 请求成功
- 301 - 资源（网页等）被永久转移到其它URL
- 400("Bad Request")
  客户端方面的问题。实体主题中的文档（若存在的话）是一个错误消息。希望客户端能够理解此错误消息，并改正问题。
- 404 - 请求的资源（网页等）不存在
- 404("Not Found") 和410("Gone")
  当客户端所请求的URI不对应于任何资源时，发送此响应代码。404用于服务器端不知道客户端要请求哪个资源的情况；410用于服务器端知道客户端所请求的资源曾经存在，但现在已经不存在了的情况。
- 409("Conflict")
  当客户端试图执行一个”会导致一个或多个资源处于不一致状态“的操作时，发送此响应代码。
- 500 - 内部服务器错误

## git

**新增文件的命令**：git add file或者git add .
提交文件的命令：git commit –m或者git commit –a
查看工作区状况：git status –s
拉取合并远程分支的操作：git fetch/git merge或者git pull

```
git fetch是将远程主机的最新内容拉到本地，用户在检查了以后决定是否合并到工作本机分支中。

而git pull 则是将远程主机的最新内容拉下来后直接合并，即：git pull = git fetch + git merge，这样可能会产生冲突，需要手动解决。查看提交记录命令：git reflog

```

拉取远程仓库的子分支   git pull +子分支名称

创建本地分支：$ git branch [name] ----注意新分支创建后不会自动切换为当前分支

切换分支：$ git checkout [name]

创建新分支并立即切换到新分支：$ git checkout -b [name]

删除分支：$ git branch -d [name] ---- -d选项只能删除已经参与了合并的分支，对于未有合并的分支是无法删除的。如果想强制删除一个分支，可以使用-D选项

合并分支：$ git merge [name] ----将名称为[name]的分支与当前分支合并

创建远程分支(本地分支push到远程)：$ git push origin [name]

删除远程分支：$ git push origin :heads/[name] 或 $ gitpush origin :[name] 

如果想撤销提交到索引区的文件，可以通过git reset HEAD file；

如果想撤销提交到本地仓库的文件，可以通过**git reset –soft HEAD^n**恢复当前分支的版本库至上一次提交的状态，索引区和工作空间不变更；

可以通过**git reset –mixed HEAD^n**恢复当前分支的版本库和索引区至上一次提交的状态，工作区不变更；

可以通过**git reset –hard HEAD^n**恢复当前分支的版本库、索引区和工作空间至上一次提交的状态。

**改写提交**：git commit --amend

**版本回退操作，可以使用如下两种方法：**

方法1： **git reset –hard HEAD ^**   ( ^ 表示回到上一个版本，如果需要回退到上上个版本的话，将HEAD^改成HEAD^^, 以此类推。那如果要回退到前100个版本，这种方法肯定不方便，我们可以使用简便命令操作：git reset –hard HEAD~100 );

方法2 ：**git reset –hard** 版本号 ，但是现在的问题是加入我已经关掉了命令行或者第三个版本的版本号，我并不知道？那么要如何知道第三个版本的版本号呐。可以通过如下命令获取到版本号： git reflog    演示如下：



通过上面的显示我们可以知道，第三个版本的版本号是 e12928c  那么现在我们可以通过命令： git reset –hard e12928c

我们可以看到文件回到第三个版本了。




**1.提交时发生冲突，你能解释冲突是如何产生的吗？你是如何解决的？**
		开发过程中，我们都有自己的特性分支，所以冲突发生的并不多，但也碰到过。诸如公共类的公共方法，我和别人同时修改同一个文件，他提交后我再提交就会报冲突的错误。

答：当遇到多人协作修改同一个文件时出现冲突，我先将远程文件先git pull下来，手动修改冲突代码后，再git add ,git commit,git push再上传到远程仓库。如果pull也pull不下来提示冲突的话，可以先通过git stash暂存下来，然后再pull拉取，然后git  stash pop，取出原来写的，手动修改，然后提交

​	通过git stash命令，把工作区的修改提交到栈区，目的是保存工作区的修改；
​	通过git pull命令，拉取远程分支上的代码并合并到本地分支，目的是消除冲突；
​	通过git stash pop命令，把保存在栈区的修改部分合并到最新的工作空间中；

**如果本次提交误操作，如何撤销？**
如果想撤销提交到索引区的文件，可以通过git reset HEAD file；如果想撤销提交到本地仓库的文件，可以通过git reset –soft HEAD^n恢复当前分支的版本库至上一次提交的状态，索引区和工作空间不变更；可以通过git reset –mixed HEAD^n恢复当前分支的版本库和索引区至上一次提交的状态，工作区不变更；可以通过

**git reset –hard HEAD^n**

恢复当前分支的版本库、索引区和工作空间至上一次提交的状态。

**你使用过git stash命令吗？你一般什么情况下会使用它？**
命令git stash是把工作区修改的内容存储在栈区。
以下几种情况会使用到它：

解决冲突文件时，会先执行git stash，然后解决冲突；
遇到紧急开发任务但目前任务不能提交时，会先执行git stash，然后进行紧急任务的开发，然后通过git stash pop取出栈区的内容继续开发；
切换分支时，当前工作空间内容不能提交时，会先执行git stash再进行分支切换；

**能不能说一下git fetch和git pull命令之间的区别？**
简单来说：git fetch branch是把名为branch的远程分支拉取到本地；而git pull branch是在fetch的基础上，把branch分支与当前分支进行merge；因此pull = fetch + merge合并分支冲突怎么解决?

**手动解决**

查看完了冲突之后当然是解决冲突，最简单的方法将去做手动合并。手动合并的方法很简单，就是我们选择我们要保留的代码，然后再把>>>>>, ======, <<<<<<这些提示行给去掉。最后重新add commit。

![1641351871866](C:\Users\86188\AppData\Roaming\Typora\typora-user-images\1641351871866.png)

**git代码回退**

有时候我们用git提交代码后发生了错误，代码冲突了啊等等，我们需要将代码回到以前的某个版本

git代码回退有两种办法

**一、git reset（推荐）：**

它是将最新的commit删除，用以前的某个版本的代码替代最新的代码，这里我们测试下

![img](https://images2015.cnblogs.com/blog/1117682/201706/1117682-20170611205104122-722130298.png)

 

 这里有很多的commit，我现在想将代码退回到第三个commit的时候,如果是用git命令，在项目的根目录就是有.git隐藏文件的目录,右击打开黑窗口

git reset --hard d83053a1a3ad6e169300b70a1f38b8b3d13d8576(这里是commit的标识)

执行完我们就回到了这个版本的代码，我们的本地代码，head什么的都改过来了，不过远程仓库的代码没有改过来，这个时候我们需要用

git push -f origin dev        //强行推送我们的代码，用我们现在的代码完全覆盖远程仓库的代码，正常推送会有冲突，这里不会有什么冲突的

如果我们用tortoise git（乌龟git）界面化git，我们右击项目点开show log

![img](https://images2015.cnblogs.com/blog/1117682/201706/1117682-20170611210052700-1858159779.png)

 

 找到我们的某次提交，右击选择reset dev to this...,选择hard

![img](https://images2015.cnblogs.com/blog/1117682/201706/1117682-20170611210231997-1788005284.png)

 

 确定后本地就已经改过来了，右击项目push代码，勾选unknown changes（就是强制推送代码的意思）

![img](https://images2015.cnblogs.com/blog/1117682/201706/1117682-20170611210758450-322887686.png)

 

远程仓库的也改过来了

![img](https://images2015.cnblogs.com/blog/1117682/201706/1117682-20170611210615668-978398602.png)

这里就会发现我们以前的commit不见了，我们想要恢复到的第三个commit上来了，成了最新的commit

**二、git revert**

 这种方法是在已有代码的基础上面，再做一次commit，不过这个commit是对某次commit的反向操作,如果我们做错了某次提交，我们可以再做一次反向的提交，就可以回到上一个版本的代码了

不过这个方式我不太喜欢，退回到上一个版本还好，如果想要退回到以前的某个版本很有可能就会冲突了，而且提交的时候也会比较麻烦,这里记录下：

现在我要把git的代码回退，revert操作用tortoise git（乌龟git）好像不太好用，点击revert经常上面都没有，这里就记录下用git命令怎么做：

在项目的根目录右击，打开黑窗口，输入:

git revert d83053a1a3ad6e169300b70a1f38b8b3d13d8576(最新的commit标识)

我们会发现来到了个黑窗口，我们需要在最下面输入提交的message，随便写些什么都可以

![img](https://images2015.cnblogs.com/blog/1117682/201706/1117682-20170611211657465-1261067809.png)

 

写一些东西后，按ESC，然后同时按shift+;  ，输入wq，回车就可以了（这完全就是linux命令）

 这个时候我们本地的代码也已经改过来了，然后我们需要将代码提交到git远程仓库，我们先pull，再push（不用先commit了，这其实做的就是一次commit操作，不过做的是某个反向的commit功能），然后我们远程的代码也改过来了

![img](https://images2015.cnblogs.com/blog/1117682/201706/1117682-20170611212620325-373902457.png)



## 宏任务和微任务、eventLoop

概念

- 同步任务和异步任务会分别进入不同的执行环境，同步的会进入主线程，就是主执行栈，异步的会进入任务队列。主线程内的任务执行完毕空了，就会去任务队列读取对应的任务，推到主线程执行。 这个过程的不断重复就是我们说的 Event Loop (事件循环)。

**运行机制**

在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：

- 执行一个宏任务（栈中没有就从事件队列中获取）
- 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
- 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
- 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
- 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

如图：

![img](https://pic2.zhimg.com/80/v2-e6dd78c74cb671dd9408c2273308a265_720w.jpg)

![63988134320](C:\Users\86187\AppData\Local\Temp\1639881343204.png)

**1.JavaScript是一门单线程语言。**
**2.Event Loop(事件循环)是JavaScript的执行机制。**

![img](https://upload-images.jianshu.io/upload_images/15216392-569f354ffa11d9ec.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

![img](https://images2018.cnblogs.com/blog/1424035/201807/1424035-20180717204025092-991427971.png)****

## http缓存

- 缓存分类
  - web服务缓存
    - 数据库缓存、服务器端缓存（代理服务器缓存、CDN 服务器缓存
  - 浏览器缓存
    - HTTP 缓存、indexDB、cookie、localstorage
- 几个专业术语
  - 缓存命中率：从缓存中得到数据的请求数 与 所有请求数的比率。理想状态是越高越好。 (看所有的请求中, 多少从缓存中读的)
  - 过期内容：超过设置的有效时间，被标记为“陈旧”的内容。
  - 验证：验证缓存中的过期内容是否仍然有效，验证通过的话刷新过期时间。
  - 失效：失效就是把内容从缓存中移除。
- http缓存
  - 请求流程
    - 1.浏览器先根据这个资源的 http头信息 来 判断是否命中强缓存。 如果命中则直接加载在缓存中的资源，并不会将请求发送到服务器。（强缓存）
    - 2.如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。 服务器来判断浏览器本地缓存是否失效。 若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。（协商缓存）
    - 3.如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。（新的请求）
  - 分类
    - 强缓存
      - Expires
        - 指定一个具体时间(2020年12月12日 17:00), 到了这个时间了, 缓存过期了, 在时间内, 都是有效的, 可以直接读
        - 缺点：由于失效时间是一个绝对时间，所以当服务端和客户端差距很大以后，就会导致缓存混乱
      - cache-control(优先级更高)
        - 概念：指定一个过期时间 (3600s), 这个资源你加载到后, 可以用 3600s，拥有更高的优先级
        - 比较特点：只是跟客户端时间进行比较，不会出现时间偏差导致缓存错误的问题
        - 组成的属性
          - max-age：指定一个时间长度，在这个时间段内缓存是有效的，单位是s。
          - no-cache 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证的请求到服务器, 问服务器是否可以读缓存。不是字面意思上的不缓存。 
          - no-store 禁止所有缓存，每次请求都要向服务器重新获取数据。
    - 协商缓存
      - 服务器根据http头信息中的Last-Modify/If-Modify-Since或Etag/If-None-Match来判断是否命中协商缓存。
      - 第一次请求
        - ![](C:\WeChat Files\wxid_fa87xwx7dtox22\FileStorage\File\2021-12\前端加强课.md\前端加强课.md\assets\7B226A74-A6DA-497D-AE7C-EB8A770D32DE.png)
      - 后续请求
        - ![](C:\WeChat Files\wxid_fa87xwx7dtox22\FileStorage\File\2021-12\前端加强课.md\前端加强课.md\assets\C20C06AA-3393-4C56-834B-18F5B8F3BF48.png)
    - 总结
      - 强缓存: 检查过期时间, 判断缓存是否失效, 如果不失效, 直接用, 不发请求 大大的减少了 服务器的请求次数, 在过期时间内, 直接从客户端内存中读
      - 协商缓存: 强缓存命中失效了, 超过过期时间了, 拿着标识(最后的修改时间, 唯一标识etag), 去问服务器, 是否真的过期了 如果验证通过, 服务器会直接响应 304, 且不会返回资源

## 强缓存和协商缓存

![img](https://images2015.cnblogs.com/blog/408483/201605/408483-20160525182943272-204994049.png)

从上图可以知道，浏览器缓存包含两种类型，即强缓存（也叫本地缓存）和协商缓存，浏览器在第一次请求发生后，再次请求时：

- 浏览器在请求某一资源时，会先获取该资源缓存的header信息，判断是否命中强缓存（cache-control和expires信息），若命中直接从缓存中获取资源信息，包括缓存header信息；本次请求根本就不会与服务器进行通信；在firebug下可以查看某个具有强缓存资源返回的信息，例如本地firebug查看的一个强缓存js文件
- 如果没有命中强缓存，浏览器会发送请求到服务器，请求会携带第一次请求返回的有关缓存的header字段信息（Last-Modified/If-Modified-Since和Etag/If-None-Match），由服务器根据请求中的相关header信息来比对结果是否协商缓存命中；若命中，则服务器返回新的响应header信息更新缓存中的对应header信息，但是并不返回资源内容，它会告知浏览器可以直接从缓存获取；否则返回最新的资源内容

**（一）、强缓存**

强缓存主要包括 `expires` 和 `cache-control`。

**1、expires**

当我们请求一个资源，服务器返回时会带有一个 `expires` 字段表示资源的过期时间。

它是一个**时间戳**（准确点应该叫格林尼治时间），当客户端再次请求该资源的时候，会把客户端时间与该时间戳进行对比，如果大于该时间戳则已过期，否则直接使用该缓存资源。

但是，有个大问题，

发送请求时是使用的**客户端时间**去对比。

一、是客户端和服务端时间可能快慢不一致，

二、是客户端的时间是可以自行修改的（比如浏览器是跟随系统时间的，修改系统时间会影响到），所以不一定满足预期。

**2、cache-control**

所以当 `cache-control` 和 `expires` 都存在时，`cache-control` 优先级更高。该字段是一个时间长度，单位秒，表示该资源过了多少秒后失效。当客户端请求资源的时候，发现该资源还在有效时间内则使用该缓存，它**不依赖客户端时间**

**3.pragma**

他的值有 `no-cache` 和 `no-store`，表示意思同 `cache-control`，优先级高于 `cache-control` 和 `expires`，即三者同时出现时，先看 `pragma` -> `cache-control` -> `expires`。

**（二）、协商缓存**

如果没有命中强缓存，浏览器会发送请求到服务器，验证资源是否更新，如果没更新才继续使用本地缓存，此时返回的是 304，这就是协商缓存。协商缓存主要包括 `last-modified` 和 `etag`。

**1、last-modified**

last-modified` 记录资源最后修改的时间。启用后，请求资源之后的响应头会增加一个 `last-modified

服务端会对比该字段和资源的最后修改时间，若一致则证明没有被修改，告知浏览器可直接使用缓存并返回 304；若不一致则直接返回修改后的资源，并修改 `last-modified` 为新的值。

但 `last-modified` 有以下两个缺点：

- 只要编辑了，不管内容是否真的有改变，都会以这最后修改的时间作为判断依据，当成新资源返回，从而导致了没必要的请求响应，而这正是缓存本来的作用即避免没必要的请求。
- 时间的精确度只能到秒，如果在一秒内的修改是检测不到更新的，仍会告知浏览器使用旧的缓存。

**2、etag**

为了解决 `last-modified` 上述问题，有了 `etag`。 `etag` 会基于资源的内容编码生成一串唯一的标识字符串，只要内容不同，就会生成不同的 `etag`。当再次请求该资源时，请求头会带有 `if-none-match` 字段，值是之前返回的 `etag` 值，服务端会根据该资源当前的内容生成对应的标识字符串和该字段进行对比，若一致则代表未改变可直接使用本地缓存并返回 304；若不一致则返回新的资源（状态码200）并修改返回的 `etag` 字段为新的值。

可以看出 `etag` 比 `last-modified` 更加精准地感知了变化，所以 `etag` 优先级也更高。不过从上面也可以看出 `etag` 存在的问题，就是每次生成标识字符串会增加服务器的开销

**访问刷新分析**

- 标签进入、输入url回车进入

  强缓存、协商缓存都生效

- 按刷新按钮、F5 刷新、网页右键“重新加载”

  强缓存过期、协商缓存生效

- ctrl + F5 强制刷新

  强缓存、协商缓存都失效



## 怎么判断一个变量是不是数组？

**1.instanceof操作符**

```
let arr = [1,2,3]
console.log(arr instanceof Array)  // true
```

**2.对象的constructor属性**

```
let arr = [1,2,3]
console.log(arr.constructor === Array) // true
```

**3.Object.prototype.toString.call()**

```
let arr = [1,2,3]
console.log(Object.prototype.toString.call(arr))  // [object Array]
```

**4.Array.isArray()**

```
let arr = [1,2,3]
console.log(Array.isArray(arr)) // true
```

## instanceof的原理是什么如何实现?

instanceof 可以正确的判断对象的类型，
因为内部机制是通过判断对象的原型链
中是不是能找到类型的 prototype。

## 防抖

**防抖**: 当事件被触发后,延迟n秒后再执行回调,如果在这n秒内事件又被触发,则重新计时  (回城)

应用场景: 

1. scroll事件滚动触发

   2.搜索框输入查询

   3.表单验证

   4.按钮提交事件

   5.浏览器窗口缩放,resize事件

**手写防抖**

![img](https://cdn.nlark.com/yuque/0/2021/png/22330294/1639559097351-bb7c49af-f263-4f26-b77e-e756c53c57aa.png)



## 节流

**节流**：在 n 秒中无论事件事件触发多少次只执行一次函数

- 应用场景：
  - 编辑器语法校验
  - resize/scroll/touch/mouseove 事件
  - 表单输入联想

**手写节流**

![63958081271](C:\Users\86187\AppData\Local\Temp\1639580812719.png)    

![64043064322](C:\Users\86187\AppData\Local\Temp\1640430643227.png)

## 深拷贝浅拷贝

**浅拷贝：**创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。  

**深拷贝 :** 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象



**浅拷贝的实现方式**

- （1）for···in只循环第一层

  ```jsx
  // 只复制第一层的浅拷贝
  function simpleCopy(obj1) {
     var obj2 = Array.isArray(obj1) ? [] : {};
     for (let i in obj1) {
     obj2[i] = obj1[i];
    }
     return obj2;
  }
  var obj1 = {
     a: 1,
     b: 2,
     c: {
           d: 3
        }
  }
  var obj2 = simpleCopy(obj1);
  obj2.a = 3;
  obj2.c.d = 4;
  alert(obj1.a); // 1
  alert(obj2.a); // 3
  alert(obj1.c.d); // 4
  alert(obj2.c.d); // 4
  ```

  （2）Object.assign方法

  ```jsx
  var obj = {
      a: 1,
      b: 2
  }
  var obj1 = Object.assign(obj);
  obj1.a = 3;
  console.log(obj.a) // 3
  ```

  （3）直接用=赋值

  ```jsx
  let a=[0,1,2,3,4],
      b=a;
  console.log(a===b);
  a[0]=1;
  console.log(a,b);
  ```

  ![img](https:////upload-images.jianshu.io/upload_images/15037426-6a06b6f2ee711a5f.png?imageMogr2/auto-orient/strip|imageView2/2/w/248/format/webp)

**深拷贝的实现方式**

- （1）采用递归去拷贝所有层级属性

  ```jsx
  function deepClone(obj){
      let objClone = Array.isArray(obj)?[]:{};
      if(obj && typeof obj==="object"){
          for(key in obj){
              if(obj.hasOwnProperty(key)){
                  //判断ojb子元素是否为对象，如果是，递归复制
                  if(obj[key]&&typeof obj[key] ==="object"){
                      objClone[key] = deepClone(obj[key]);
                  }else{
                      //如果不是，简单复制
                      objClone[key] = obj[key];
                  }
              }
          }
      }
      return objClone;
  }    
  let a=[1,2,3,4],
      b=deepClone(a);
  a[0]=2;
  console.log(a,b);
  ```

  结果：

  

  ![img](https:////upload-images.jianshu.io/upload_images/15037426-66f503dd14d2bd0f.png?imageMogr2/auto-orient/strip|imageView2/2/w/407/format/webp)

  

  （2） 通过JSON对象来实现深拷贝

  缺点： 无法实现对对象中方法的深拷贝，会显示为undefined

  ```jsx
  function deepClone2(obj) {
    var _obj = JSON.stringify(obj),
      objClone = JSON.parse(_obj);
    return objClone;
  }
  ```

   （3）通过jQuery的extend方法实现深拷贝

  ```php
  var array = [1,2,3,4];
  var newArray = $.extend(true,[],array); // true为深拷贝，false为浅拷贝
  ```

  （4）lodash函数库实现深拷贝

  ```bash
  let result = _.cloneDeep(test)
  ```

  （6）手动实现深拷贝

  ```csharp
  let obj1 = {
     a: 1,
     b: 2
  }
  let obj2 = {
     a: obj1.a,
     b: obj1.b
  }
  obj2.a = 3;
  alert(obj1.a); // 1
  alert(obj2.a); // 3
  ```

  （7）如果对象的value是基本类型的话，也可以用Object.assign来实现深拷贝，但是要把它赋值给一个空对象

  ```jsx
  var obj = {
      a: 1,
      b: 2
  }
  var obj1 = Object.assign({}, obj); // obj赋值给一个空{}
  obj1.a = 3;
  console.log(obj.a)；// 1
  ```

  ![img](https:////upload-images.jianshu.io/upload_images/15037426-1c7b29547b2a8794.png?imageMogr2/auto-orient/strip|imageView2/2/w/332/format/webp)

  （8）用slice实现对数组的深拷贝

  ```jsx
  // 当数组里面的值是基本数据类型，比如String，Number，Boolean时，属于深拷贝
  // 当数组里面的值是引用数据类型，比如Object，Array时，属于浅拷贝
  var arr1 = ["1","2","3"]; 
  var arr2 = arr1.slice(0);
  arr2[1] = "9";
  console.log("数组的原始值：" + arr1 );
  console.log("数组的新值：" + arr2 );
  ```

  ![img](https:////upload-images.jianshu.io/upload_images/15037426-a412661f28396034.png?imageMogr2/auto-orient/strip|imageView2/2/w/341/format/webp)

  image.png

  （9）用concat实现对数组的深拷贝

  ```jsx
  // 当数组里面的值是基本数据类型，比如String，Number，Boolean时，属于深拷贝
  var arr1 = ["1","2","3"];
  var arr2 = arr1.concat();
  arr2[1] = "9";
  console.log("数组的原始值：" + arr1 );
  console.log("数组的新值：" + arr2 );
  // 当数组里面的值是引用数据类型，比如Object，Array时，属于浅拷贝
  var arr1 = [{a:1},{b:2},{c:3}];
  var arr2 = arr1.concat();
  arr2[0].a = "9";
  console.log("数组的原始值：" + arr1[0].a ); // 数组的原始值：9
  console.log("数组的新值：" + arr2[0].a ); // 数组的新值：9
  ```

  ![img](https:////upload-images.jianshu.io/upload_images/15037426-5f64889271b63ce7.png?imageMogr2/auto-orient/strip|imageView2/2/w/326/format/webp)

  （11）使用扩展运算符实现深拷贝

  ```jsx
  // 当value是基本数据类型，比如String，Number，Boolean时，是可以使用拓展运算符进行深拷贝的
  // 当value是引用类型的值，比如Object，Array，引用类型进行深拷贝也只是拷贝了引用地址，所以属于浅拷贝
  var car = {brand: "BMW", price: "380000", length: "5米"}
  var car1 = { ...car, price: "500000" }
  console.log(car1); // { brand: "BMW", price: "500000", length: "5米" }
  console.log(car); // { brand: "BMW", price: "380000", length: "5米" }
  ```

## 堆和栈

**js中的堆内存与栈内存**

在js引擎中对变量的存储主要有两种位置，**堆内存和栈内存**。

和java中对内存的处理类似，**栈内存**主要用于存储各种**基本类型的**变量，包括Boolean、Number、String、Undefined、Null，**以及对象变量的指针，这时候栈内存给人的感觉就像一个线性排列的空间，每个小单元大小基本相等。

![img](https://images2018.cnblogs.com/blog/461976/201808/461976-20180823211511434-1707579794.png)

**内存分配和垃圾回收**

一般来说栈内存线性有序存储，容量小，系统分配效率高。而堆内存首先要在堆内存新分配存储区域，之后又要把指针存储到栈内存中，效率相对就要低一些了。
垃圾回收方面，栈内存变量基本上用完就回收了，而推内存中的变量因为存在很多不确定的引用，只有当所有调用的变量全部销毁之后才能回收。

## loadsh常用API

原生用法
直接使用的API

**_.reject**
根据条件去除某个元素。

```js
var foo = [
    {id: 0, name: "aaa", age: 33},
    {id: 1, name: "bbb", age: 25}
]
var bar = _.reject(foo, ['id', 0])

//bar = [{id: 1, name: "bbb", age: 25}]
```

**_.pick**
根据第二个参数的key的数组，筛选第一个参数中的值并返回

```js
var foo = {id: 0, name: "aaa", age: 33}
var bar = _.pick(foo, ['name', 'age'])
//bar = {name: "aaa", age: 33}
**_.keys**
返回object中的所有key

var foo = {id: 0, name: "aaa", age: 33}
var bar = _.keys(foo)
//bar = ['id', 'name', 'age']
```

**_.cloneDeep**
深度拷贝，这个不用多说了吧，js中基础类型以外的类型，都会默认拷贝备份

```js
var bar = _.cloneDeep(foo)
```

**_.find**
查找数组

```js
var foo = [
    {id: 0, name: "aaa", age: 33},
    {id: 1, name: "bbb", age: 25}
]
var bar = _.find(foo, ['id', 0])
//bar = {id: 0, name: "aaa", age: 33}
```

注意一下如果没找到的话，会返回undefined，要处理一下

**_.keyBy**
以某个属性为键，将数组转为对象

```js
var foo = var foo = [
    {id: 0, name: "aaa", age: 33},
    {id: 1, name: "bbb", age: 25}
]
var bar = _.keyBy(foo, 'name')
//bar = {
//    aaa: {id: 0, name: "aaa", age: 33},
//    bbb: {id: 1, name: "bbb", age: 25}
//}
```

**_.filter**
根据条件过滤出符合条件的元素，返回新数组

```js
var foo = var foo = [
    {id: 0, name: "aaa", age: 33},
    {id: 1, name: "bbb", age: 25}
]
var bar = _.filter(foo, ['name', "aaa"])
//bar = {
//    aaa: {id: 0, name: "aaa", age: 33}
//}
```

**_.map**
从集合中挑出一个key，将其值作为数组返回

```js
var foo = var foo = [
    {id: 0, name: "aaa", age: 33},
    {id: 1, name: "bbb", age: 25}
]
var bar = _.map(foo, 'name')
//bar = ["aaa", "bbb"]
_.max/_.min/_.sum
数组中最大值、最小值、数组求和

var foo = [1, 2, 3, 4]
var bar = _.max(foo)
//bar = 4
bar = _.min(foo)
//bar = 1
bar = _.sum(foo)
//bar = 10
_.pad/_.padStart/_.padEnd
在两端、开头、末尾补齐字符

var foo = "helloworld"
var bar = _.pad(foo, 14, '-')
//bar = --helloworld--
bar = _.padStart(foo, 14, '-')
//bar = ----helloworld
bar = _.padEnd(foo, 14, '-')
//bar = helloworld----
```

**组合用法**
如果说上面是基础技能，那么下面奉上几个炫酷的组合技：

**选出json数组中id最大的一项**

```js
var foo = [
    {id: 0, name: "aaa", age: 33},
    {id: 1, name: "bbb", age: 25}
]
var bar = _.find(foo, ['id', _.max(_.map(foo, 'id'))])
// bar = {id: 1, name: "bbb", age: 25}
ps:也可以用maxBy某个key来代替
```

**更新json数组中某一项的值**

```js
var foo = [
    {id: 0, name: "aaa", age: 33},
    {id: 1, name: "bbb", age: 25}
]
let list = _.keyBy(foo, 'id')
list[0].name = "ccc"
var bar = _.map(list)
// bar = [
//    {id: 0, name: "ccc", age: 33},
//    {id: 1, name: "bbb", age: 25}
//]
```



# react部分

## react-hooks

### **useState**

(1). useState让函数组件也可以有state状态, 并进行状态数据的读写操作

(2). 语法: const [xxx, setXxx] = React.useState(initValue)  

 ![img](https://cdn.nlark.com/yuque/0/2021/png/22330294/1637631603129-5eda2409-cc8c-424e-b3ad-580792a7ebcc.png)

(3). useState()说明:

​        参数: 第一次初始化指定的值在内部作缓存                       

​        返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数

(4). setXxx()2种写法:

​        setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值

​      ![img](https://cdn.nlark.com/yuque/0/2021/png/22330294/1637631935714-ed814788-393d-47ea-8526-fafadb90e89c.png)

​        setXxx(value => newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值

​    ![img](https://cdn.nlark.com/yuque/0/2021/png/22330294/1637631889129-ad96f6cc-1130-4967-ae85-b52091cc3c54.png)

####  useState为什么不能放到条件语句里面？

**这是因为React通过单链表来管理Hooks。**

![在这里插入图片描述](https://img-blog.csdnimg.cn/345fad8ae0e74dd2912a10ae77018a25.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAY2FrZV9lYXQ=,size_20,color_FFFFFF,t_70,g_se,x_16)

update 阶段，每次调用 useState，链表就会执行 next 向后移动一步。如果将 useState 写在条件判断中，假设条件判断不成立，没有执行里面的 useState 方法，会导致接下来所有的 useState 的取值出现偏移，从而导致异常发生

### useEffect

(1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子)

(2). React中的副作用操作:

​        发ajax请求数据获取

​        设置订阅 / 启动定时器

​        手动更改真实DOM

(3). 语法和说明: 

​        useEffect(() => { 

​          // 在此可以执行任何带副作用操作

​          return () => { // 在组件卸载前执行

​            // 在此做一些收尾工作, 比如清除定时器/取消订阅等

​          }

​        }, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行

   useEffect接受两个参数：

- 第一个参数是函数（这里叫effect函数），它的作用是，在页面渲染后执行这个函数。因此你可以把ajax请求等放在这里执行；
- 第二个参数是一个数组，这里注意：
- useEffect的第二个参数可用于定义其依赖的所有变量。如果其中一个变量发生变化，则useEffect会再次运行。如果包含变量的数组为空，则在更新组件时useEffect不会再执行，因为它不会监听任何变量的变更

| 参数情况  |                             效果                             |                             注意                             |
| :-------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   不传    |              每次渲染后都执行清理或者执行effect              |       这可能会导致性能问题，比如两次渲染的数据完全一样       |
| 传空数组  |       只运行一次的 effect（仅在组件挂载和卸载时执行）        | 这就告诉 React 你的 effect 不依赖于 props 或 state 中的任何值，所以它永远都不需要重复执行 |
| 传[count] | React 将对前一次渲染的count和后一次渲染的count进行比较。若相等React 会跳过这个 effect， |                       实现了性能的优化                       |

#### **useEffect第二个参数不能是引用类型**

useEffect需要将此次渲染时，依赖中的值与上次渲染依赖中的值做对比， 如果结果为true， 表示两者一致，未发生改变，所以不需要再次渲染， 若结果为false，表示发生了改变，会重新调用执行函数。并且，useEffect的比较为浅比较，查阅资料之后发现是调用Object.is(arg1, arg2)，若参数为基本类型，则不会有问题，但是如果为引用类型， 则比较的是两者的地址，而非值， 即 : Object.is({a: 1}, {a: 1})的结果为false， 会再次调用执行函数，这就是依赖最好不要传入引用类型的原因，并且，如果在useEffect中修改了引用类型，则会引发无限渲染的问题


是因为在JavaScript中，`{} === {}`结果是false，`{a:1} === {a:1}`同样，由此造成了react以为两个值不同，就一直的渲染最终页面死循环

**结论：useEffect的不作为componentDidUnmount的话，传入第二个参数时一定注意：第二个参数不能为引用类型，引用类型比较不出来数据的变化，会造成死循环**

![64043211518](C:\Users\86187\AppData\Local\Temp\1640432115187.png)

#### 第二个参数是引用类型的解决方法

1.比较简单的方法是使用 ‘use-deep-compare-effect’ 这个库，它可以进行深比较，使用方法也很简单， import useDeepCompareEffect from ‘use-deep-compare-effect’ 之后用useDeepCompareEffect 替换掉 原有的 useEffect 即可。

2.用useRef也可以解决,不过在实际工作中主要用的是第一种方案

我们使用async / await从第三方API获取数据。如果你对async/await熟悉的话，你会知道，每个async函数都会默认返回一个隐式的promise。但是，useEffect不应该返回任何内容。这就是为什么会在控制台日志中看到以下警告：

> Warning: useEffect function must return a cleanup function or nothing. Promises and useEffect(async () => …) are not supported, but you can call an async function inside an effect

这就是为什么不能直接在useEffect中使用async函数，因此，我们可以不直接调用async函数，可以把箭头函数写成函数表达式



### useRef

1.useRef可以用来定义变量，这些变量更改之后不会引起页面重新渲染，比如分页获取数据时，存储页码。
2.useRef也可以用来区分初始渲染还是更新(通过current有没值，具体见示例库里的didOrUpdate.tsx)
3.在DOM节点上定义ref属性，通过.current就可以获取到该DOM元素

#### createRef 与 useRef 的区别

createRef 每次渲染都会返回一个新的引用，而 useRef 每次都会返回相同的引用。

作用：获取dom依赖关系

```jsx
function App() {
  let [value, setValue] = useState('')
  const inputRef = useRef();

  useEffect(
    () => {
    },
    [inputRef]
  )

  let handleSetValue = function (e) {
    setValue(e.target.value);
  }

  return <React.Fragment>
    <input
      ref={inputRef}
      value={value}
      onChange={handleSetValue}
    ></input>

  </React.Fragment>
}
```

### useContext

如果需要在组件之间共享状态，可以使用useContext()。

https://blog.csdn.net/weixin_43606158/article/details/100750602?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164049782816780366597444%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=164049782816780366597444&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-1-100750602.pc_search_insert_es_download_v2&utm_term=useContext&spm=1018.2226.3001.4187

![img](https://cdn.nlark.com/yuque/0/2021/png/22330294/1639210089520-b2f049f0-96e2-4f17-89eb-375013ff1186.png)

### useReducer

useReducer仅仅是useState的一种替代方案：

- 在某些场景下，如果state的处理逻辑比较复杂，我们可以通过useReducer来对其进行拆分；
- 或者这次修改的state需要依赖之前的state时，也可以使用；

单独创建一个reducer/test.js文件：

![img](https://cdn.nlark.com/yuque/0/2021/png/22330294/1638600771582-2f6e7552-7d52-4d84-90ef-b664ef058111.png)

![img](https://cdn.nlark.com/yuque/0/2021/png/22330294/1638600832448-c061f13f-67b6-43c1-8570-b58cbdd3398b.png)![img](https://cdn.nlark.com/yuque/0/2021/png/22330294/1638600857390-c2162366-64e5-4c07-8477-53da357060cc.png)

useReducer.js和useReducer1.js都引入了这个函数 并都使用了useReducers ,

数据是不会共享的，它们只是使用了相同的counterReducer的函数而已



### useCallback(缓存函数)useMemo(缓存值) 

**useMemo 和 useCallback进行性能优化**

`useMemo` 和 `useCallback` 接收的参数都是一样,第一个参数为回调 第二个参数为要依赖的数据

共同作用：
1.仅仅 `依赖数据` 发生变化, 才会重新计算结果，也就是起到缓存的作用。

两者区别：
1.`useMemo` 计算结果是 `return` 回来的值, 主要用于 缓存计算结果的值 ，应用场景如： 需要 计算的状态
2.`useCallback` 计算结果是 `函数`, 主要用于 [缓存函数](https://www.zhihu.com/search?q=缓存函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A188602024})，应用场景如: 需要缓存的函数，因为[函数式组件](https://www.zhihu.com/search?q=函数式组件&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A188602024})每次任何一个 state 的变化 整个组件 都会被重新刷新，一些函数是没有必要被重新刷新的，此时就应该缓存起来，提高性能，和减少资源浪费。

#### useCallback的使用场景

![64043373550](C:\Users\86187\AppData\Local\Temp\1640433735506.png)

![64043360980](C:\Users\86187\AppData\Local\Temp\1640433609808.png)

![64043362755](C:\Users\86187\AppData\Local\Temp\1640433627550.png)

#### useMemo的使用场景

![64043389175](C:\Users\86187\AppData\Local\Temp\1640433891750.png)

![64043392212](C:\Users\86187\AppData\Local\Temp\1640433922121.png)

### useSelector()

主要作用： 从`redux`的`store`对象中提取数据(`state`)

```
import React from 'react'
import { useSelector } from 'react-redux'

export const CounterComponent = () => {
  const counter = useSelector(state => state.counter)
  return <div>{counter}</div>
}
```



### useDispatch()

```
const dispatch = useDispatch()
```

主要作用：返回`Redux` `store`中对`dispatch`函数的引用

```
import React from 'react'
import { useDispatch } from 'react-redux'

export const CounterComponent = ({ value }) => {
  const dispatch = useDispatch()

  return (
    <div>
      <span>{value}</span>
      <button onClick={() => dispatch({ type: 'increment-counter' })}>
        Increment counter
      </button>
    </div>
  )
}

```

将回调使用`dispatch`传递给子组件时，建议使用来进行回调`useCallback`，因为否则，由于更改了引用，子组件可能会不必要地呈现。

```
import React, { useCallback } from 'react'
import { useDispatch } from 'react-redux'

export const CounterComponent = ({ value }) => {
  const dispatch = useDispatch()
  const incrementCounter = useCallback(
    () => dispatch({ type: 'increment-counter' }),
    [dispatch]
  )

  return (
    <div>
      <span>{value}</span>
      <MyIncrementButton onIncrement={incrementCounter} />
    </div>
  )
}

export const MyIncrementButton = React.memo(({ onIncrement }) => (
  <button onClick={onIncrement}>Increment counter</button>
))

```



### useLayoutEffect

useLayoutEffect看起来和useEffect非常的相似，事实上他们也只有一点区别而已：

- useEffect会在渲染的内容更新到DOM上后执行，不会阻塞DOM的更新；
- useLayoutEffect会在渲染的内容更新到DOM上之前执行，会阻塞DOM的更新；


下面通过一个案例来演示他们之间具体的区别

```
import React, { useState, useEffect } from 'react'

export default function UseLayoutEffect() {

  const [count,setCount] = useState(10)
  
  useEffect(()=>{
    if(count ===0){
      setCount(Math.random())
    }
  },[count])
  return (
    <div>
      <h2>数字:{count}</h2>
      <button onClick={e=>setCount(0)}>修改数字</button>
    </div>
  )
}
```

我们把count变成一个随机数， 虽然可以实现，但是当我们点击修改的时候其实是有一个闪烁的 因为它先把数字变为了0，再变成了随机数

但是当我们这样写把里面的useEffect换成了useLayoutEffect，页面就不会发生这个闪烁了，这个useLayoutEffect其实在开发中不太常用，一些特殊情况才会用

比如：

如果我们希望在某些操作发生之后再更新DOM,那么应该将这个操作放在useLayoutEffect

## 性能优化

**1.路由懒加载**

React.lazy(()=>import('组件路径'))  +   <Suspense>

![image-20211124215855297](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211124215855297.png)

![image-20211124215811440](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211124215811440.png)

​	![image-20211124215926021](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20211124215926021.png)

**2.图片懒加载**

 **一、什么是懒加载**

将图片src先赋值为一张默认图片，当用户滚动滚动条到可视区域图片的时候，再去加载后续真正的图片

如果用户只对第一张图片感兴趣，那剩余的图片请求就可以节省了

**二、为什么要引入懒加载**

懒加载（LazyLoad）是前端优化的一种有效方式，极大的提升用户体验。图片一直是页面加载的流浪大户，现在一张图片几兆已经是很正常的事，远远大于代码的大小。倘若一次ajax请求10张图片的地址，一次性把10张图片都加载出来，肯定是不合理的。

**三、懒加载实现的原理**

先将img标签中的src链接设置为空，将真正的图片链接放在自定义属性（data-src），当js监听到图片元素进入到可视窗口的时候，将自定义属性中的地址存储到src中，达到懒加载的效果。



**网页中有大量图片加载很慢 你有什么办法进行优化？**

图片懒加载，在图片未可视区域加一个滚动条事件，判断图片位置与浏览器顶端和页面的距离，如果前者小于后者，优先加载

长列表优化（长列表产生性能问题的元素：大量DOM节点的重绘和重排）：懒加载，react-virtualized（头条项目）

```react
import React from 'react';
import ReactDOM from 'react-dom';
import LazyLoad from 'react-lazyload';
import MyComponent from './MyComponent';

const App = () => {
  return (
    <div className="list">
      <LazyLoad height={200}>
        <img src="tiger.jpg" /> /*
                                  Lazy loading images is supported out of box,
                                  no extra config needed, set `height` for better
                                  experience
                                 */
      </LazyLoad>
      <LazyLoad height={200} once >
                                /* Once this component is loaded, LazyLoad will
                                 not care about it anymore, set this to `true`
                                 if you're concerned about improving performance */
        <MyComponent />
      </LazyLoad>
      <LazyLoad height={200} offset={100}>
                              /* This component will be loaded when it's top
                                 edge is 100px from viewport. It's useful to
                                 make user ignorant about lazy load effect. */
        <MyComponent />
      </LazyLoad>
      <LazyLoad>
        <MyComponent />
      </LazyLoad>
    </div>
  );
};

ReactDOM.render(<App />, document.body);
```

**3.antd组件按需加载**

**4.借助shouldComponentUpdate生命周期函数，避免无谓的组件的render函数的运行**

```react
shouldComponentUpdate(nextProps,nextState){

	return !this.state.data === nextState.data

}
```

**PureComponent**

`React.PureComponent`  , `React.PureComponent` 通过props和state的浅对比来实现 `shouldComponentUpate()`。如果对象包含复杂的数据结构(比如对象和数组)，他会浅比较，如果深层次的改变，是无法作出判断的，`React.PureComponent` 认为没有变化，而没有渲染视图。

解决办法：

```react
 <Text data={{ ...data }} />
```

无论组件是否是 `PureComponent`，如果定义了 `shouldComponentUpdate()`，那么会调用它并以它的执行结果来判断是否 `update`。在组件未定义 `shouldComponentUpdate()` 的情况下，会判断该组件是否是 `PureComponent`，如果是的话，会对新旧 `props、state` 进行 `shallowEqual` 比较，一旦新旧不一致，会触发渲染更新。



**useMemo 和 useCallback进行性能优化**

`useMemo` 和 `useCallback` 接收的参数都是一样,第一个参数为回调 第二个参数为要依赖的数据

共同作用：
1.仅仅 `依赖数据` 发生变化, 才会重新计算结果，也就是起到缓存的作用。

两者区别：
1.`useMemo` 计算结果是 `return` 回来的值, 主要用于 缓存计算结果的值 ，应用场景如： 需要 计算的状态
2.`useCallback` 计算结果是 `函数`, 主要用于 [缓存函数](https://www.zhihu.com/search?q=缓存函数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A188602024})，应用场景如: 需要缓存的函数，因为[函数式组件](https://www.zhihu.com/search?q=函数式组件&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"article"%2C"sourceId"%3A188602024})每次任何一个 state 的变化 整个组件 都会被重新刷新，一些函数是没有必要被重新刷新的，此时就应该缓存起来，提高性能，和减少资源浪费。

```react
//useMemo
export default function WithMemo() {
    const [count, setCount] = useState(1);
    const [val, setValue] = useState('');
    const expensive = useMemo(() => {
        console.log('compute');
        let sum = 0;
        for (let i = 0; i < count * 100; i++) {
            sum += i;
        }
        return sum;
    }, [count]);
 
    return <div>
        <h4>{count}-{expensive}</h4>
        {val}
        <div>
            <button onClick={() => setCount(count + 1)}>+c1</button>
            <input value={val} onChange={event => setValue(event.target.value)}/>
        </div>
    </div>;
}
```

```react
//useCallBack
import React, { useState, useCallback, useEffect } from 'react';
function Parent() {
    const [count, setCount] = useState(1);
    const [val, setVal] = useState('');
 
    const callback = useCallback(() => {
        return count;
    }, [count]);
    return <div>
        <h4>{count}</h4>
        <Child callback={callback}/>
        <div>
            <button onClick={() => setCount(count + 1)}>+</button>
            <input value={val} onChange={event => setVal(event.target.value)}/>
        </div>
    </div>;
}
 
function Child({ callback }) {
    const [count, setCount] = useState(() => callback());
    useEffect(() => {
        setCount(callback());
    }, [callback]);
    return <div>
        {count}
    </div>
}
```



## 单向数据流

react是单向数据流，数据通过props从父节点传递到子节点，如果父级的某个props改变了，react会重新渲染所有的子节点



## 合成事件与原生事件的区别

\1. 写法不同，合成事是驼峰写法，而原生事件是全部小写

\2. 执行时机不同，合成事全部委托到document上，而原生事件绑定到DOM元素本身

\3. 合成事件中可以是任何类型，比如this.handleClick这个函数，而原生事件中只能是字符串

## React.createElement

JSX的编译过程

![64049860257](C:\Users\86187\AppData\Local\Temp\1640498602572.png)

[React](https://so.csdn.net/so/search?from=pc_blog_highlight&q=React).createElement()： 根据指定的第一个参数创建一个React元素。

```
React.createElement(
  type,
  [props],
  [...children]
)

```

第一个参数是必填，传入的是似HTML标签名称，eg: ul, li
第二个参数是选填，表示的是属性，eg: className
第三个参数是选填, 子节点，eg: 要显示的文本内容

看如下demo:

```
写法一：

var child1 = React.createElement('li', null, 'one');
    var child2 = React.createElement('li', null, 'two');
    var content = React.createElement('ul', { className: 'teststyle' }, child1, child2); // 第三个参数可以分开也可以写成一个数组
      ReactDOM.render(
          content,
        document.getElementById('example')
      );

写法二：

var child1 = React.createElement('li', null, 'one');
    var child2 = React.createElement('li', null, 'two');
    var content = React.createElement('ul', { className: 'teststyle' }, [child1, child2]);
      ReactDOM.render(
          content,
        document.getElementById('example')
      );

```

在我们应用JSX进行开发的时候，其实它最终会转化成React.createElement…去创建元素。
下面就通过一个官网上的DEMO来实际的理解一下：

```
//JSX写法：

class Hello extends React.Component {
    render() {
        return <div>Hello, { this.props.toWhat }</div>
    }
}

ReactDOM.render(
    <Hello toWhat=‘world’>,
    document.getElementById(‘root’)
)

```

```
// 转化为原生JS后的写法

class Hello extends React.Component {
    render(){
        return React.createElement(‘div’,null, `Hello,${this.props.toWhat}`)
    }
}

ReactDOM.render(
    React.createElement(‘Hello’, { toWhat: ‘world’ }, null),
    document.getElementById(‘root’)
)

```

## React.PureComponent 

React.PureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true 注意:  只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false

## React.memo

React.memo 为高阶组件，它可以传入一个 React 组件作为参数。

作用：提升性能

React.memo会返回一个**纯化**(purified)的组件**MemoFuncComponent**，这个组件将会在JSX标记中渲染出来。当组件的参数props和状态state发生改变时，React将会检查前一个状态和参数是否和下一个状态和参数是否相同，如果相同，组件将不会被渲染，如果不同，组件将会被重新渲染。

## 受控组件和非受控组件

**受控组件**：值受到react控制的表单元素

```
class App extends React.Component {
    constructor(){
        super()
        this.inputChange = this.inputChange.bind(this)
    }
    state = {
        txt : ''
    }
    inputChange(e){
       this.setState({
           txt: e.target.value
       })
    }
    render(){
        console.log(this.state);
        
        return (
            <div>
                {/* 把state的值设置给输入框的value，绑定change事件，这样用户在输入内容的时候调用相应函数，在函数里面把当前设置的值赋值给state，从而达到数据的统一 */}
                <input type="text" value={this.state.txt} onChange={this.inputChange}/>
            </div>
        )
    }
}
ReactDOM.render(<App />,document.getElementById('root'))

```

**非受控组件**:表单组件没有value prop就可以称为非受控组件

- 调用 `React.createRef()` 方法创建ref对象

- 将创建好的 ref 对象添加到文本框中

- 通过ref对象获取到文本框的值

- ```
  class App extends React.Component {
      constructor(){
          super()
          
          //创建 ref
          this.txtRef = React.createRef()
      }
      // 获取文本框的值
      getTxt =() => {
          console.log(this.txtRef.current.value)
      }
      render(){
          return (
            <div>
              <input type ="text" ref={this.txtRef} />
              <button onClick ={this.getTxt}>获取值</button>
            </div>
          )
      }
  }

  ```

  

## 单页面应用程序(SPA)的优缺点

**优点:**  

- **良好的交互体验** : 单页面应用的内容的改变不需要重新加载整个页面,获取数据也是通过ajax异步获取,没有页面之间的切换 就不会出现"白屏现象:,页面显示流畅
- **减轻服务器压力**: 服务器只要出数据,不用管展示逻辑和页面合成

**缺点:**

- **首屏加载慢**:如果不对路由进行处理，在加载首页的时候，就会将所有组件全部加载，并向服务器请求数据，这必将拖慢加载速度                                                                                                                                                                                                                                                                    


- **解决方案：**用路由的懒加载	




## React 虚拟DOM

 virtul DOM 也就是虚拟节点。通过JS的Object对象模拟DOM中的真实节点对象，再通过特定的render方法将其渲染成真实的DOM节点。

生成vNode---->渲染成真实节点 --------->挂载到页面--------->diff比较

**为什么虚拟 dom 会提高性能?**

虚拟 dom 相当于在 js 和真实 dom 中间加了一个缓存，利用 dom diff 算法避免了没有必要的 dom 操作，从而提高性能

## Diff算法与虚拟DOM中key的作用

**Diff算法**：把树形结构按照层级分解，只比较同级元素，给列表结构的每个单元添加唯一的key值，方便比较

简单的说: key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用。   

详细的说: 当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】,                        

随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较，比较规则如下： 

a. 旧虚拟DOM中找到了与新虚拟DOM相同的key：                    

(1).若虚拟DOM中内容没变, 直接使用之前的真实DOM             

(2).若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM                

b. 旧虚拟DOM中未找到与新虚拟DOM相同的key，根据数据创建新的真实DOM，随后渲染到到页面      



**用index作为key可能会引发的问题：**                

\1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作                       

会产生没有必要的真实DOM更新 ==> 界面效果没问题, 但效率低。             

\2. 如果结构中还包含输入类的DOM                        

会产生错误DOM更新 ==> 界面有问题。         

\3. 注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，            

 仅用于渲染列表用于展示，使用index作为key是没有问题的。

\3. 开发中如何选择key

1.最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。           

2.如果确定只是简单的展示数据，用index也是可以的。



## 纯函数和高阶函数

**纯函数**

https://blog.csdn.net/c_kite/article/details/79138814

一个函数的返回结果**只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数**。

所谓纯函数，它是这样一种函数：**即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用**。****

为什么要煞费苦心地构建纯函数？因为纯函数非常“靠谱”，执行一个纯函数你不用担心它会干什么坏事，它不会产生不可预料的行为，也不会对外部产生影响。不管何时何地，你给它什么它就会乖乖地吐出什么。如果你的应用程序大多数函数都是由纯函数组成，那么你的程序测试、调试起来会非常方便

使用纯函数创建组件：

```react
// function
function Title (props) {
  return <h1>{ props.title }</h1>
}
// 箭头函数
const Title = ({ props }) => <div>{ props.title }</div>
```

对比下使用类组件方式创建的组件：

```react
// es6 类组件
class Title extends React.Component {
  render() {
    return <h1>{this.props.title}</h1>
  }
}
```

**通过对比，纯函数组件写法简单了，可以看出纯函数组件的特点:**

1.组件不会被实例化，整体渲染性能得到提升；
2.组件不能访问 this 对象；
3.组件无法访问生命周期的方法；
4.无状态组件只能访问输入的 props，无副作用。

**可以总结出纯函数组件的优点：**

1.无副作用；
2.占内存更小，首次 render 的性能更好；
3.语法更简洁，可读性好，逻辑简单，测试简单，代码量少，容易复用；
4.更佳的性能表现：因为函数组件中不需要进行生命周期的管理和状态管理，因此 React 并不需要进行某些特定的5.检查和内存分配，保证了性能。
6.当然，纯函数组件也有自己的短板，它无生命周期，且没有 this。

**高阶函数**

高阶函数: 若一个函数符合下面两个规范中的一个,该函数就是高阶函数

  1.若a函数,接受的参数是一个函数,那么a就可以称为高阶函数

  2.若a函数,调用的返回值依旧是一个函数,那么a就可以称之为高阶函数

  3.常见的高阶函数有:promise,setTimeout,arr.map等

## **高阶组件**

高阶组件就是一个没有副作用的纯函数。

- 高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件
- 高阶组件的作用:就是为了组件之间的**代码复用**。组件可能有着某些相同的逻辑，把这些逻辑抽离出来，放到高阶组件中进行复用。例如withRouter,connect
- 高阶组件包装的新组件和原来组件之间**通过 props 传递信息**，减少代码的重复程度。

## 高阶组件的应用

**增强props 不修改原有的代码情况下 添加新的props**

![img](https://cdn.nlark.com/yuque/0/2021/png/22330294/1638870843699-7e10f061-75c2-4a66-a302-9bec7d368578.png)

**应用场景2 登录鉴权**

![img](https://cdn.nlark.com/yuque/0/2021/png/22330294/1638774136606-0882cc2b-d859-4d38-b4c2-306bdc16b19a.png)

## vue和react区别?

**相同点**

- 都有组件化开发和虚拟DOM
- 都支持props进行父子组件间数据通信
- 都支持数据驱动试视图,不直接操作真实DOM,更新状态数据界面就自动更新
- 都支持服务器端渲染

**不同点**

- 数据绑定,vue实现了数据的双向绑定,react数据流动是单向的

- 组件写法不一样,react推荐的做法是jsx,也就是把html和css全都写进js里 

  ​                           vue推荐的做法是webpack+vue-loader的单文件组件格式 即html+css+js写在同一个文件

- state对象在react应用中是不可变的 需要使用setState方法更新状态 

  ​                 在vue中, state对象不是必须的,数据由data属性在vue对象中管理


- react严格上只针对MVC的view层 vue则是MVVM模式

## react中，函数式组件和类组件的优缺点

1.类组件的性能消耗比较大，因为类组件需要创建类组件的实例，而且不能销毁。

2.函数式组件性能消耗小，因为函数式组件不需要创建实例，渲染的时候就执行一下，得到返回的react元素后就直接把中间量全部都销毁。

函数式组件是不能有状态的，但是现在有了react hooks，也可能有状态了。

## react组件通信，跨组件通信

- 父组件向子组件通信：使用 props
- 子组件向父组件通信：使用 props 回调
- 非嵌套组件间通信：使用事件订阅、redux（集中式状态管理）
- 跨级组件间通信：使用 context 对象、redux（集中式状态管理）


## setState 是同步还是异步？

查了很多文档 官网说是异步的

React 内部将**同一事件响应函数**中的多个`setState`进行合并，减少`setState`的调用次数，也就能减少渲染的次数，提高性能。

 React 在合并多个`setState`时，若出现同名属性，会将**后面的同名属性**覆盖掉**前面的同名属性**。可以这么理解，对于同名属性，最终执行的的是**最后**的`setState`中的属性。



在 React 中直接使用的事件，如onChange、onClick等，都是由 React 封装后的事件，是合成事件，由 React 管理。

React 对于合成事件和生命周期函数，有一套性能优化机制，会合并多个setState，若出现同名属性，会将后面的同名属性覆盖掉前面的同名属性。

若越过 React 的性能优化机制，在原生事件、setTimeout中使用setState，就不归 React 管理了，写了几次setState，就会调用几次setState。



我的回答是执行过程代码同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，所以表现出来有时是同步，有时是“异步”。

**1.何时是同步，何时是异步呢？**

- 在合成事件和生命周期钩⼦函数中是异步的
- 在原⽣事件和 setTimeout 中是同步的

**2.那为什么会出现异步的情况呢？**

为了做性能优化，将 state 的更新延缓到最后批量合并再去渲染对于应用的性能优化是有极大好处的，如果每次的状态改变都去重新渲染真实 dom，那么它将带来巨大的性能消耗。

- setState 的异步并不是指内部由异步代码实现。其实，它本身执⾏的过程及代码都是同步的，只是由于合成事件和钩⼦函数的调⽤顺序在更新之前，因此导致了在合成事件和钩⼦函数中没法立刻拿到更新后的值，所以形成了所谓的异步。
- setState的批量更新优化也是建⽴在异步（合成事件、钩⼦函数）之上的，在原⽣事件和setTimeout中不会批量更新。在异步中，如果对同⼀个值进⾏多次setState，则它的批量更新策略会对其进⾏覆盖，只取最后⼀次的执⾏。如果同时setState多个不同的值，则会在更新时对其进⾏合并批量更新。

**3.那如何在表现出异步的函数里可以准确拿到更新后的 state 呢？**

通过第二个参数 setState(partialState, callback) 中的 callback 拿到更新后的结果。

或者可以通过给 setState 传递函数来表现出同步的情况：

![64006504899](C:\Users\86187\AppData\Local\Temp\1640065048997.png)

## 调用 setState 之后发生了什么？

React在调用setstate后，react会将传入的**参数对象**和组件**当前的状态**合并，触发**调和过程，**

在调和过程中，react会根据新的状态构建react元素树重新渲染整个UI界面，在得到元素树之后，react会自动计算新老节点的差异，根据差异对界面进行最小化重新渲染

## react-thunk原理

**概念**:引入thunk插件后，我们可以在actionCreators内部编写逻辑，处理请求结果。而不只是单纯的返回一个action对象。可以在actionCreators里通过返回一个函数，然后就可以在函数里编写某些异步操作了，等异步操作结束，最后通过传入的store.dispatch，发出action通知给Store要进行状态更新。

**thunk中间件的使用方法**

![64049889953](C:\Users\86187\AppData\Local\Temp\1640498899539.png)

react-thunk源码：

```react
function createThunkMiddleware(extraArgument) {
  return ({ dispatch, getState }) => next => action => {
    /**
     *如果ation是函数，就调用这个函数，并且传入dispatch和getState及 extraArgument 为参数
     *extraArgument是给返回函数传入的额外参数
     *后面applyMiddleware函数相当于是对dispatch(action)派发到reducer之前进行了拦截
     *拦截过程中就是经过了一系列中间件处理
     *reducer是个纯函数到达reducer的action必须是一个plain object类型
     *所以后面applyMiddleware函数处理完所有中间件之后返回的是一个普通的对象
     *react-thunk就是充分利用了applyMiddleware函数最后会返回普通对象的原理！！！
     *所以react-thunk的作用就只是将函数类型的action传递进了applyMiddleware！仅此而已！！
     *经典到不能再经典的中间件！
    */
    if (typeof action === 'function') {
     // 这里的dispatch是在applyMiddleware中改写过的
      return action(dispatch, getState, extraArgument);
    }
    

    // 如果传过来的是普通对象，直接调用下一个middleware
    return next(action);

  };
}

//向外暴露
const thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;

export default thunk;
```

## 自己封装过什么组件

**NavBar组件**

![64033349901](C:\Users\86187\AppData\Local\Temp\1640333499015.png)

**卡片组件**

在项目中，我在不同的页面会使用相同样式的代码，为了避免写多处重复的代码，也避免后期多处维护的弊端，我们可以将相同样式的代码自定义封装成组件，在不同的页面调用自定义组件即可。

1、先封装自定义组件

1）、新建CardList文件夹

2）、在CardList文件夹里新建index.js文件，并在index.js文件里书写如下代码

```
//index.js暴露组件CardList
import Card from './card';
import CardList from './cardList';
 
CardList.Card = Card;
export default CardList;
```

3）、在CardList文件夹里新建cardList.js文件，并在该文件下书写如下代码：

```
import { Component } from 'react';
import withRouter from 'umi/withRouter';
import style from './index.css';
 
/**
 * CardList组件内容
 * @param title 组件标题
 * @param extra 描述
 * @param children 内容
 * @param restProps 传入的自定义属性
 * @returns {*}
 * @constructor
 */
const CardList = ({title, extra, children, ...restProps})=>{
  return(
    <div>
      <div className={style.card2} {...restProps}>
        <nav>{title} <span className={style.details}>{extra}</span></nav>
        {React.Children.map(
          children,
          child => (child ? React.cloneElement(child, {  }) : child)
        )}
      </div>
    </div>
  )
}
export default CardList;
```

4）、在CardList文件夹里新建index.css文件,并在该文件里书写样式

```
.card2{
  height: auto;
  background-color: white;
  padding: 16px;
  border-bottom: 1px solid #ddd;
}
.card2 nav{
  color: red;
  text-align: left;
  font-family: 'Arial Normal', 'Arial';
  font-weight: 400;
  font-style: normal;
  font-size: 16px;
  color: #333333;
  margin-bottom: 0.2rem;
}
.card2 div{
  color: #999999;
  font-family: 'Arial Normal', 'Arial';
  font-weight: 400;
  font-style: normal;
  font-size: 14px;
}
.list1{
  text-align: left;
  display: flex;
}
.list1>span{
  /*width: 50%;*/
  display: inline-block;
  vertical-align: top;
  /*white-space:nowrap;*/
  /*overflow:hidden;*/
  /*text-overflow : ellipsis;*/
  flex: 1;
}
 
.details{
  float: right;
  color:#2DA9FA;
}
```

5）、在CardList文件夹里新建card.js文件，并在该文件下书写如下代码：

```
import { Component } from 'react';
import withRouter from 'umi/withRouter';
import style from './index.css';
 
/**
 * 子组件内容
 * @param title 标题
 * @param children 内容
 * @param restProps 传入的自定义属性
 * @returns {*}
 * @constructor
 */
const Card = ({title,children,...restProps})=>{
  return(
    <div>
      <div className={style.list1} {...restProps}>
        <span>{title} {children}</span>
      </div>
    </div>
  )
}
export default Card;
```

6）、用法如下：

```
import { Component } from 'react';
import withRouter from 'umi/withRouter';
import router from 'umi/router';
import CardList from './CardList/index';
const {Card} = CardList;
 
class Index extends Component{
    state ={
        loading:false,
        totalList:[{"trainCount":2360,"stationName":"北京"},{"trainCount":152,"stationName":"北京东"},{"trainCount":4248,"stationName":"北京南"},{"trainCount":3336,"stationName":"北京西"},{"trainCount":56,"stationName":"通州"}],
     }
 
    render() {
        let info = <div>
                       {
                           this.state.totalList.map((obj,index)=>{
                               return <CardList title={`${obj.stationName}站`} extra={<span onClick={()=>{this.jump({obj})}}>查看当天数据</span>} key={index}>
                                          <Card title="当天进站列车：">{obj.trainCount||0} 车次</Card>
                                      </CardList>
                            })
                       }
                    </div>
        return (
            <div>
                {info}
            </div>
        )
    }
 
}
export default withRouter(Index);
```

7）、效果如下：

![自定义组件](https://img-blog.csdnimg.cn/20190304094847419.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2d1b3lhbmd5YW5nMTIzNDU2,size_16,color_FFFFFF,t_70)

## 自己封装过什么hooks

**useLocalStorage**

这个 Hook 主要有两个参数，一个是 `key`，一个是 `value`。

返回的值为localStorage存的值和改变localStorage存的值的方法

我们创建将与 localStorage 同步的React状态变量。

```react
const [state, setState] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.log(error);
      return initialValue;
    }
  });
```

在这里，我们使用惰性初始化来读取 `localStorage` 以获取键的值，如果找到该值，则解析该值，否则返回传入的`initialValue`。

如果在读取 `localStorage` 时出现错误，我们只记录一个错误并返回初始值。

此函数同时更新React状态和 `localStorage` 中的相应键/值。

最后，我们返回状态值和我们的自定义更新函数。

现在可以使用`useLocalStorage` hook 将组件中的任何数据持久化到`localStorage`中。

```react
import { useState } from 'react';

const useLocalStorage = (key = '', initialValue = '') => {
  const [state, setState] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      return initialValue;
    }
  });

  const setLocalStorageState = newState => {
    try {
      const newStateValue =
        typeof newState === 'function' ? newState(state) : newState;
      setState(newStateValue);
      window.localStorage.setItem(key, JSON.stringify(newStateValue));
    } catch (error) {
      console.error(`Unable to store new value for ${key} in localStorage.`);
    }
  };

  return [state, setLocalStorageState];
};

export default useLocalStorage;

const [appSettings, setAppSettings] = useLocalStorage(
    'app-settings',
    defaultSettings
  );
```

**useFetch**

获取数据是我每次创建React应用时都会做的事情。我甚至在一个应用程序中进行了好多个这样的重复获取。

不管我们选择哪种方式来获取数据，Axios、Fetch API，还是其他，我们很有可能在React组件序中一次又一次地编写相同的代码。

这个 Hook 接受两个参数，一个是获取数据所需查询的**URL**，另一个是表示要应用于请求的选项的对象**options**。

我们使用 Fetch API来发出请求。我们会传递`URL`和 `options`。一旦 Promise 被解决，我们就通过解析响应体来检索数据。为此，我们使用`json()`方法。获取到的数据存储在一个React state 变量中

这里，我们还需要处理网络错误，以防我们的请求出错。所以我们要用另一个 `state` 变量来存储错误。这样我们就能从 Hook 中返回它并能够判断是否发生了错误

最后，向用户表明异步请求的状态通常是一个好做法，比如在呈现结果之前显示 loading。

因此，我们添加第三个 state 变量来跟踪请求的状态。在请求之前，将`loading`设置为`true`，并在请求之后完成后设置为`false`。

```react
import { useState, useEffect } from 'react';

const useFetch = (url = '', options = null) => {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);
  const [loading, setLoading] = useState(false);

  useEffect(() => {
    let isMounted = true;

    setLoading(true);

    fetch(url, options)
      .then(res => res.json())
      .then(data => {
        if (isMounted) {
          setData(data);
          setError(null);
        }
      })
      .catch(error => {
        if (isMounted) {
          setError(error);
          setData(null);
        }
      })
      .finally(() => isMounted && setLoading(false));

    return () => (isMounted = false);
  }, [url, options]);

  return { loading, error, data };
};

export default useFetch;

const App = () => {
  const { loading, error, data = [] } = useFetch(
    'https://hn.algolia.com/api/v1/search?query=react'
  );
```

**useEventListener**

这个 Hook 负责在组件内部设置和清理事件监听器。

这样，我们就不需要每次添加事件监听器,做重复的工作。

这个函数有几个参数，`eventType` 事件类型，`listener` 监听函数，`target` 监听对象，`options` 可选参数。

首先，我们需要确保`target` 是否支持`addEventListener`方法。否则，我们什么也不做。

然后，我们可以添加实际的事件监听器并在卸载函数中删除它。

```react
import { useEffect, useRef } from 'react';

const useEventListener = (
  eventType = '',
  listener = () => null,
  target = null,
  options = null
) => {
  const savedListener = useRef();

  useEffect(() => {
    savedListener.current = listener;
  }, [listener]);

  useEffect(() => {
    if (!target?.addEventListener) return;

    const eventListener = event => savedListener.current(event);

    target.addEventListener(eventType, eventListener, options);

    return () => {
      target.removeEventListener(eventType, eventListener, options);
    };
  }, [eventType, target, options]);
};

export default useEventListener;



useEventListener(
    'mousedown',
    event => {
      if (event.defaultPrevented) {
        return; // Do nothing if the event was already processed
      }
      if (dialogRef.current && !dialogRef.current.contains(event.target)) {
        console.log('Click outside detected -> closing dialog...');
        onClose();
      }
    },
    window
  );
	
```

## react如何实现路由懒加载

- 1.第一种自己定义组件在加载时调用
  
- import(‘../login.js’)方法,默认能实现异步加载，返回的是一个promise
  
- 2.使用React自带的 Suspense,lazy实现懒加载

- 路由懒加载主要是解决项目打包之后首屏加载过慢的问题，

  React.lazy(()=>import('组件路径'))  +   <Suspense>

  最常用的是通过`import()`来实现它。然后通过Webpack编译打包后，会把每个路由组件的代码分割成一一个js文件，初始化时不会加载这些js文件，只当激活路由组件才会去加载对应的js文件（按需加载对应的路由组件js文件。）

- ![64024559054](C:\Users\86187\AppData\Local\Temp\1640245590548.png)



## 函数式组件优点

- Hooks是比HOC和render props更优雅的逻辑复用方式
- 函数式组件的心智模型更加“声明式”。hooks（主要是useEffect）取代了生命周期的概念（减少API），让开发者的代码更加“声明化”
- 函数式组件的心智模型更加“函数式”
- 让函数式组件可以保存状态
- 类组件性能消耗比较大，因为类组件要创建实例，而且不能销毁。函数式组件渲染的时候执行一下，得到react元素后，中间变量部分会销毁


## react生命周期



![img](https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fupload-images.jianshu.io%2Fupload_images%2F13617804-d074e34a83769a92.png&refer=http%3A%2F%2Fupload-images.jianshu.io&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1641449201&t=3e2a4984e45dc6aecb409a09359fa1b1)

![img](https://img-blog.csdnimg.cn/c9668cce90ab4840b7a2be0c60f0a86b.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54yr6ICB5p2_55qE6LGG,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)

componentWillMount  组件渲染之前调用

componentDidMount  在第一次渲染之后调用

componentWillReceiveProps  在组件接收到一个新的props时调用

shouldComponentUpdate  判断组件是否更新html

componentWillupdate  组件即将更新html时调用

componentDidupdate  在组件完成更新后立即调用

componentWillUnmount  在组件移除之前调用

**挂载卸载过程**

1. 父constructor
2. 父componentWillMount
3. 父render
4. 子constructor
5. 子componentWillMount
6. 子render
7. 子componentDidMount
8. 父componentDidMount

**1.1.constructor()**

constructor()中完成了React数据的初始化，它接受两个参数：props和context，当想在函数内部使用这两个参数时，需使用super()传入这两个参数。
 注意：只要使用了constructor()就必须写super(),否则会导致this指向错误。

**1.2.componentWillMount()**

componentWillMount()一般用的比较少，它更多的是在服务端渲染时使用。它代表的过程是组件已经经历了constructor()初始化数据后，但是还未渲染DOM时。

**1.3.componentDidMount()**

组件第一次渲染完成，此时dom节点已经生成，可以在这里调用ajax请求，返回数据setState后组件会重新渲染

**1.4.componentWillUnmount ()**

在此处完成组件的卸载和数据的销毁。

1. clear你在组建中所有的setTimeout,setInterval
2. 移除所有组建中的监听 removeEventListener
3. 有时候我们会碰到这个warning:

```csharp
Can only update a mounted or mounting component. This usually      means you called setState() on an unmounted component. This is a   no-op. Please check the code for the undefined component.
```

原因：因为你在组件中的ajax请求返回setState,而你组件销毁的时候，请求还未完成，因此会报warning
 解决方法：

```kotlin
componentDidMount() {
    this.isMount === true
    axios.post().then((res) => {
    this.isMount && this.setState({   // 增加条件ismount为true时
      aaa:res
    })
})
}
componentWillUnmount() {
    this.isMount === false
}
```

**2. 更新过程**

**2.1. componentWillReceiveProps (nextProps)**

1. 在接受父组件改变后的props需要重新渲染组件时用到的比较多
2. 接受一个参数nextProps
3. 通过对比nextProps和this.props，将nextProps的state为当前组件的state，从而重新渲染组件

```kotlin
  componentWillReceiveProps (nextProps) {
    nextProps.openNotice !== this.props.openNotice&&this.setState({
        openNotice:nextProps.openNotice
    }，() => {
      console.log(this.state.openNotice:nextProps)
      //将state更新为nextProps,在setState的第二个参数（回调）可以打         印出新的state
  })
}
```

**2.2.shouldComponentUpdate(nextProps,nextState)**

1. 主要用于性能优化(部分更新)
2. 唯一用于控制组件重新渲染的生命周期，由于在react中，setState以后，state发生变化，组件会进入重新渲染的流程，在这里return false可以阻止组件的更新
3. 因为react父组件的重新渲染会导致其所有子组件的重新渲染，这个时候其实我们是不需要所有子组件都跟着重新渲染的，因此需要在子组件的该生命周期中做判断

**2.3.componentWillUpdate (nextProps,nextState)**

shouldComponentUpdate返回true以后，组件进入重新渲染的流程，进入componentWillUpdate,这里同样可以拿到nextProps和nextState。

**2.4.componentDidUpdate(prevProps,prevState)**

组件更新完毕后，react只会在第一次初始化成功会进入componentDidmount,之后每次重新渲染后都会进入这个生命周期，这里可以拿到prevProps和prevState，即更新前的props和state。

**2.5.render()**

render函数会插入jsx生成的dom结构，react会生成一份虚拟dom树，在每一次组件更新时，在此react会通过其diff算法比较更新前后的新旧DOM树，比较以后，找到最小的有差异的DOM节点，并重新渲染。

**3. React新增的生命周期(个人补充)**

![img](https:////upload-images.jianshu.io/upload_images/16775500-102dbe772034e8fa.png?imageMogr2/auto-orient/strip|imageView2/2/w/1002/format/webp)

React新增生命周期

**3.1. getDerivedStateFromProps(nextProps, prevState)**

代替componentWillReceiveProps()。
 老版本中的componentWillReceiveProps()方法判断前后两个 props 是否相同，如果不同再将新的 props 更新到相应的 state 上去。这样做一来会破坏 state 数据的单一数据源，导致组件状态变得不可预测，另一方面也会增加组件的重绘次数。

这两者最大的不同就是:
 在 componentWillReceiveProps 中，我们一般会做以下两件事，一是根据 props 来更新 state，二是触发一些回调，如动画或页面跳转等。

1. 在老版本的 React 中，这两件事我们都需要在 componentWillReceiveProps 中去做。
2. 而在新版本中，官方将更新 state 与触发回调重新分配到了 getDerivedStateFromProps 与 componentDidUpdate 中，使得组件整体的更新逻辑更为清晰。而且在 getDerivedStateFromProps 中还禁止了组件去访问 this.props，强制让开发者去比较 nextProps 与 prevState 中的值，以确保当开发者用到 getDerivedStateFromProps 这个生命周期函数时，就是在根据当前的 props 来更新组件的 state，而不是去做其他一些让组件自身状态变得更加不可预测的事情。

**3.2. getSnapshotBeforeUpdate(prevProps, prevState)**

代替componentWillUpdate。
 常见的 componentWillUpdate 的用例是在组件更新前，读取当前某个 DOM 元素的状态，并在 componentDidUpdate 中进行相应的处理。
 这两者的区别在于：

1. 在 React 开启异步渲染模式后，在 render 阶段读取到的 DOM 元素状态并不总是和 commit 阶段相同，这就导致在
   componentDidUpdate 中使用 componentWillUpdate 中读取到的 DOM 元素状态是不安全的，因为这时的值很有可能已经失效了。
2. getSnapshotBeforeUpdate 会在最终的 render 之前被调用，也就是说在 getSnapshotBeforeUpdate 中读取到的 DOM 元素状态是可以保证与 componentDidUpdate 中一致的。
   此生命周期返回的任何值都将作为参数传递给componentDidUpdate（）

## react 父子组件交互时生命周期的执行顺序

不管父组件有没有把数据传递给子组件，只要父组件setState，都会走一遍子组件的更新周期

只要在父组件的shouldComponentUpdate(nextProps, nextState)中return false则子组件不会进行更新re-render，所有更新流程都不执行了

**父子组件生命周期函数执行顺序：**

进入页面：parent-constructor -> parent-getDerivedStateFromProps -> parent-render -> child-constructor -> child-getDerivedStateFromProps -> child-render -> child-componentDidMount -> parent-componentDidMount

更新页面：parent-getDerivedStateFromProps -> parent-shouldComponentUpdate -> parent-render -> child-getDerivedStateFromProps -> child-shouldComponentUpdate -> child-render -> child-componentDidUpdate -> parent-componentDidUpdate

销毁页面：parent-componentWillUnmount -> child-componentWillUnmount

## redux流程图

![img](https://www.ruanyifeng.com/blogimg/asset/2016/bg2016091802.jpg)

它会定义 一个行为 action，包含要执行的动作类型和动作数据，然后交给dispatch 进行分发，dispatch会交给store，store 相当于一个管理者，管理各个部分，store 将 action 和 previousState 传递给 Reducers ，Reducers 处理action，返回新的 state ，交还给 store，组件可以通过 getState() 方法得到 redux 管理的状态.

## react-redux这个库是如何工作的？

- 核心概念
  - Provider
    - Provider 的作⽤是从最外部封装了整个应⽤，并向 connect 模块传递 store 。
  - connect
    - 负责将 React 和 Redux 关联起来
- 流程
  - 获取 state：connect 先通过 context 来获取存放在 Provider 中的 store，然后通过 store.getState() 来获取整个 store tree 上所存放的 state
  - 包装原组件：connect 将 state 和 action 通过 props 传⼊到原组件的内部，并调用 wrapWithConnect 函数来包装和返回⼀个 Connect 对象，Connect 对象重新 render 外部传⼊的原组件，并把 connect 中传⼊的 mapStateToProps 和 mapDispatchToProps 与组件原有的 props 合并后，通过属性的⽅式传给包装组件
  - 监听 store tree 变化：connect 缓存了 store tree 中 state 的状态，通过对比当前 state 和变更前 state，确定是否需要调⽤ this.setState() ⽅法，以此触发 Connect 及其⼦组件的重新渲染

## 为什么reducer必须是纯函数

**纯函数**

一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数。

- 函数的返回结果只依赖于它的参数。
- 函数执行过程里面没有副作用:一个函数执行过程对产生了外部可观察的变化那么就说这个函数是有副作用的。
- 纯函数很严格，也就是说你几乎除了计算数据以外什么都不能干，计算的时候还不能依赖除了函数参数以外的数据



Redux接收一个给定的state（对象），然后通过循环将state的每一部分传递给每个对应的reducer。如果有发生任何改变，reducer将返回一个新的对象。如果不发生任何变化，reducer将返回旧的state。

**Redux只通过比较新旧两个对象的存储位置来比较新旧两个对象是否相同（译者注：也就是Javascript对象浅比较）。如果你在reducer内部直接修改旧的state对象的属性值，那么新的state和旧的state将都指向同一个对象。因此Redux认为没有任何改变，返回的state将为旧的state。**

因为比较两个Javascript对象所有的属性是否相同的的唯一方法是对它们进行深比较。但是深比较在真实的应用当中代价昂贵，因为通常js的对象都很大，同时需要比较的次数很多。

因此一个有效的解决方法是作出一个规定：无论何时发生变化时，开发者都要创建一个新的对象，然后将新对象传递出去。同时，当没有任何变化发生时，开发者发送回旧的对象。也就是说，新的对象代表新的state。

必须注意到你只能使用slice（译者注：此处slice类似数组的slice方法，具体可以使用本文例子中解构赋值等方法进行slice）或者类似的机制去复制旧的值到新的对象里。

现在使用了新的策略之后，你能够比较两个对象通过使用!==比较两个对象的存储位置而不是比较两个对象的所有属性。同时当两个对象不同的时候，你就能知道新的对象已经改变了旧的state（也就是说，JavaScript对象当中的某些属性的值发生了变化）。这正是Redux所采取的策略。

## Histoty和Hash------------------

**hash模式和history模式的不同**

最直观的区别就是在url中 hash 带了一个很丑的 # 而history是没有#的

hash模式背后的原理是`onhashchange`事件,可以在window对象上监听这个事件，hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。

history —— 利用了 HTML5新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。浏览器从 / 到 /user是会向服务器发送 request 的。所以服务器端是要做特殊配置的；否则，页面将无法正常访问。

pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；
pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；
pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；
pushState() 可额外设置 title 属性供后续使用。

**React中的路由问题（官网）：**Hash 历史记录不支持 `location.key` 或 `location.state`。在以前的版本中，我们试图填补行为，但存在我们无法解决的边缘案例。 任何需要此行为的代码或插件都将无法使用。由于此技术仅用于支持传统浏览器，因此我们鼓励您配置服务器以便与 `<BrowserHistory>` 配合使用。

**上线后出现的问题及解决办法**

跳转后刷新或者回跳，会报一个404的错误，找不到指定的路由,最后后端去指向正确的路由 加了/hd/xxx 去匹配是否有这个/hd/{:path} 才得以解决，只需在后端（Apache 或 Nginx）进行简单的路由配置，同时搭配前端路由的 404 页面支持。(比如用的 express 的话，你需要 handle 所有的路由 app.get('*', (req, res) => { ... })；
使用了 nginx 的话，nginx也要做相应的配置)

## BrowserRouter与HashRouter的区别

​            1.底层原理不一样：

​                        BrowserRouter使用的是H5的history API，不兼容IE9及以下版本。

​                        HashRouter使用的是URL的哈希值。

​            2.path表现形式不一样

​                        BrowserRouter的路径中没有#,例如：localhost:3000/demo/test

​                        HashRouter的路径包含#,例如：localhost:3000/#/demo/test

​            3.刷新后对路由state参数的影响

​                        (1).BrowserRouter没有任何影响，因为state保存在history对象中。

​                        (2).HashRouter刷新后会导致路由state参数的丢失！！！

​            4.备注：HashRouter可以用于解决一些路径错误相关的问题。

## react路由守卫

https://www.jianshu.com/p/677433245697

下面是我的实现方式，首先，准备一份路由表，包含了路由的地址，组件以及是否需要权限校验：

```tsx
import { HomePage } from '../pages/home/home.page';
import { LoginPage } from '../pages/login/login.page';
import { ErrorPage } from '../pages/error/error.page';

interface routerConfigModel {
    path:string,
    component?:any,
    auth?:boolean
}
export const routerConfig:routerConfigModel[] = [
    {
        path:'/',
        component:HomePage,
        auth:true,
    },{
        path:'/home',
        component:HomePage,
        auth:true,
    },{
        path:'/login',
        component:LoginPage,
    },{
        path:'/404',
        component:ErrorPage
    }
];
```

将 `auth` 设置为 `true`，表示该路由需要权限校验。
 然后，定义 `Router` 组件，该组件是经过高阶组件包装后的结果：



```jsx
import * as React from 'react';
import { HashRouter,Switch } from 'react-router-dom';
import { FrontendAuth } from '../components/frontend-auth/frontend-auth.component'
import { routerConfig } from './router.config'

export class Router extends React.Component{
    render(){
        return(
            <HashRouter>
                <Switch>
                    <FrontendAuth config={routerConfig} />
                </Switch>
            </HashRouter>
        );
    }
}
```

所有的路由跳转，都交给 `FrontendAuth` 高阶组件代理完成。下面是 `FrontendAuth` 组件的实现：



```tsx
import * as React from 'react';
import { Route,Redirect } from 'react-router-dom';
import { propsModel } from './frontend-auth.model'

export class FrontendAuth extends React.Component<any,propsModel>{
    render(){
        const { location,config } = this.props;
        const { pathname } = location;
        const isLogin = localStorage.getItem('__config_center_token')
        
        // 如果该路由不用进行权限校验，登录状态下登陆页除外
        // 因为登陆后，无法跳转到登陆页
        // 这部分代码，是为了在非登陆状态下，访问不需要权限校验的路由
        const targetRouterConfig = config.find((v:any) => v.path === pathname);
        if(targetRouterConfig && !targetRouterConfig.auth && !isLogin){
            const { component } = targetRouterConfig;
            return <Route exact path={pathname} component={component} />
        }

        if(isLogin){
            // 如果是登陆状态，想要跳转到登陆，重定向到主页
            if(pathname === '/login'){
                return <Redirect to='/' />
            }else{
                // 如果路由合法，就跳转到相应的路由
                if(targetRouterConfig){
                    return <Route path={pathname} component={targetRouterConfig.component} />
                }else{
                    // 如果路由不合法，重定向到 404 页面
                    return <Redirect to='/404' />
                }
            }
        }else{
            // 非登陆状态下，当路由合法时且需要权限校验时，跳转到登陆页面，要求登陆
            if(targetRouterConfig && targetRouterConfig.auth){
                return <Redirect to='/login' />
            }else{
                // 非登陆状态下，路由不合法时，重定向至 404
                return <Redirect to='/404' />
            }
        }
    }
}
```

以及对应的 Model：



```css
export interface propsModel {
    config:any[],
}
```

页面上的路由跳转，都由 `FrontendAuth` 高阶组件代理了，在 `Switch` 组件内部，不再是 `Route` 组件，而只有一个 `FrontendAuth` 组件。
 `FrontendAuth` 组件接收一个名为 `config` 的 `Props`，这是一份路由表。同时，由于 `FrontendAuth` 组件放在了 `Switch` 组件内部，React Router 还自动为 `FrontendAuth` 注入了 `location` 属性，当地址栏的路由发生变化时，就会触发 `location` 属性对象上的 `pathname` 属性发生变化，从而触发 `FrontendAuth` 的更新（调用 `render` 函数）。
 `FrontendAuth` 的 `render` 函数中，根据 `pathname` 查找到路由表中的相关配置，如果该配置中指定了无需校验，就直接返回相应的 `Route` 组件。
 如果查找到的配置需要进行校验，再根据是否登陆进行处理，具体可以查看代码中的注释。

**总结一下，实现路由守卫需要考虑到以下的问题：**

1. 未登录情况下，访问不需要权限校验的合法页面：允许访问
2. 登陆情况下，访问登陆页面：禁止访问，跳转至主页
3. 登陆情况下，访问除登陆页以外的合法页面：允许访问
4. 登陆情况下，访问所有的非法页面：禁止访问，跳转至 404
5. 未登录情况下，访问需要权限校验的页面：禁止访问，跳转至登陆页
6. 未登录情况下，访问所有的非法页面：禁止访问，跳转至 404

## 向路由组件传递参数

​                1.params参数

​                            路由链接(携带参数)：<Link   to='/demo/test/tom/18'} >详情</Link>

​                            注册路由(声明接收)：<Route  path="/demo/test/:name/:age" component = {Test} />

​                            接收参数：this.props.match.params

​                2.search参数 

​                            路由链接(携带参数)：<Link to='/demo/test?name=tom&age=18'}>详情</Link>

​                            注册路由(无需声明，正常注册即可)：<Route path="/demo/test" component={Test}/>

​                            接收参数：this.props.location.search

​                            备注：获取到的search是urlencoded编码字符串，需要借助querystring解析

​                3.state参数

​                            路由链接(携带参数)：<Link to={{ pathname:'/demo/test', state:{name:'tom',age:18}}}>详情</Link>

​                            注册路由(无需声明，正常注册即可)：<Route path="/demo/test" component={Test}/>

​                            接收参数：this.props.location.state

​                            备注：刷新也可以保留住参数



## React中使用Suspense

**疑问**

问：React Suspense有什么用呢？

答：在动态导入的帮助下，React Suspense让我们轻松定义延迟加载的组件。

 

**代码demo**

```
const OtherComponent = React.lazy(() => import('./OtherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <OtherComponent />
      </Suspense>
    </div>
  );
}
```

> ```
> OtherComponent
> ```
>
> 是通过懒加载加载进来的，所以渲染页面的时候可能会有延迟，但使用了
>
> ```
> Suspense
> ```
>
> 之后，可优化交互。
>
> 在`<OtherComponent />`外面使用`Suspense`标签，并在`fallback`中声明`OtherComponent`加载完成前做的事，即可优化整个页面的交互

> `fallback` 属性接受任何在组件加载过程中你想展示的 React 元素。你可以将 `Suspense` 组件置于懒加载组件之上的任何位置。你甚至可以用一个 `Suspense` 组件包裹多个懒加载组件。

 

```
const OtherComponent = React.lazy(() => import('./OtherComponent'));
const AnotherComponent = React.lazy(() => import('./AnotherComponent'));

function MyComponent() {
  return (
    <div>
      <Suspense fallback={<div>Loading...</div>}>
        <section>
          <OtherComponent />
          <AnotherComponent />
        </section>
      </Suspense>
    </div>
  );
}
```

## Immutable数据流

**什么是Immutable Data？**

Immutable Data 就是一旦创建，就不能再被更改的数据。对 Immutable 对象的任何修改或添加删除操作都会返回一个新的 Immutable 对象。Immutable 实现的原理是 **Persistent Data Structure（持久化数据结构）**，也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免 deepCopy 把所有节点都复制一遍带来的性能损耗，Immutable 使用了[Structural Sharing（结构共享）](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F27133830%3Fgroup_id%3D851585269567213568)，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享

**immutable优化性能的方式**

`immutable`实现的原理是：`持久化数据结构`，也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了`避免deepCopy` 把所有节点都复制一遍带来的`性能损耗`。

`immutable`使用了`结构共享`，即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其它节点则进行共享。



**immutable出现的背景**

一定记得`Redux`中的`reducer`是基于纯函数设计的，要求返回的状态数据(对象或数组)，需要先深拷贝一份（目的是：防止影响老状态），再根据自己的开发需求对其拷贝后的值操作？

来看下面这样一个例子：

```
let list = [
  { name: 'house', age: 18}
]

let newList = [...list];
newList[0].name = "xiaoming";

console.log(list[0].name); // "xiaoming"
复制代码
```

显然上面例子中的原数组`list`，被我们不轻易间串改了，其实原因很简单，就是因为ES6中的展开运算符`[...list]`是一个浅拷贝，浅拷贝的意思就是只复制对象或数组的第一级内容。

在上面中，可以发现经过展开运算符的浅拷贝，只复制了其内层引用类型的地址，当通过索引找到其引用地址，并改变它的时候，改的就是`list`原数组本身。

当然，有的小伙伴可以想到：当访问到对象的属性值的时候，将属性值再进行递归对比，这样就达到了深层对比的效果，但是想想一种极端的情况，就是在属性有一万条的时候，只有最后一个属性发生了变化，那我们就不得已将一万条属性都遍历。这是非常浪费性能的。

回到问题的本质，无论是直接用浅层比对，还是进行深层比对，我们最终想知道的就是原对象里的属性有无改变。

在这样的条件下，immutable 数据应运而生。

**什么是immutable数据？**

**immutable数据一种利用`结构共享`形成的`持久化数据结构`，一旦有部分被修改，那么将会返回一个全新的对象，并且原来相同的节点会直接共享。**

每次修改一个 immutable 对象时都会创建一个新的不可变的对象，在新对象上操作并 不会影响到原对象的数据。

具体点来说，**immutable** 对象数据内部采用是多叉树的结构，凡是有节点被改变，那么它和与它相关的所有`上级节点`都`更新`。

用一张动图来模拟一下这个过程：

![63991501244](C:\Users\86187\AppData\Local\Temp\1639915012449.png)immutable修改节点更新引用过程

是吧！`只更新了父节点`，比直接比对所有的属性简直强太多，并且更新后返回了一个`全新的引用`，即使是浅比对也能感知到数据的改变。

因此，采用 **immutable** 既能够最大效率地更新数据结构，又能够和现有的 React中的 **PureComponent (memo)** 顺利对接，感知到状态的变化，是提高 `React 渲染性能的极佳方案`。

不过，immutable 也有一些被开发者吐槽的点，首先是 `immutable 对象`和 `JS 对象`要注意转换，不能混用，这个大家注意适当的时候调用 `toJS` 或者 `fromJS` 即可，问题并不大。

**immutable性能优化体现在哪里**

![63991504276](C:\Users\86187\AppData\Local\Temp\1639915042761.png)

immutable优化性能

与React中的 **PureComponent(memo)** 相结合，我们知道`PureComponent`能够在内部帮我们比较`新props`跟`旧props`，`新state`和`旧state`，如果`值相等`或者`对象含有的相同的属性、且属性值相等`，便确定`shouldComponentUpdate`返回true或者false，从而判断是否再次渲染`render`函数。

看上述代码，我们可以看出来，当代码中使用`immutable`第三库的时候，可以精确地`深拷贝` a 对象，改`a对象`中的`select`属性赋值给`b`之后，并不会影响`原对象a`，而`b`的`select`属性变为了新值。

如果上述`select`属性给一个组件用，因为其值被改变了，导致`shouldComponentUpdate`应该返回true，而`filter`属性给另一个组件用，通过判断，并无变化，导致`shouldComponentUpdate`应该返回false，故此组件就避免了`重复的diff算法对比`，大大提高了React中的性能优化。

这么好用的第三方库，我们来看一下它的基本用法：

**immutable中常用类型**

（1）Map() 包裹对象

```
const { Map } = require('immutable'); 
const map1 = Map({ a: 1, b: 2, c: 3 }); 
const map2 = map1.set('b', 50);

console.log(map1.get('b')); // 2
console.log(map2.get('b')); // 50
复制代码
```

（2）List() 包裹数组

```
const { List } = require('immutable');

const list1 = List([ 1, 2 ]); 
const list2 = list1.push(3, 4, 5);  // [1,2,3,4,5]
const list3 = list2.unshift(0);    // [0,1,2,3,4,5]
const list4 = list1.concat(list2, list3); // [1,2,3,4,5,0,1,2,3,4,5]

//push, set, unshift or splice 都可以直接用，返回一个新的immutable对象
复制代码
```

（3）merge() 连接对象 | concat() 连接数组

```
const { Map, List } = require('immutable');

const map1 = Map({ a: 1, b: 2, c: 3, d: 4 });
const map2 = Map({ c: 10, a: 20, t: 30 });
const obj = { d: 100, o: 200, g: 300 };

const map3 = map1.merge(map2, obj);
// Map { a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 }

const list1 = List([ 1, 2, 3 ]);
const list2 = List([ 4, 5, 6 ]);

const list3 = list1.concat(list2, array);
// List [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
复制代码
```

（4）toJS() 把immutable对象转换为js对象

```
const { Map, List } = require('immutable');

const deep = Map({ a: 1, b: 2, c: List([ 3, 4, 5 ]) });
console.log(deep.toObject());   // { a: 1, b: 2, c: List [ 3, 4, 5 ] }
console.log(deep.toArray());    // [ 1, 2, List [ 3, 4, 5 ] ]
console.log(deep.toJS());       // { a: 1, b: 2, c: [ 3, 4, 5 ] }
JSON.stringify(deep);           // '{"a":1,"b":2,"c":[3,4,5]}'
复制代码
```

（5）fromJS() 包裹 js对象转换为immutable对象

```
const { fromJS } = require('immutable');

const nested = fromJS({ a: { b: { c: [ 3, 4, 5 ] } } });
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ] } } }

const nested2 = nested.mergeDeep({ a: { b: { d: 6 } } });
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }

console.log(nested2.getIn([ 'a', 'b', 'd' ])); // 6
//如果取一级属性 直接通过get方法，如果取多级属性 getIn(["a","b","c"]])

// setIn 设置新的值
const nested3 = nested2.setIn([ 'a', 'b', 'd' ], "kerwin");
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: "kerwin" } } }

// updateIn 回调函数更新
const nested3 = nested2.updateIn([ 'a', 'b', 'd' ], value => value + 1);
console.log(nested3);
// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 7 } } }

const nested4 = nested3.updateIn([ 'a', 'b', 'c' ], list => list.push(6));
// Map { a: Map { b: Map { c: List [ 3, 4, 5, 6 ], d: 7 } } }
复制代码
```

相对较全的`immutable`一些常用方法，都在这里给大家总结了，大家在项目中经常用就可以熟练掌握了。



**immutable+Redux的开发方式**

情况1：未使用`immutable`时

下面的代码的情况十分危险，不建议这样用，因为一旦当`newStateList`中的类型较为复杂（包含引用类型），且需要修改`newStateList`时，就会发生报错，因为`[...xxx, ...xxx]`是浅拷贝，会影响原来的状态。

![63991506301](C:\Users\86187\AppData\Local\Temp\1639915063018.png)

情况2：使用`immutable`时

通过store中传递过来的老状态`prevState`先转化为`immutable`对象，对深拷贝之后的对象，再进行修改等操作时，不会影响原状态，最后再通过`toJS()`转换为js对象即可

![63991509896](C:\Users\86187\AppData\Local\Temp\1639915098967.png)

**本文总结**

> immutable并没有深层比较，因为深层比较的开销是很大的。

> immutable数据调用set方法修改的时候仅仅`修改本节点`和它上面所有的`相关上层节点`，保证了`不一样的引用`，也更新了数据。更重要的是，它避免了无关数据的比对，提高了性能。

